{
  "when": "2025-11-26T17:34:22.335Z",
  "testFilePath": "/Users/leonardspeiser/Projects/shadow-plugin/UnitTests/generated.test.ts",
  "runResult": {
    "passed": 0,
    "failed": 0,
    "output": "{\"numFailedTestSuites\":1,\"numFailedTests\":0,\"numPassedTestSuites\":0,\"numPassedTests\":0,\"numPendingTestSuites\":0,\"numPendingTests\":0,\"numRuntimeErrorTestSuites\":1,\"numTodoTests\":0,\"numTotalTestSuites\":1,\"numTotalTests\":0,\"openHandles\":[],\"snapshot\":{\"added\":0,\"didUpdate\":false,\"failure\":false,\"filesAdded\":0,\"filesRemoved\":0,\"filesRemovedList\":[],\"filesUnmatched\":0,\"filesUpdated\":0,\"matched\":0,\"total\":0,\"unchecked\":0,\"uncheckedKeysByFile\":[],\"unmatched\":0,\"updated\":0},\"startTime\":1764178461229,\"success\":false,\"testResults\":[{\"assertionResults\":[],\"coverage\":{},\"endTime\":1764178462315,\"message\":\"  â— Test suite failed to run\\n\\n    \\u001b[96mUnitTests/generated.test.ts\\u001b[0m:\\u001b[93m73\\u001b[0m:\\u001b[93m9\\u001b[0m - \\u001b[91merror\\u001b[0m\\u001b[90m TS2451: \\u001b[0mCannot redeclare block-scoped variable 'sendRequest'.\\n\\n    \\u001b[7m73\\u001b[0m const { sendRequest } = require('../src/ai/providers/anthropicProvider');\\n    \\u001b[7m  \\u001b[0m \\u001b[91m        ~~~~~~~~~~~\\u001b[0m\\n    \\u001b[96mUnitTests/generated.test.ts\\u001b[0m:\\u001b[93m165\\u001b[0m:\\u001b[93m9\\u001b[0m - \\u001b[91merror\\u001b[0m\\u001b[90m TS2451: \\u001b[0mCannot redeclare block-scoped variable 'sendRequest'.\\n\\n    \\u001b[7m165\\u001b[0m const { sendRequest } = require('../src/ai/providers/openAIProvider');\\n    \\u001b[7m   \\u001b[0m \\u001b[91m        ~~~~~~~~~~~\\u001b[0m\\n    \\u001b[96mUnitTests/generated.test.ts\\u001b[0m:\\u001b[93m258\\u001b[0m:\\u001b[93m215\\u001b[0m - \\u001b[91merror\\u001b[0m\\u001b[90m TS2503: \\u001b[0mCannot find namespace 'fs'.\\n\\n    \\u001b[7m258\\u001b[0m const { analyzeFileMetadata } = require('../src/analysis/enhancedAnalyzer'); const fs = require('fs'); const path = require('path'); describe('analyzeFileMetadata', () => { let mockReadFileSync: jest.Mock<string, [fs.PathOrFileDescriptor, BufferEncoding]>; let originalReadFileSync: typeof fs.readFileSync; beforeEach(() => { originalReadFileSync = fs.readFileSync; mockReadFileSync = jest.fn<string, [fs.PathOrFileDescriptor, BufferEncoding]>(); fs.readFileSync = mockReadFileSync; }); afterEach(() => { fs.readFileSync = originalReadFileSync; jest.restoreAllMocks(); }); test('should analyze a TypeScript file with a simple function', () => { const filePath: string = '/test/sample.ts'; const fileContent: string = 'function add(a: number, b: number): number { return a + b; }'; mockReadFileSync.mockReturnValue(fileContent); const result: unknown = analyzeFileMetadata(filePath); expect(mockReadFileSync).toHaveBeenCalledWith(filePath, 'utf-8'); expect(result).toBeDefined(); expect(typeof result).toBe('object'); expect(result).toHaveProperty('functions'); const resultObj: { functions?: unknown[] } = result as { functions?: unknown[] }; expect(Array.isArray(resultObj.functions)).toBe(true); if (resultObj.functions && resultObj.functions.length > 0) { const firstFunc: unknown = resultObj.functions[0]; expect(firstFunc).toHaveProperty('name'); const funcWithName: { name?: string } = firstFunc as { name?: string }; expect(funcWithName.name).toBe('add'); } }); test('should handle files with no functions', () => { const filePath: string = '/test/empty.ts'; const fileContent: string = 'const x: number = 5;'; mockReadFileSync.mockReturnValue(fileContent); const result: unknown = analyzeFileMetadata(filePath); expect(result).toBeDefined(); expect(typeof result).toBe('object'); expect(result).toHaveProperty('functions'); const resultObj: { functions?: unknown[] } = result as { functions?: unknown[] }; expect(Array.isArray(resultObj.functions)).toBe(true); expect(resultObj.functions?.length || 0).toBe(0); }); test('should handle file read errors gracefully', () => { const filePath: string = '/test/nonexistent.ts'; mockReadFileSync.mockImplementation(() => { throw new Error('File not found'); }); expect(() => analyzeFileMetadata(filePath)).toThrow('File not found'); }); });\\n    \\u001b[7m   \\u001b[0m \\u001b[91m                                                                                                                                                                                                                      ~~\\u001b[0m\\n    \\u001b[96mUnitTests/generated.test.ts\\u001b[0m:\\u001b[93m258\\u001b[0m:\\u001b[93m403\\u001b[0m - \\u001b[91merror\\u001b[0m\\u001b[90m TS2503: \\u001b[0mCannot find namespace 'fs'.\\n\\n    \\u001b[7m258\\u001b[0m const { analyzeFileMetadata } = require('../src/analysis/enhancedAnalyzer'); const fs = require('fs'); const path = require('path'); describe('analyzeFileMetadata', () => { let mockReadFileSync: jest.Mock<string, [fs.PathOrFileDescriptor, BufferEncoding]>; let originalReadFileSync: typeof fs.readFileSync; beforeEach(() => { originalReadFileSync = fs.readFileSync; mockReadFileSync = jest.fn<string, [fs.PathOrFileDescriptor, BufferEncoding]>(); fs.readFileSync = mockReadFileSync; }); afterEach(() => { fs.readFileSync = originalReadFileSync; jest.restoreAllMocks(); }); test('should analyze a TypeScript file with a simple function', () => { const filePath: string = '/test/sample.ts'; const fileContent: string = 'function add(a: number, b: number): number { return a + b; }'; mockReadFileSync.mockReturnValue(fileContent); const result: unknown = analyzeFileMetadata(filePath); expect(mockReadFileSync).toHaveBeenCalledWith(filePath, 'utf-8'); expect(result).toBeDefined(); expect(typeof result).toBe('object'); expect(result).toHaveProperty('functions'); const resultObj: { functions?: unknown[] } = result as { functions?: unknown[] }; expect(Array.isArray(resultObj.functions)).toBe(true); if (resultObj.functions && resultObj.functions.length > 0) { const firstFunc: unknown = resultObj.functions[0]; expect(firstFunc).toHaveProperty('name'); const funcWithName: { name?: string } = firstFunc as { name?: string }; expect(funcWithName.name).toBe('add'); } }); test('should handle files with no functions', () => { const filePath: string = '/test/empty.ts'; const fileContent: string = 'const x: number = 5;'; mockReadFileSync.mockReturnValue(fileContent); const result: unknown = analyzeFileMetadata(filePath); expect(result).toBeDefined(); expect(typeof result).toBe('object'); expect(result).toHaveProperty('functions'); const resultObj: { functions?: unknown[] } = result as { functions?: unknown[] }; expect(Array.isArray(resultObj.functions)).toBe(true); expect(resultObj.functions?.length || 0).toBe(0); }); test('should handle file read errors gracefully', () => { const filePath: string = '/test/nonexistent.ts'; mockReadFileSync.mockImplementation(() => { throw new Error('File not found'); }); expect(() => analyzeFileMetadata(filePath)).toThrow('File not found'); }); });\\n    \\u001b[7m   \\u001b[0m \\u001b[91m                                                                                                                                                                                                                                                                                                                                                                                                                  ~~\\u001b[0m\\n\",\"name\":\"/Users/leonardspeiser/Projects/shadow-plugin/UnitTests/generated.test.ts\",\"startTime\":1764178462315,\"status\":\"failed\",\"summary\":\"\"}],\"wasInterrupted\":false}\n"
  }
}