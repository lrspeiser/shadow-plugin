# Product Documentation Report

## Executive Summary

Shadow Watch is an AI-powered VS Code extension that automatically analyzes codebases to generate human-readable documentation, architectural insights, and actionable code quality recommendations. It serves as an intelligent code understanding assistant that bridges the gap between raw source code and comprehensible documentation, enabling developers to understand, navigate, and improve their codebases more efficiently through continuous monitoring, real-time insights, and AI-generated recommendations.

## Product Overview

Shadow Watch transforms the way developers interact with and understand their codebases by combining static code analysis with AI-powered semantic understanding. The extension continuously monitors workspace files and provides real-time insights into code structure, complexity, dependencies, and potential issues through integrated sidebar panels and diagnostic displays.

The product automatically identifies entry points, maps dependencies between files and functions, detects code smells such as circular dependencies and orphaned files, and generates comprehensive test coverage reports. By integrating language models (OpenAI GPT or Anthropic Claude), Shadow Watch generates contextual documentation and refactoring recommendations that help developers maintain code quality and reduce technical debt.

Users can explore their codebase through multiple specialized views including hierarchical analysis trees, insights panels, and documentation browsers that make complex codebases easier to navigate and understand. The extension maintains a persistent knowledge base of analysis results that improves over time and supports iterative AI-powered analysis workflows, enabling developers to work more efficiently with both familiar and unfamiliar codebases.

## What It Does

Shadow Watch provides comprehensive code intelligence capabilities:

- **Automated Analysis**: Automatically analyzes code structure and generates human-readable documentation explaining what code does from a user perspective
- **Quality Metrics**: Displays code quality metrics and complexity assessments in interactive sidebar tree views
- **Test Coverage**: Identifies test coverage gaps showing which functions have tests and which need testing
- **Code Organization**: Detects code organization issues including large files, orphaned code, circular dependencies, and duplicate code
- **AI-Powered Recommendations**: Generates refactoring recommendations with detailed migration guidance
- **Test Generation**: Creates automated test generation plans and executes tests with validation and auto-fixing capabilities
- **Real-Time Diagnostics**: Provides diagnostics in the VS Code Problems panel showing code quality warnings and suggestions
- **Navigation**: Enables instant navigation from analysis results to specific code locations in the editor
- **Export Capabilities**: Exports analysis results in formats optimized for ChatGPT, Cursor AI, and other AI assistants
- **Continuous Monitoring**: Monitors file changes and automatically refreshes analysis when code is modified
- **Documentation Generation**: Generates comprehensive product documentation describing application features and architecture
- **Test Planning**: Creates test plans prioritizing which functions need testing based on complexity and risk

## User Perspective

### GUI Interface

Users interact with Shadow Watch primarily through VS Code's graphical interface:

- **Interactive Sidebar Tree Views**: Displaying code analysis hierarchy with files, functions, and metrics
- **Insights Panel**: Showing AI-generated recommendations categorized by type (quality, architecture, testing)
- **Documentation Browser**: For viewing generated product documentation and architecture insights
- **Problems Panel Integration**: Displaying code quality diagnostics with severity levels
- **Status Bar Indicators**: Showing analysis progress and current state
- **Webview Panels**: Displaying detailed information about selected code elements with syntax highlighting
- **Tree View Navigation**: Allowing direct jumps to code locations by clicking on analysis items
- **Progress Notifications**: During long-running analysis and test generation operations
- **Configuration Settings Interface**: For enabling/disabling features and selecting AI providers

### Command Palette Integration

Users can trigger actions through VS Code's command palette:

- Workspace-wide and file-specific analysis commands
- Insight management (viewing, copying, clearing)
- LLM provider configuration
- Navigation through code structure and analysis reports
- Report generation and viewing

### Automated Workflows

The extension provides hands-free operation through:

- Real-time file watching that triggers re-analysis when code changes
- Automatic population of tree views with structured insights
- Continuous display of diagnostics for code issues

## Problems Solved

Shadow Watch addresses critical development challenges:

1. **Documentation Burden**: Eliminates manual documentation effort by automatically generating human-readable explanations of code purpose
2. **Code Comprehension**: Reduces time spent understanding unfamiliar codebases through AI-powered architectural insights
3. **Hidden Issues**: Identifies code quality issues that manual review might miss (circular dependencies, orphaned files, complexity hotspots)
4. **Testing Overhead**: Accelerates test writing by automatically generating test plans and test code with validation
5. **Technical Debt**: Prevents technical debt accumulation by surfacing refactoring opportunities before files become unmaintainable
6. **Navigation Challenges**: Improves code navigation in large projects through structured analysis hierarchies and instant jump-to-definition
7. **Documentation Consistency**: Standardizes documentation format across projects through consistent AI-generated output
8. **Review Complexity**: Reduces cognitive load during code review by highlighting specific issues with actionable recommendations

## Architecture Overview

Shadow Watch implements a layered architecture with clear separation of concerns:

### Layer Structure

**Domain Layer**: Contains services for code analysis, AI integration, test generation, and insight creation. These services orchestrate workflows like analyzing code structure, generating documentation, planning tests, and creating refactoring recommendations.

**Infrastructure Layer**: Handles persistence, file system operations, caching, and external AI provider integration. Manages data storage, retrieval, and communication with external services.

**Presentation Layer**: Consists of VS Code UI components including tree view providers, webview panels, diagnostics providers, and command handlers that present information to users.

### Event-Driven Architecture

The extension uses an event-driven model where:

- File system watchers detect code changes and trigger analysis pipelines
- Analysis results flow through multiple stages:
  1. Initial code parsing extracts structural information
  2. AI services enrich data with semantic understanding and recommendations
  3. Formatters transform results into human-readable documentation
  4. UI components display formatted results to users
- A caching layer stores analysis results to avoid redundant processing

### AI Integration Architecture

AI integration follows a provider abstraction pattern:

- Seamless switching between OpenAI and Anthropic Claude
- Rate limiting with provider-specific constraints
- Retry logic with exponential backoff
- Response parsing for both JSON and natural language outputs
- Iterative workflows where AI can progressively request additional information

### Test Generation Architecture

Test generation uses a multi-stage workflow:

1. AI analyzes code to create test plans
2. Tests are generated in small batches
3. Each batch is executed to capture results
4. Failures are automatically fixed through multiple refinement cycles
5. Results are persisted to workspace directory structure

## Key Components & Modules

### Core Analysis Components

**Code Analysis Engine**: Scans source code files to extract structural information including functions, classes, dependencies, complexity metrics, and code relationships. Identifies entry points, maps call graphs, and detects patterns like circular dependencies and orphaned files.

**AI-Powered Documentation Generator**: Leverages language models to transform raw code structure into human-readable documentation explaining what code does from a user perspective. Generates product overviews, feature descriptions, and architectural summaries.

**Insights and Recommendations Engine**: Analyzes code quality, complexity, organization, and structure to generate actionable recommendations for improvements. Identifies refactoring opportunities, test coverage gaps, and code smell patterns.

### Testing Components

**Test Generation System**: Creates comprehensive automated testing workflows including test environment detection, test plan creation, test code generation, execution, validation, and automatic fixing of failing tests. Supports multiple test frameworks like Jest, Mocha, pytest, and JUnit.

**Test Plan Creator**: Analyzes codebase to determine which functions need testing and creates prioritized test plans. Evaluates testability based on complexity, dependencies, and existing test coverage.

**Test Execution and Validation**: Runs generated tests, captures results including pass/fail status and error messages, and automatically attempts to fix failing tests through iterative AI-powered refinement.

**Test Configuration Detector**: Automatically identifies test frameworks in use, validates configuration, and detects missing dependencies. Ensures generated tests can execute without manual setup.

### UI Components

**Analysis Tree Navigator**: Hierarchical view of code analysis results showing statistics, files, functions, and entry points. Enables users to explore code structure and navigate to specific code locations.

**Architecture Insights Viewer**: Interactive tree view for browsing AI-generated architectural analysis of the codebase. Shows module structure, component relationships, and system design patterns.

**Code Quality Diagnostics**: Displays code quality issues, warnings, and suggestions directly in the VS Code Problems panel. Categorizes diagnostics by severity and provides navigation to problem locations.

**Product Documentation Generator**: Creates comprehensive product documentation describing application features, user workflows, problems solved, and technical architecture. Formats documentation as structured markdown with timestamped versions.

### Infrastructure Components

**File System Watcher**: Monitors workspace for file changes including creation, modification, and deletion. Triggers automatic re-analysis when files are saved if auto-analysis is enabled.

**Rate Limiter for AI Requests**: Enforces provider-specific API rate limits to prevent quota exhaustion. Automatically queues requests when approaching limits and throttles according to OpenAI (60 req/min) or Claude (50 req/min) constraints.

**Response Parser for AI Outputs**: Extracts structured data from AI-generated text responses. Handles both JSON and natural language outputs, providing fallback text parsing when structured data is unavailable.

**Configuration Manager**: Centralizes all extension settings including enable/disable controls, auto-analysis behavior, diagnostic display preferences, AI provider selection, and performance tuning parameters. Propagates configuration changes to dependent components in real-time.

**Navigation Handler**: Manages navigation between analysis results and source code locations. Opens files, positions editor view, highlights relevant code sections, and displays detailed information in webview panels.

**Progress Notification Service**: Displays progress indicators during long-running operations like analysis, test generation, and AI requests. Supports cancellation for interruptible operations.

**Analysis Context Builder**: Transforms code analysis results into structured format optimized for AI processing. Persists analysis data to workspace directory for reuse across sessions.

## Key Functions & Data Structures

### Core Functions

**analyzeCodebase** (`src/analyzer.ts`): Performs comprehensive code analysis across all workspace files, extracting functions, dependencies, complexity metrics, and structural patterns.

**generateInsights** (`src/insightGenerator.ts`): Creates actionable code quality insights by analyzing code structure, complexity, and organization patterns.

**generateProductDocumentation** (`src/llmIntegration.ts`): Leverages AI to create comprehensive product documentation from code analysis results.

**generateArchitectureInsights** (`src/llmIntegration.ts`): Uses AI to analyze codebase architecture and generate high-level architectural insights.

**createTestPlan** (`src/domain/services/testing/llmTestPlanningService.ts`): Analyzes functions to determine testability and creates prioritized test generation plans.

**generateTests** (`src/domain/services/testing/llmTestGenerationService.ts`): Creates test code for functions using AI, executing tests in small batches with validation.

**validateTests** (`src/domain/services/testing/llmTestValidationService.ts`): Executes generated tests, detects failures, and automatically fixes failing tests through iterative refinement.

**navigateToLocation** (`src/domain/handlers/navigationHandler.ts`): Opens files in the editor and positions cursor at specific code locations from analysis results.

**buildPromptForAnalysis** (`src/domain/prompts/promptBuilder.ts`): Constructs specialized prompts that guide AI interactions for code analysis tasks.

**parseAnalysisResponse** (`src/ai/llmResponseParser.ts`): Extracts structured data from AI text responses, handling both JSON and natural language outputs.

**enforceRateLimit** (`src/ai/llmRateLimiter.ts`): Throttles AI API requests to prevent quota exhaustion based on provider-specific limits.

**processFileChanges** (`src/domain/services/fileWatcherService.ts`): Handles file system change events and triggers appropriate analysis updates.

### Data Structures

**AnalysisResult** (`src/analyzer.ts`): Represents complete code analysis output including file metrics, functions, dependencies, entry points, and code relationships.

**FileAnalysis** (`src/analyzer.ts`): Contains detailed analysis of a single file including functions, imports, exports, complexity metrics, and test mappings.

**FunctionInfo** (`src/analyzer.ts`): Describes a function including name, signature, location, complexity, dependencies, and behavioral metadata.

**CodeInsight** (`src/insightGenerator.ts`): Represents an actionable code quality recommendation with severity, category, description, and affected locations.

**ProductDocumentation** (`src/fileDocumentation.ts`): Structured product documentation including overview, features, user perspectives, architecture, and examples.

**TestPlan** (`src/domain/services/testing/types/testPlanTypes.ts`): Organized plan for test generation including functions to test, priorities, testability assessments, and generation strategy.

**TestResult** (`src/domain/services/testing/types/testResultTypes.ts`): Results from test execution including pass/fail status, error messages, stack traces, and execution timing.

**TestSetupPlan** (`src/domain/services/testing/types/testSetupTypes.ts`): Configuration plan for test environment including framework detection, required dependencies, and setup instructions.

**AnalysisTreeItem** (`src/analysisViewer.ts`): Tree view item representing a node in the analysis hierarchy for display in VS Code sidebar.

**InsightTreeItem** (`src/insightsTreeView.ts`): Tree view item representing an insight or recommendation for display in the insights panel.

## Workflows & Integration

### Analysis Workflow

1. **Trigger**: User opens workspace, saves file (if auto-analysis enabled), or manually triggers analysis via command palette
2. **Scanning**: Extension scans workspace files, filtering out non-source directories (node_modules, .git, dist, etc.)
3. **Parsing**: Code is parsed using AST to extract structural information (functions, classes, dependencies, complexity)
4. **AI Enrichment**: Analysis results are sent to AI provider (OpenAI or Claude) to generate semantic insights
5. **Insight Generation**: AI produces recommendations for code quality, refactoring, testing, and architecture
6. **Display**: Results populate tree views, diagnostics panel, and webview components
7. **Persistence**: Analysis results saved to `.shadow/docs/code-analysis.json` for caching and history

### Test Generation Workflow

1. **Environment Detection**: System identifies test framework (Jest, Mocha, pytest, JUnit) and validates configuration
2. **Test Planning**: Analyzes functions to determine which need tests based on complexity, dependencies, and existing coverage
3. **Prioritization**: Creates prioritized list of functions to test, focusing on high-risk, high-complexity areas
4. **Batch Generation**: Generates tests in small batches (e.g., "3 of 10: validateUser") for incremental progress
5. **Execution**: Runs generated tests and captures results (pass/fail, error messages, stack traces)
6. **Validation**: Analyzes test results and identifies failures
7. **Auto-Fixing**: Iteratively refines failing tests through AI-powered analysis and regeneration
8. **Reporting**: Generates comprehensive test report with coverage metrics and recommendations

### Navigation Workflow

1. **User Interaction**: User clicks on analysis result, insight, or function in tree view
2. **Location Resolution**: System resolves file path and line number from analysis data
3. **File Opening**: VS Code opens the target file in editor
4. **Positioning**: Editor scrolls to target line and highlights relevant code section
5. **Information Display**: Webview panel shows detailed information about selected element (function signature, metadata, context)

### AI Integration Workflow

1. **Request Formation**: Prompt builder constructs specialized prompt based on task (documentation, testing, refactoring)
2. **Rate Limiting**: Rate limiter checks if request can be sent or must be queued based on provider limits
3. **API Call**: Request sent to AI provider (OpenAI or Claude) with timeout protection (5 minutes)
4. **Response Parsing**: Raw AI response parsed into structured data (JSON) or fallback text parsing if needed
5. **Retry Logic**: Failed requests automatically retried with exponential backoff for transient errors
6. **Result Processing**: Parsed results feed into appropriate workflow (documentation generation, test creation, etc.)

### File Watching Workflow

1. **Registration**: File system watcher registered for workspace at extension activation
2. **Change Detection**: Watcher detects file creation, modification, or deletion events
3. **Debouncing**: Changes consolidated to prevent duplicate processing of rapid successive changes
4. **Trigger Analysis**: If auto-analysis enabled, triggers re-analysis for affected files
5. **UI Update**: Tree views and diagnostics automatically refresh with updated analysis results

## File Organization

### Root Files

**`src/extension.ts`**: Main entry point that initializes the extension and orchestrates all features when VS Code activates. Bootstraps all extension components including analyzers, tree views, diagnostics, file watchers, and command handlers.

### Core Analysis Files

**`src/analyzer.ts`**: Core analysis engine that scans code files to extract functions, dependencies, complexity metrics, and structural information. Performs comprehensive static code analysis across the workspace.

**`src/insightGenerator.ts`**: Generates actionable code quality insights by analyzing patterns like complexity, large files, orphaned code, and circular dependencies. Creates recommendations for code improvements based on analysis results.

**`src/llmIntegration.ts`**: Coordinates AI-powered features including documentation generation, architecture insights, and refactoring recommendations. Integrates language models into the analysis workflow for semantic understanding.

**`src/llmService.ts`**: Provides AI services for generating documentation, insights, test plans, and refactoring guidance using language models. Handles all interactions with AI providers for analysis enrichment.

### UI Components

**`src/analysisViewer.ts`**: Provides interactive tree view displaying analysis hierarchy including files, functions, and metrics. Enables users to explore code structure through visual tree navigation.

**`src/insightsTreeView.ts`**: Displays AI-generated insights, recommendations, and documentation in an interactive sidebar panel. Presents code quality insights and documentation to users.

**`src/diagnosticsProvider.ts`**: Manages code quality diagnostics displayed in the VS Code Problems panel. Shows warnings and suggestions alongside native VS Code diagnostics.

### Domain Layer

**`src/domain/bootstrap/`**: Extension initialization and activation with all core components. Command registration for code analysis, insights management, and LLM provider switching.

**`src/domain/handlers/navigationHandler.ts`**: Handles navigation from analysis results to source code locations with highlighting and detailed information display. Manages jumps from analysis views to corresponding code.

**`src/domain/prompts/promptBuilder.ts`**: Constructs specialized prompts for all AI-powered analysis tasks. Guides AI interactions to produce consistent, structured analysis results.

**`src/domain/formatters/`**: Transforms raw code analysis data and product insights into human-readable, well-structured Markdown documentation.

**`src/domain/services/`**: Core services including file watching, incremental AI analysis, and test generation orchestration.

**`src/domain/services/testing/`**: Complete testing system including test generation, planning, validation, and execution services.

**`src/domain/services/testing/types/`**: Type definitions for test setup, planning, generation, validation, and execution phases.

### Infrastructure Layer

**`src/ai/`**: Core infrastructure for LLM communication including rate limiting, retry handling, and response parsing.

**`src/ai/providers/`**: Unified interface for multiple AI providers (OpenAI GPT and Anthropic Claude) with factory pattern implementation.

**`src/config/`**: Centralized configuration management with real-time updates and change notifications.

**`src/context/`**: Analysis context building and persistence for AI processing.

**`src/infrastructure/fileSystem/`**: High-performance file operations with intelligent caching and parallel processing.

**`src/infrastructure/persistence/`**: Storage and organization of AI-generated analysis results within the workspace.

**`src/infrastructure/`**: Progress notification service for long-running operations.

### Analysis Enhancement Files

**`src/analysis/`**: Deep code analysis using AST parsing, function metadata extraction, and behavioral pattern recognition.

### Workspace Organization

- **`.shadow/docs/`**: Persistent storage for analysis results, product documentation, and code analysis data
- **`.shadow/insights/`**: Architecture insights stored in timestamped directories
- **Configuration Files**: Jest configuration for testing infrastructure
- **Total Workspace**: 65 files, 25,156 lines of code, 1,183 functions

---

This documentation provides a comprehensive overview of Shadow Watch's capabilities, architecture, and workflows. The extension serves as an intelligent assistant that continuously helps developers understand, improve, and document their codebases through AI-powered automation and analysis.