{
  "overallAssessment": "Shadow Watch exhibits a **monolithic layered architecture** that has evolved organically but lacks clear architectural boundaries between presentation, business logic, and data access layers. The codebase demonstrates a **feature-driven organization pattern** where major capabilities (LLM integration, insights viewing, product navigation, unit test navigation) each have their own large files (2000+ LOC) that intermix UI concerns, business logic, and external service integration. While the extension successfully delivers its core value proposition of continuous architecture monitoring with AI-powered analysis, the architecture has grown complex with **three overlapping file watching systems** (fileWatcher.ts, extension.ts file system watcher, cache.ts), **two separate LLM integration paths** (llmIntegration.ts and llmService.ts with 5080 combined LOC), and **multiple competing presentation layers** (insightsViewer.ts webview, insightsTreeView.ts sidebar, analysisViewer.ts, staticAnalysisViewer.ts, diagnosticsProvider.ts) that create redundant code paths.\n\nThe architecture reveals **missing abstraction layers** between VS Code extension APIs and business logic, causing tight coupling to the extension host environment. Business logic for analysis, LLM interaction, and documentation generation is scattered across multiple large files without clear separation of concerns. The recent addition of an `ai/` subdirectory (llmRateLimiter, llmResponseParser, llmRetryHandler) and `config/`, `context/`, `state/`, `storage/` subdirectories suggests an emerging attempt to introduce layered architecture, but these new patterns coexist with the older monolithic files rather than replacing them. The codebase would benefit significantly from completing this architectural transition by **extracting business logic into a domain layer**, **consolidating the duplicate LLM integration code**, **unifying the file watching systems**, and **establishing clear interfaces** between the VS Code extension shell and the core analysis/documentation engine, which would also enable future extensibility to other IDEs or CLI usage.",
  "strengths": [
    "Clear domain separation emerging in ai/ subdirectory with focused modules (llmRateLimiter, llmResponseParser, llmRetryHandler) that handle single responsibilities",
    "Provider abstraction pattern in ai/providers/ enabling support for multiple LLM backends (OpenAI, Anthropic, custom) without coupling core logic to specific APIs",
    "Configuration management centralized in configurationManager.ts providing single source of truth for extension settings",
    "Incremental storage system (incrementalStorage.ts) implementing caching strategy to avoid re-analyzing unchanged files, maintaining performance at scale",
    "Comprehensive error handling infrastructure with dedicated errorHandler.ts module and logger.ts for observability",
    "State management abstraction (llmStateManager.ts) separating state concerns from business logic",
    "Context building abstraction (analysisContextBuilder.ts) encapsulating prompt construction logic for LLM interactions"
  ],
  "issues": [
    {
      "title": "Duplicate LLM Integration Systems",
      "description": "Both llmIntegration.ts (2251 LOC, 187 functions) and llmService.ts (2829 LOC, 112 functions) implement overlapping LLM interaction functionality. These files combined represent 5080 lines and 299 functions - approximately 33% of the entire codebase. This creates confusion about which service to use, duplicates error handling and retry logic, and makes maintenance difficult. **Proposed Fix**: Consolidate into a single LLM service layer. Move llmService.ts core functionality into a domain/services/llmAnalysisService.ts that handles all AI-powered analysis (architecture insights, product documentation, unit test documentation). Use llmIntegration.ts as a thin adapter layer that connects VS Code commands to the domain service. Refactor llmIntegration.ts to delegate to the consolidated service rather than reimplementing LLM calls. Extract shared prompt formatting logic into the existing llmFormatter.ts. This reduces the codebase by ~2000 lines and establishes a clear separation between VS Code integration (llmIntegration.ts as adapter) and business logic (llmAnalysisService.ts as domain service).",
      "relevantFiles": [
        "src/llmIntegration.ts",
        "src/llmService.ts",
        "src/llmFormatter.ts",
        "src/ai/llmResponseParser.ts"
      ],
      "relevantFunctions": [
        "llmIntegration.generateArchitectureInsights",
        "llmService.generateArchitectureInsights",
        "llmIntegration.generateProductDocumentation",
        "llmService.analyzeCodebase"
      ]
    },
    {
      "title": "Three Overlapping File Watching Systems",
      "description": "The codebase implements three separate file watching mechanisms: fileWatcher.ts (128 LOC) dedicated file watcher, extension.ts createFileSystemWatcher (inline implementation), and cache.ts file modification tracking. This creates redundant filesystem monitoring, unclear responsibility for triggering analysis, and potential race conditions. **Proposed Fix**: Consolidate file watching into a single FileWatcherService in domain/services/fileWatcherService.ts. This service should use VS Code's FileSystemWatcher API and emit domain events (FileChanged, FileCreated, FileDeleted) that other components subscribe to. The cache module should subscribe to these events rather than implementing its own tracking. The extension.ts should delegate to this service rather than creating watchers directly. Update analyzer.ts to subscribe to file change events from the centralized service.",
      "relevantFiles": [
        "src/fileWatcher.ts",
        "src/extension.ts",
        "src/cache.ts",
        "src/analyzer.ts"
      ],
      "relevantFunctions": [
        "FileWatcher.watch",
        "extension.activate",
        "cache.updateCache",
        "analyzer.analyzeFile"
      ]
    },
    {
      "title": "Presentation Logic Scattered Across Five View Components",
      "description": "Five separate files implement overlapping presentation concerns: insightsViewer.ts (727 LOC) webview, insightsTreeView.ts (957 LOC) sidebar tree, analysisViewer.ts (525 LOC) analysis webview, staticAnalysisViewer.ts (216 LOC) static analysis view, and diagnosticsProvider.ts (103 LOC) inline diagnostics. These components duplicate view state management, event handling, and data formatting logic. There's no clear separation between view logic and view models. **Proposed Fix**: Introduce a presentation layer architecture with shared view models. Create ui/viewModels/ directory with AnalysisViewModel, InsightsViewModel, DiagnosticsViewModel that transform domain data into presentation format. Refactor view components to consume view models rather than directly accessing domain data. Extract shared webview HTML generation into webviewTemplateEngine.ts (which already exists but is underutilized). Consider creating a base WebviewProvider class that handles common webview lifecycle, messaging, and state management, with specific views (insights, analysis, static analysis) extending it.",
      "relevantFiles": [
        "src/insightsViewer.ts",
        "src/insightsTreeView.ts",
        "src/analysisViewer.ts",
        "src/staticAnalysisViewer.ts",
        "src/diagnosticsProvider.ts",
        "src/ui/webview/webviewTemplateEngine.ts"
      ],
      "relevantFunctions": [
        "InsightsViewer.render",
        "InsightsTreeView.refresh",
        "AnalysisViewer.showAnalysis",
        "StaticAnalysisViewer.update",
        "DiagnosticsProvider.updateDiagnostics"
      ]
    },
    {
      "title": "Missing Domain Layer Abstraction",
      "description": "Business logic for code analysis, architecture detection, and documentation generation is tightly coupled to VS Code APIs throughout extension.ts, analyzer.ts, and navigator files. There's no clear domain model representing concepts like AnalysisResult, ArchitectureIssue, CodebaseInsight independent of presentation concerns. This makes the code difficult to test, impossible to reuse outside VS Code, and harder to reason about. **Proposed Fix**: Introduce a domain/ layer with clear models and services. Create domain/models/ with AnalysisResult, ArchitectureIssue, CodebaseHealth, DocumentationEntry, TestCase entities. Create domain/services/ with AnalysisService, ArchitectureDetectionService, DocumentationService that operate on domain models. These services should have no dependencies on VS Code APIs (vscode module). The existing src/ files become adapters that translate between VS Code APIs and domain services. For example, extension.ts becomes an adapter that maps VS Code commands to domain service calls, then translates results back to VS Code UI components.",
      "relevantFiles": [
        "src/extension.ts",
        "src/analyzer.ts",
        "src/insightGenerator.ts",
        "src/productNavigator.ts",
        "src/unitTestsNavigator.ts"
      ],
      "relevantFunctions": [
        "extension.activate",
        "analyzer.analyzeFile",
        "insightGenerator.generateInsights",
        "productNavigator.generateProductDocs",
        "unitTestsNavigator.analyzeUnitTests"
      ]
    },
    {
      "title": "God Object in extension.ts",
      "description": "extension.ts contains 1407 LOC and 86 functions, serving as a god object that handles extension lifecycle, command registration, UI orchestration, file watching, analysis triggering, and state management. This violates single responsibility principle and makes the file extremely difficult to maintain and test. **Proposed Fix**: Decompose extension.ts into focused modules. Create infrastructure/extensionBootstrapper.ts to handle activation, deactivation, and dependency injection. Create infrastructure/commandRegistry.ts to register all VS Code commands and map them to handlers. Create adapters/vscode/ directory with focused adapters: FileSystemAdapter (file operations), WorkspaceAdapter (workspace queries), DiagnosticsAdapter (problem reporting). The main extension.ts should become a thin composition root (~100 LOC) that wires dependencies and delegates to specialized components. Extract UI orchestration into ui/uiCoordinator.ts that manages view lifecycle and communication.",
      "relevantFiles": [
        "src/extension.ts"
      ],
      "relevantFunctions": [
        "activate",
        "deactivate",
        "registerCommands",
        "setupFileWatcher",
        "analyzeWorkspace",
        "showInsightsPanel",
        "updateDiagnostics"
      ]
    },
    {
      "title": "Circular Dependency Between analyzer.ts and cache.ts",
      "description": "analyzer.ts imports cache.ts for caching analysis results, while cache.ts imports analyzer.ts to trigger analysis on cache misses. This creates a circular dependency that couples these modules tightly and makes understanding data flow difficult. **Proposed Fix**: Break the circular dependency by introducing an event-based architecture. The analyzer should publish AnalysisCompleted events that the cache subscribes to, rather than the cache calling back into the analyzer. Create domain/events/ directory with event types (AnalysisCompleted, FileChanged, CacheInvalidated). Implement a simple event bus in domain/events/eventBus.ts. The analyzer publishes events when analysis completes, the cache subscribes to update itself, and other components (file watcher, diagnostics provider) can subscribe to react to analysis completion without direct coupling.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/cache.ts"
      ],
      "relevantFunctions": [
        "analyzer.analyzeFile",
        "cache.getAnalysis",
        "cache.updateCache",
        "analyzer.getCachedAnalysis"
      ]
    },
    {
      "title": "Tight Coupling to VS Code APIs Throughout Domain Logic",
      "description": "Core business logic in analyzer.ts, insightGenerator.ts, and llmService.ts directly imports and uses the vscode module, making these components impossible to test in isolation and preventing reuse outside VS Code. For example, analyzer.ts uses vscode.workspace directly, insightGenerator.ts uses vscode.Uri, and multiple files use VS Code progress indicators. **Proposed Fix**: Introduce infrastructure interfaces that abstract VS Code APIs. Create domain/interfaces/ with IFileSystem, IWorkspace, IProgress abstractions. Create infrastructure/vscode/ with concrete implementations (VSCodeFileSystem, VSCodeWorkspace, VSCodeProgress) that wrap VS Code APIs. Update domain services to depend on interfaces rather than the vscode module. Use dependency injection to provide VS Code implementations at runtime but allow mock implementations in tests. This follows the Dependency Inversion Principle and enables both testing and potential future CLI or web-based versions.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/insightGenerator.ts",
        "src/llmService.ts",
        "src/fileAccessHelper.ts"
      ],
      "relevantFunctions": [
        "analyzer.analyzeFile",
        "insightGenerator.generateInsights",
        "llmService.analyzeCodebase",
        "fileAccessHelper.readFile"
      ]
    },
    {
      "title": "Missing Separation Between Static and AI-Powered Analysis",
      "description": "The analyzer.ts (592 LOC) mixes static code analysis (AST parsing, dependency detection, complexity calculation) with AI-powered analysis orchestration. This creates confusion about which analysis techniques are being used and makes it difficult to configure analysis strategies independently. **Proposed Fix**: Split analysis into two distinct services. Create domain/services/staticAnalysisService.ts for AST parsing, dependency graph construction, complexity metrics, and pattern detection that requires no external services. Create domain/services/aiAnalysisService.ts (refactored from current llmService.ts) for AI-powered architecture insights, documentation generation, and semantic analysis. Create domain/services/analysisOrchestrator.ts that coordinates both services, running static analysis first (fast, deterministic), then optionally enriching with AI analysis (slower, configurable). This separation enables users to choose analysis strategies and makes testing easier.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/llmService.ts",
        "src/insightGenerator.ts"
      ],
      "relevantFunctions": [
        "analyzer.analyzeFile",
        "analyzer.detectPatterns",
        "llmService.analyzeCodebase",
        "insightGenerator.generateInsights"
      ]
    },
    {
      "title": "Configuration Spread Across Multiple Mechanisms",
      "description": "Configuration is managed through configurationManager.ts but also accessed directly via vscode.workspace.getConfiguration() in extension.ts, llmIntegration.ts, and provider files. This creates multiple sources of truth and makes it unclear where configuration should be accessed. **Proposed Fix**: Centralize all configuration access through configurationManager.ts. Add a configuration facade pattern that provides typed, validated access to all settings. Create domain/config/configurationSchema.ts that defines configuration structure with TypeScript types. Update all components to inject ConfigurationManager rather than accessing vscode.workspace directly. Add configuration validation on startup to catch invalid settings early. Consider adding a ConfigurationChangeEvent that components can subscribe to rather than polling for changes.",
      "relevantFiles": [
        "src/config/configurationManager.ts",
        "src/extension.ts",
        "src/llmIntegration.ts",
        "src/ai/providers/anthropicProvider.ts",
        "src/ai/providers/openAIProvider.ts"
      ],
      "relevantFunctions": [
        "configurationManager.getApiKey",
        "extension.activate",
        "llmIntegration.getProvider",
        "anthropicProvider.constructor",
        "openAIProvider.constructor"
      ]
    },
    {
      "title": "No Clear Testing Strategy or Test Organization",
      "description": "The codebase includes scripts/test_architecture_insights.mjs and scripts/test_product_docs.mjs (integration tests) but no unit test infrastructure. There's no src/test/ directory, no test runner configuration, and the production code is tightly coupled to VS Code APIs making it untestable. The unitTestsNavigator.ts analyzes tests but the extension itself lacks tests. **Proposed Fix**: Establish a comprehensive testing strategy. Create src/test/unit/ for unit tests of domain logic, src/test/integration/ for VS Code integration tests, src/test/fixtures/ for test data. Add @vscode/test-electron dev dependency and configure test scripts in package.json. Refactor domain logic to remove VS Code dependencies (as described in previous issues) to enable unit testing. Write unit tests for domain/services/, domain/models/, and core analysis logic. Write integration tests for VS Code adapters and UI components using the VS Code test framework. Add test coverage reporting to track progress.",
      "relevantFiles": [
        "scripts/test_architecture_insights.mjs",
        "scripts/test_product_docs.mjs",
        "src/unitTestsNavigator.ts"
      ],
      "relevantFunctions": []
    }
  ],
  "organization": "The codebase exhibits **severe root directory clutter** with 14 files directly in root including 8 markdown documentation files (GET_STARTED.md, IMPLEMENTATION_GUIDE.md, MENU_STRUCTURE.md, PLUGIN_DESIGN.md, QUICK_START.md, README.md, REFACTORING_PLAN.md, and images/README.md), 2 compiled VSIX packages (shadow-watch-1.0.0.vsix, shadow-watch.vsix), build configuration (webpack.config.js, tsconfig.json), package metadata (package.json, package-lock.json), and LICENSE. This makes navigating the project difficult and obscures the actual source code structure. More critically, the **src/ directory lacks meaningful architectural organization** - 19 TypeScript files sit in the root src/ directory with only 5 subdirectories (ai/, config/, context/, state/, storage/, ui/, utils/) that contain 10 additional files. The newer subdirectories (ai/, config/, context/, state/, storage/) suggest an incomplete migration toward layered architecture, but they exist alongside the older monolithic files rather than fully organizing the codebase.\n\n**Layer Organization Analysis**: Based on the architectural analysis, files are poorly organized relative to their actual layer responsibilities. **Presentation layer files** (insightsViewer.ts, insightsTreeView.ts, analysisViewer.ts, staticAnalysisViewer.ts, diagnosticsProvider.ts - 2528 LOC combined) all sit in src/ root when they should be in src/ui/ or src/presentation/. **Business logic files** (analyzer.ts, insightGenerator.ts, llmService.ts, llmIntegration.ts - 6437 LOC combined) are mixed in src/ root with presentation files when they should be in src/domain/services/. **Infrastructure files** (fileWatcher.ts, cache.ts, logger.ts) are in src/ root when they should be in src/infrastructure/. The **ai/ subdirectory** correctly separates LLM-related concerns but only contains 3 support files (rate limiter, parser, retry handler) while the massive llmService.ts and llmIntegration.ts remain in root. The **ai/providers/ subdirectory** correctly implements provider abstraction but is isolated from the main LLM integration code. Navigation files (productNavigator.ts, unitTestsNavigator.ts - 1327 LOC) that orchestrate AI-powered documentation generation are in src/ root when they should be in a src/features/ or src/application/ directory. The webview template engine sits in src/ui/webview/ but none of the actual webview implementations (insightsViewer.ts, analysisViewer.ts) are there, creating organizational inconsistency.",
  "entryPointsAnalysis": "The extension has a **single formal entry point** defined in package.json main field: `./dist/extension.js` (compiled from src/extension.ts). This entry point serves the VS Code Extension Host and is the only mechanism for loading the extension. The extension.ts file (1407 LOC) implements the standard VS Code extension lifecycle with `activate()` and `deactivate()` functions. However, extension.ts has become a **god object entry point** that directly handles command registration, UI orchestration, file watching, analysis triggering, state management, and dependency wiring. It contains 86 functions performing responsibilities that should be distributed across multiple modules. The entry point directly couples to domain logic (analyzer.ts), presentation logic (insightsViewer.ts, insightsTreeView.ts), and infrastructure (fileWatcher.ts, cache.ts) without abstraction layers. The webpack.config.js configures compilation targeting Node.js with the extension.ts as the entry point for bundling.",
  "orphanedFilesAnalysis": "Two files are identified as orphaned: **src/extension.ts** and **webpack.config.js**. However, this analysis is misleading. src/extension.ts is the **primary entry point** defined in package.json main field and is imported by the VS Code Extension Host runtime, not by TypeScript import statements in the codebase. webpack.config.js is a **build configuration file** consumed by webpack tooling, not imported by source code. These are both critical infrastructure files despite showing zero imports in the static analysis. The orphaned file detection is identifying files consumed by external runtimes (VS Code, webpack) rather than internal code, which is expected for entry points and build configuration. There are no genuinely orphaned code files in the codebase - all source files in src/ are either the entry point or imported by other modules.",
  "folderReorganization": "**Immediate Priority: Organize Root Directory** - Move 8 documentation files to docs/ directory: docs/getting-started/GET_STARTED.md, docs/getting-started/QUICK_START.md, docs/guides/IMPLEMENTATION_GUIDE.md, docs/reference/MENU_STRUCTURE.md, docs/architecture/PLUGIN_DESIGN.md, docs/planning/REFACTORING_PLAN.md, docs/README.md (main documentation index), images/README.md → docs/images/README.md. Move VSIX packages to dist/ or release/ directory: dist/shadow-watch-1.0.0.vsix, dist/shadow-watch.vsix. Keep LICENSE, README.md, package.json, package-lock.json, tsconfig.json, webpack.config.js in root as they are standard root-level files.\n\n**Critical Priority: Restructure src/ by Architectural Layer** - Create src/domain/ for business logic: src/domain/models/ (analysis results, architecture issues, health metrics), src/domain/services/ (move analyzer.ts → analysisService.ts, insightGenerator.ts → insightGenerationService.ts, consolidate llmService.ts + llmIntegration.ts → llmAnalysisService.ts), src/domain/interfaces/ (IFileSystem, IWorkspace, IAnalysisService abstractions), src/domain/events/ (event types and event bus for decoupled communication). Create src/application/ for use case orchestration: src/application/useCases/ (analyzeWorkspace, generateProductDocs, generateArchitectureInsights, analyzeUnitTests use case handlers). Create src/infrastructure/ for technical concerns: src/infrastructure/vscode/ (move fileAccessHelper.ts, create fileSystemAdapter.ts, workspaceAdapter.ts), src/infrastructure/cache/ (move cache.ts), src/infrastructure/fileWatching/ (move fileWatcher.ts), src/infrastructure/logging/ (move logger.ts). Create src/presentation/ (or src/ui/) for all view components: src/presentation/views/ (move insightsViewer.ts, analysisViewer.ts, staticAnalysisViewer.ts), src/presentation/treeViews/ (move insightsTreeView.ts), src/presentation/diagnostics/ (move diagnosticsProvider.ts), src/presentation/viewModels/ (create view model classes), src/presentation/webview/ (move webviewTemplateEngine.ts). Create src/features/ or src/adapters/ for feature-specific adapters: src/features/productDocumentation/ (move productNavigator.ts), src/features/unitTestAnalysis/ (move unitTestsNavigator.ts).\n\n**AI Module Consolidation** - Keep src/ai/ for LLM infrastructure but consolidate: src/ai/providers/ (keep existing provider files), src/ai/core/ (move llmRateLimiter.ts, llmRetryHandler.ts), src/ai/parsing/ (move llmResponseParser.ts), src/ai/formatting/ (move llmFormatter.ts, llmSchemas.ts). Remove duplicate llmService.ts and llmIntegration.ts by consolidating into src/domain/services/llmAnalysisService.ts.\n\n**Testing Infrastructure** - Create src/test/ structure: src/test/unit/ (unit tests for domain services), src/test/integration/ (integration tests for VS Code adapters), src/test/fixtures/ (test data and mocks), src/test/helpers/ (test utilities). Move existing test scripts: scripts/test_architecture_insights.mjs → src/test/integration/, scripts/test_product_docs.mjs → src/test/integration/.\n\n**Scripts Organization** - Keep scripts/ but organize: scripts/build/ (move build-vsix.sh), scripts/setup/ (move setup.sh), scripts/testing/ (move test-incremental-saving.sh, test-plugin.sh). After moving integration tests to src/test/, the scripts/ directory will primarily contain build and setup automation.\n\n**Configuration Organization** - Keep src/config/ but expand: src/config/schemas/ (configuration type definitions), src/config/validation/ (configuration validation logic), src/config/defaults/ (default configuration values). The existing configurationManager.ts becomes the facade for this organized configuration system.",
  "recommendations": [
    {
      "title": "Consolidate LLM Integration for Maintainability",
      "description": "**If you want to reduce maintenance burden and eliminate confusion about which LLM service to use**: Consolidate llmService.ts and llmIntegration.ts into a single src/domain/services/llmAnalysisService.ts. This would reduce the codebase by approximately 2000 lines, eliminate duplicate error handling and retry logic, and create a single clear interface for AI-powered analysis. The consolidated service should use the existing ai/providers/ abstraction, ai/llmRateLimiter, ai/llmRetryHandler, and ai/llmResponseParser as dependencies. **Rationale**: Currently 33% of the codebase (5080 LOC) is duplicate LLM integration code. Consolidating eliminates technical debt while maintaining all existing functionality through better-organized code.",
      "relevantFiles": [
        "src/llmIntegration.ts",
        "src/llmService.ts",
        "src/ai/providers/providerFactory.ts",
        "src/ai/llmRateLimiter.ts",
        "src/ai/llmRetryHandler.ts",
        "src/ai/llmResponseParser.ts"
      ],
      "relevantFunctions": [
        "llmIntegration.generateArchitectureInsights",
        "llmService.generateArchitectureInsights",
        "llmIntegration.generateProductDocumentation",
        "llmService.analyzeCodebase"
      ]
    },
    {
      "title": "Extract Domain Layer for Testability and Future Extensibility",
      "description": "**If you want to enable comprehensive unit testing and potentially support other IDEs or CLI usage in the future**: Extract business logic from extension.ts, analyzer.ts, and service files into a domain/ layer with no dependencies on VS Code APIs. Create domain/models/ for core entities (AnalysisResult, ArchitectureIssue, CodebaseHealth), domain/services/ for business logic (AnalysisService, ArchitectureDetectionService), and domain/interfaces/ for abstractions (IFileSystem, IWorkspace). **Rationale**: Current tight coupling to VS Code APIs makes unit testing impossible and prevents code reuse. A clean domain layer following Dependency Inversion Principle enables isolated testing, faster development cycles, and future platform expansion without rewriting business logic.",
      "relevantFiles": [
        "src/extension.ts",
        "src/analyzer.ts",
        "src/insightGenerator.ts",
        "src/llmService.ts"
      ],
      "relevantFunctions": [
        "extension.activate",
        "analyzer.analyzeFile",
        "insightGenerator.generateInsights",
        "llmService.analyzeCodebase"
      ]
    },
    {
      "title": "Unify File Watching for Reliability",
      "description": "**If you want to eliminate race conditions and simplify file change handling**: Consolidate the three separate file watching implementations (fileWatcher.ts, extension.ts inline watcher, cache.ts tracking) into a single domain/services/fileWatcherService.ts that emits domain events. Other components subscribe to FileChanged, FileCreated, FileDeleted events rather than implementing their own watching. **Rationale**: Multiple overlapping file watchers create unpredictable behavior and make debugging difficult. A single event-based file watching service provides reliable change detection with clear subscriber relationships.",
      "relevantFiles": [
        "src/fileWatcher.ts",
        "src/extension.ts",
        "src/cache.ts",
        "src/analyzer.ts"
      ],
      "relevantFunctions": [
        "FileWatcher.watch",
        "extension.activate",
        "cache.updateCache",
        "analyzer.analyzeFile"
      ]
    },
    {
      "title": "Introduce Presentation Layer Architecture",
      "description": "**If you want to reduce code duplication across view components and simplify UI maintenance**: Create a presentation layer with shared view models and base classes. Introduce ui/viewModels/ with typed view models that transform domain data for display. Create a base WebviewProvider class that handles common webview lifecycle, messaging, and state management. Refactor the five existing view components (insightsViewer, insightsTreeView, analysisViewer, staticAnalysisViewer, diagnosticsProvider) to extend base classes and consume view models. **Rationale**: Currently 2528 LOC of presentation code contains significant duplication for view state management, event handling, and data formatting. Shared presentation infrastructure would reduce this by an estimated 30-40% while improving consistency across views.",
      "relevantFiles": [
        "src/insightsViewer.ts",
        "src/insightsTreeView.ts",
        "src/analysisViewer.ts",
        "src/staticAnalysisViewer.ts",
        "src/diagnosticsProvider.ts",
        "src/ui/webview/webviewTemplateEngine.ts"
      ],
      "relevantFunctions": [
        "InsightsViewer.render",
        "InsightsTreeView.refresh",
        "AnalysisViewer.showAnalysis",
        "StaticAnalysisViewer.update",
        "DiagnosticsProvider.updateDiagnostics"
      ]
    },
    {
      "title": "Separate Static and AI-Powered Analysis",
      "description": "**If you want to give users fine-grained control over analysis strategies and improve performance**: Split analyzer.ts into domain/services/staticAnalysisService.ts (AST parsing, dependency detection, complexity metrics) and domain/services/aiAnalysisService.ts (AI-powered insights). Create domain/services/analysisOrchestrator.ts that runs static analysis first (fast, always available) and optionally enriches with AI analysis (slower, requires API key). **Rationale**: Users may want fast static analysis without AI costs, or may want to disable AI analysis in certain contexts. Separation enables configuration flexibility and clearer understanding of which analysis techniques are being used. Static analysis can run in <100ms while AI analysis takes seconds - making this separation explicit improves user experience.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/llmService.ts",
        "src/insightGenerator.ts"
      ],
      "relevantFunctions": [
        "analyzer.analyzeFile",
        "analyzer.detectPatterns",
        "llmService.analyzeCodebase",
        "insightGenerator.generateInsights"
      ]
    },
    {
      "title": "Establish Comprehensive Testing Infrastructure",
      "description": "**If you want to prevent regressions and enable confident refactoring**: Create a full testing infrastructure with src/test/unit/ for domain logic tests, src/test/integration/ for VS Code integration tests, and src/test/fixtures/ for test data. Add @vscode/test-electron and configure test scripts in package.json. Refactor domain logic to be testable (remove VS Code API dependencies as described in other recommendations). Aim for 80%+ coverage of domain services and 50%+ coverage of adapters. **Rationale**: The extension currently has no unit tests despite 15,287 LOC. Comprehensive testing enables safe refactoring, prevents regressions, and improves code quality. The lack of tests makes the architectural improvements described in other recommendations risky without extensive manual testing.",
      "relevantFiles": [
        "scripts/test_architecture_insights.mjs",
        "scripts/test_product_docs.mjs"
      ],
      "relevantFunctions": []
    }
  ],
  "priorities": [
    {
      "title": "Organize Root Directory Documentation",
      "description": "Move 8 markdown files from root to docs/ directory structure (docs/getting-started/, docs/guides/, docs/architecture/, docs/planning/). Move 2 VSIX packages to dist/ directory. **Rationale**: Root directory clutter obscures project structure and makes navigation difficult. This is a low-risk, high-impact change that requires no code modification - just file moves and documentation path updates. Estimated effort: 1-2 hours. Impact: Significantly improves project navigability and professionalism.",
      "relevantFiles": [
        "GET_STARTED.md",
        "IMPLEMENTATION_GUIDE.md",
        "LICENSE",
        "MENU_STRUCTURE.md",
        "PLUGIN_DESIGN.md",
        "QUICK_START.md",
        "README.md",
        "REFACTORING_PLAN.md",
        "shadow-watch-1.0.0.vsix",
        "shadow-watch.vsix"
      ],
      "relevantFunctions": []
    },
    {
      "title": "Consolidate Duplicate LLM Integration Code",
      "description": "Merge llmIntegration.ts (2251 LOC) and llmService.ts (2829 LOC) into single domain/services/llmAnalysisService.ts. Extract shared logic, eliminate duplicate error handling and retry logic, establish single clear interface for AI-powered analysis. **Rationale**: These two files represent 33% of the codebase with significant overlap. Consolidation reduces maintenance burden, eliminates confusion about which service to use, and establishes clearer architecture. This is foundational for other improvements. Estimated effort: 3-5 days. Impact: Reduces codebase by ~2000 lines, dramatically improves maintainability.",
      "relevantFiles": [
        "src/llmIntegration.ts",
        "src/llmService.ts",
        "src/llmFormatter.ts",
        "src/ai/llmResponseParser.ts",
        "src/ai/providers/providerFactory.ts"
      ],
      "relevantFunctions": [
        "llmIntegration.generateArchitectureInsights",
        "llmService.generateArchitectureInsights",
        "llmIntegration.generateProductDocumentation",
        "llmService.analyzeCodebase",
        "llmIntegration.analyzeUnitTests"
      ]
    },
    {
      "title": "Extract Domain Layer from extension.ts God Object",
      "description": "Decompose extension.ts (1407 LOC, 86 functions) into focused modules: infrastructure/extensionBootstrapper.ts (activation/deactivation), infrastructure/commandRegistry.ts (command registration), domain/services/ (business logic extraction), adapters/vscode/ (VS Code API wrappers). Reduce extension.ts to ~100 LOC composition root. **Rationale**: extension.ts violates single responsibility principle and is the biggest barrier to testing and maintainability. Breaking it apart establishes clear architectural boundaries and enables unit testing of business logic. This change has cascading benefits for all other improvements. Estimated effort: 5-7 days. Impact: Enables testing, improves maintainability, establishes foundation for layered architecture.",
      "relevantFiles": [
        "src/extension.ts"
      ],
      "relevantFunctions": [
        "activate",
        "deactivate",
        "registerCommands",
        "setupFileWatcher",
        "analyzeWorkspace",
        "showInsightsPanel",
        "updateDiagnostics",
        "generateInsights",
        "generateProductDocs"
      ]
    },
    {
      "title": "Unify File Watching Systems",
      "description": "Consolidate three separate file watching implementations (fileWatcher.ts, extension.ts inline watcher, cache.ts tracking) into single domain/services/fileWatcherService.ts with event-based architecture. Implement FileChanged, FileCreated, FileDeleted events that other components subscribe to. **Rationale**: Multiple overlapping watchers create race conditions and unpredictable behavior. Single unified watcher with event-based communication simplifies debugging and improves reliability. This affects core functionality (analysis triggering) so fixing it early prevents bugs. Estimated effort: 2-3 days. Impact: Eliminates race conditions, simplifies change tracking, improves reliability.",
      "relevantFiles": [
        "src/fileWatcher.ts",
        "src/extension.ts",
        "src/cache.ts",
        "src/analyzer.ts"
      ],
      "relevantFunctions": [
        "FileWatcher.watch",
        "extension.activate",
        "cache.updateCache",
        "analyzer.analyzeFile"
      ]
    },
    {
      "title": "Establish Testing Infrastructure",
      "description": "Create src/test/ structure with unit/, integration/, fixtures/ directories. Add @vscode/test-electron dependency. Configure test scripts in package.json. Write initial unit tests for domain services (starting with analyzer, insightGenerator). Write integration tests for critical workflows (analyze file, generate insights, update diagnostics). **Rationale**: Zero unit tests for 15,287 LOC makes refactoring risky and prevents confident changes. Testing infrastructure must be established before major architectural refactoring. Initial test suite provides safety net for subsequent improvements. Estimated effort: 3-4 days for infrastructure + initial tests. Impact: Enables safe refactoring, prevents regressions, improves code quality.",
      "relevantFiles": [
        "scripts/test_architecture_insights.mjs",
        "scripts/test_product_docs.mjs"
      ],
      "relevantFunctions": []
    }
  ],
  "cursorPrompt": "You are refactoring the Shadow Watch VS Code extension to improve architecture and maintainability. The extension continuously monitors codebases and provides AI-powered architecture analysis and documentation generation.\n\n## Current Architecture Issues:\n1. Duplicate LLM integration code in llmIntegration.ts (2251 LOC) and llmService.ts (2829 LOC) - 33% of codebase\n2. Three overlapping file watching systems creating race conditions\n3. Presentation logic scattered across 5 view components with significant duplication\n4. God object in extension.ts (1407 LOC, 86 functions) handling too many responsibilities\n5. Missing domain layer - business logic tightly coupled to VS Code APIs\n6. No clear separation between static and AI-powered analysis\n7. No unit testing infrastructure\n\n## Refactoring Priorities:\n1. **Consolidate LLM Integration**: Merge llmIntegration.ts and llmService.ts into domain/services/llmAnalysisService.ts\n2. **Extract Domain Layer**: Create domain/models/ and domain/services/ with no VS Code dependencies\n3. **Decompose extension.ts**: Split into focused modules (bootstrapper, command registry, adapters)\n4. **Unify File Watching**: Single FileWatcherService with event-based architecture\n5. **Establish Testing**: Create test infrastructure and initial test suite\n\n## Target Architecture:\n- src/domain/ - Business logic and models (no VS Code dependencies)\n- src/application/ - Use case orchestration\n- src/infrastructure/ - Technical concerns (caching, file watching, logging)\n- src/presentation/ - View components, view models, webviews\n- src/adapters/ - VS Code API wrappers\n- src/test/ - Unit and integration tests\n\nWhen refactoring, maintain all existing functionality while improving structure. Use dependency injection and interfaces to enable testing.",
  "productPurposeAnalysis": {
    "productPurpose": "Shadow Watch aims to bridge the gap between static code analysis and AI-powered development workflows by providing continuous, real-time architecture monitoring that feeds directly into AI assistant tools. Its core mission is to eliminate friction in the developer feedback loop by detecting architecture issues the moment code is saved and formatting those issues in a way that AI tools can immediately act upon. Rather than replacing human or AI review, it serves as an intelligent intermediary that identifies problems, explains them clearly, and packages them for AI-assisted resolution.",
    "architectureRationale": "The architecture exists as a single VS Code extension entry point because the product serves one primary user type (developers working in VS Code) but must support multiple interaction patterns within that environment. The multi-layered architecture with sidebar, webview, diagnostics, and AI integration reflects the need to meet developers where they work: some want passive inline warnings, others want detailed exploratory views, and still others want to immediately pipe issues to external AI tools. The continuous monitoring system exists because waiting for developers to manually trigger analysis breaks the rapid feedback loop necessary for preventing technical debt. The flexible AI provider abstraction exists because developers use different AI assistants (Cursor, ChatGPT, Claude) and need consistent functionality regardless of their choice. The caching system exists because re-analyzing entire codebases on every save would block development workflow. Multiple view modes (tree, webview, inline diagnostics) exist because different issues require different levels of detail and context.",
    "designDecisions": [
      "Continuous file monitoring on save - Reason: Manual analysis triggers create friction and allow architecture issues to accumulate unnoticed; real-time feedback prevents problems before they compound",
      "Multiple presentation layers (sidebar, webview, diagnostics) - Reason: Different severity issues require different levels of attention; critical errors need inline visibility while architectural insights benefit from detailed formatted views",
      "LLM-ready prompt formatting with provider-specific templates - Reason: Developers already use AI assistants for refactoring but waste time manually formatting context; pre-formatted prompts eliminate that friction and ensure AI tools receive properly structured information",
      "AI provider abstraction supporting OpenAI, Anthropic, and custom endpoints - Reason: Developers have strong preferences for different AI tools based on cost, performance, and availability; forcing a single provider would limit adoption",
      "Severity-based categorization (error, warning, info) - Reason: Not all architecture issues are equally urgent; developers need to prioritize critical problems while keeping lower-severity issues visible for future improvement",
      "Caching of analysis results - Reason: Re-analyzing unchanged files wastes computation and blocks the development workflow; incremental analysis maintains responsiveness",
      "Direct navigation from issues to code locations - Reason: Identifying problems is useless if developers must manually search for the problematic code; one-click navigation reduces time-to-fix",
      "Product documentation generation alongside technical analysis - Reason: Developers often inherit unfamiliar codebases where understanding user-facing purpose is as important as fixing technical issues; bridging this gap accelerates onboarding",
      "Multi-language support - Reason: Real-world projects use multiple languages; requiring different tools per language fragments the developer experience and increases cognitive load"
    ],
    "userGoals": [
      "Catch architecture anti-patterns immediately during development before they become embedded in the codebase",
      "Understand what an unfamiliar codebase actually does from a user perspective without reading every file",
      "Get AI-powered refactoring suggestions without manually copying code and context into chat interfaces",
      "Navigate directly to problematic code locations without searching through files manually",
      "Maintain comprehensive documentation that stays current with code changes without manual effort",
      "Identify circular dependencies and god objects before they cause maintenance nightmares",
      "Use their preferred AI assistant (Cursor, ChatGPT, Claude) without switching tools or reformatting context",
      "See architecture issues at the right level of detail - inline for critical errors, detailed views for exploratory analysis",
      "Analyze specific files quickly during focused work without triggering full workspace scans",
      "Understand test coverage and test purposes through AI-generated documentation that explains what tests verify",
      "Monitor overall codebase health trends over time through quantified health scores",
      "Get actionable suggestions alongside problem identification rather than just being told something is wrong",
      "Work with multiple programming languages in a single project without juggling different analysis tools"
    ],
    "contextualFactors": [
      "VS Code extension ecosystem constraints requiring single extension.js entry point but supporting rich UI capabilities",
      "Real-time development workflow requiring non-blocking, incremental analysis",
      "AI assistant integration landscape with multiple competing tools (Cursor, ChatGPT, Claude) each requiring different prompt formats",
      "Developer context-switching costs making inline and sidebar views necessary to avoid leaving the editor",
      "Codebase complexity growth over time requiring automated monitoring since manual reviews don't scale",
      "Multi-language project realities where teams mix JavaScript, Python, Go, and other languages",
      "Performance requirements for large codebases where full re-analysis on every save would be prohibitive",
      "Developer preference diversity where some want passive monitoring and others want active AI-powered guidance",
      "Documentation drift problem where manually written docs become outdated immediately after code changes",
      "Knowledge transfer challenges when developers join projects and need to understand both technical architecture and user-facing purpose",
      "Architecture anti-pattern detection requiring AST parsing and dependency graph analysis beyond simple regex matching",
      "AI API rate limits and costs requiring intelligent caching and selective analysis triggering"
    ]
  },
  "_metadata": {
    "generatedAt": "2025-11-18T05:01:30.115Z",
    "generatedAtLocal": "11/17/2025, 9:01:30 PM",
    "runId": "architecture-insights-2025-11-18T04-58-27-307Z"
  }
}