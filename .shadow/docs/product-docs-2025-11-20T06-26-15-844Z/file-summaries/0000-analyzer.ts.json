{
  "file": "src/analyzer.ts",
  "role": "Core Logic",
  "purpose": "Defines data structures and interfaces for representing code analysis results including file metrics, function metadata, dependencies, test mappings, and code relationships",
  "userVisibleActions": [
    "View total file, line, and function counts across the codebase",
    "See list of large files that may need optimization",
    "Identify orphaned files not imported anywhere",
    "Discover entry points into the application",
    "Find duplicate code blocks across the codebase",
    "Review function risk levels (high, medium, low) for maintenance priority",
    "See which functions have test coverage and which don't",
    "View import relationships between files",
    "Identify functions with external dependencies (databases, HTTP, filesystem, etc.)"
  ],
  "developerVisibleActions": [
    "Import and use CodeAnalysis interface to structure analysis results",
    "Access function metadata including parameters, return types, and visibility",
    "Query branch complexity information (if/else, loops, try/catch)",
    "Examine dependency information to understand external service calls",
    "Track state mutations within functions (assignments, modifications, deletions)",
    "Map source files to their corresponding test files",
    "Identify uncovered functions that lack tests",
    "Use AnalysisCache for performance optimization",
    "Access circular dependency detection results",
    "Review similarity scores for duplicate code detection"
  ],
  "keyFunctions": [
    {
      "name": "CodeAnalysis",
      "desc": "Main interface representing complete codebase analysis results",
      "inputs": "N/A (interface)",
      "outputs": "Structure containing files, functions, imports, orphans, entry points, duplicates, and optional enhanced metadata"
    },
    {
      "name": "FunctionMetadata",
      "desc": "Detailed metadata about a single function including parameters, branches, dependencies, and risk assessment",
      "inputs": "N/A (interface)",
      "outputs": "Function name, file location, parameters, return type, visibility, branches, dependencies, state mutations, risk level"
    },
    {
      "name": "TestMapping",
      "desc": "Maps source code to test coverage",
      "inputs": "N/A (interface)",
      "outputs": "Source files to test files mapping, functions to test names mapping, list of uncovered functions"
    },
    {
      "name": "DependencyInfo",
      "desc": "Describes external or internal dependencies used by functions",
      "inputs": "N/A (interface)",
      "outputs": "Dependency name, type (db/http/filesystem/etc), whether internal or external, line number"
    },
    {
      "name": "BranchInfo",
      "desc": "Represents control flow branches for complexity analysis",
      "inputs": "N/A (interface)",
      "outputs": "Branch type (if/loop/try/etc), human-readable condition, line number"
    },
    {
      "name": "StateMutationInfo",
      "desc": "Tracks how functions modify state",
      "inputs": "N/A (interface)",
      "outputs": "Target of mutation, mutation type (assign/modify/delete/read), line number"
    }
  ],
  "dependencies": [
    "fs",
    "path",
    "./cache"
  ],
  "intent": "This file exists to provide a comprehensive, structured schema for representing static code analysis results. It solves the problem of consistently capturing and communicating code quality metrics, architectural relationships, test coverage, complexity indicators, and maintenance risk factors. It enables other parts of the system to work with a standardized representation of codebase structure and behavior, supporting decisions about refactoring, testing, and code organization.",
  "rawContent": "```json\n{\n  \"purpose\": \"Defines data structures and interfaces for representing code analysis results including file metrics, function metadata, dependencies, test mappings, and code relationships\",\n  \"userVisibleActions\": [\n    \"View total file, line, and function counts across the codebase\",\n    \"See list of large files that may need optimization\",\n    \"Identify orphaned files not imported anywhere\",\n    \"Discover entry points into the application\",\n    \"Find duplicate code blocks across the codebase\",\n    \"Review function risk levels (high, medium, low) for maintenance priority\",\n    \"See which functions have test coverage and which don't\",\n    \"View import relationships between files\",\n    \"Identify functions with external dependencies (databases, HTTP, filesystem, etc.)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import and use CodeAnalysis interface to structure analysis results\",\n    \"Access function metadata including parameters, return types, and visibility\",\n    \"Query branch complexity information (if/else, loops, try/catch)\",\n    \"Examine dependency information to understand external service calls\",\n    \"Track state mutations within functions (assignments, modifications, deletions)\",\n    \"Map source files to their corresponding test files\",\n    \"Identify uncovered functions that lack tests\",\n    \"Use AnalysisCache for performance optimization\",\n    \"Access circular dependency detection results\",\n    \"Review similarity scores for duplicate code detection\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"CodeAnalysis\",\n      \"desc\": \"Main interface representing complete codebase analysis results\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Structure containing files, functions, imports, orphans, entry points, duplicates, and optional enhanced metadata\"\n    },\n    {\n      \"name\": \"FunctionMetadata\",\n      \"desc\": \"Detailed metadata about a single function including parameters, branches, dependencies, and risk assessment\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Function name, file location, parameters, return type, visibility, branches, dependencies, state mutations, risk level\"\n    },\n    {\n      \"name\": \"TestMapping\",\n      \"desc\": \"Maps source code to test coverage\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Source files to test files mapping, functions to test names mapping, list of uncovered functions\"\n    },\n    {\n      \"name\": \"DependencyInfo\",\n      \"desc\": \"Describes external or internal dependencies used by functions\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Dependency name, type (db/http/filesystem/etc), whether internal or external, line number\"\n    },\n    {\n      \"name\": \"BranchInfo\",\n      \"desc\": \"Represents control flow branches for complexity analysis\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Branch type (if/loop/try/etc), human-readable condition, line number\"\n    },\n    {\n      \"name\": \"StateMutationInfo\",\n      \"desc\": \"Tracks how functions modify state\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Target of mutation, mutation type (assign/modify/delete/read), line number\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./cache\"\n  ],\n  \"intent\": \"This file exists to provide a comprehensive, structured schema for representing static code analysis results. It solves the problem of consistently capturing and communicating code quality metrics, architectural relationships, test coverage, complexity indicators, and maintenance risk factors. It enables other parts of the system to work with a standardized representation of codebase structure and behavior, supporting decisions about refactoring, testing, and code organization.\"\n}\n```",
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-20T06:28:52.075Z"
  }
}