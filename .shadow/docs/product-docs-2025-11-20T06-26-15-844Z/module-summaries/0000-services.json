{
  "module": "src/domain/services",
  "moduleType": "other",
  "capabilities": [
    "Automatic detection and monitoring of file system changes across the workspace",
    "Intelligent test framework detection and configuration validation",
    "Iterative AI-powered codebase analysis with progressive information gathering",
    "Consolidated event handling to prevent duplicate processing of file changes",
    "Automatic dependency and configuration validation for test frameworks"
  ],
  "summary": "This module provides core services that power the extension's intelligent automation features. It monitors file system changes and document saves to keep the UI and analysis up-to-date without user intervention. When files are created, modified, or deleted, the service automatically detects these changes and triggers appropriate updates across the extension.\n\nThe module enables AI-powered analysis through an iterative process where the LLM can progressively request additional files or perform grep searches across the codebase until it has sufficient information to complete its task. This allows for thorough, context-aware analysis without overwhelming the AI with unnecessary information upfront.\n\nFor test generation workflows, the module automatically detects which test framework is in use (Jest, Mocha, Vitest, or Pytest), validates the configuration, and identifies missing dependencies. Users receive clear feedback about what needs to be installed or configured before generated tests can run, eliminating manual setup and configuration guesswork.",
  "files": [
    {
      "file": "src/domain/services/fileWatcherService.ts",
      "role": "Core Logic",
      "purpose": "Provides a unified service for watching file system changes and document saves across the extension to eliminate code duplication.",
      "userVisibleActions": [
        "File changes are automatically detected when files matching watched patterns are created, modified, or deleted",
        "Document saves trigger automatic updates and refreshes in related UI components",
        "Changes to specific file types (like documentation files) are monitored and processed",
        "File system events are consolidated to prevent duplicate processing of the same changes"
      ],
      "developerVisibleActions": [
        "Register file watchers with custom patterns and handlers to respond to file system changes",
        "Subscribe to document save events with custom callback functions",
        "Configure ignore patterns to exclude specific files or directories from being watched",
        "Control which types of events to watch (create, change, delete) per pattern",
        "Manage multiple handlers for the same file pattern with unique identifiers",
        "Dispose of specific watchers or all watchers to clean up resources",
        "Receive standardized FileChangeEvent objects with URI and event type information"
      ],
      "keyFunctions": [
        {
          "name": "watch",
          "desc": "Registers a file system watcher for a specific pattern with options to filter event types and ignore patterns",
          "inputs": "id (string), pattern (string or RelativePattern), handler (FileChangeHandler), options (watchCreate, watchChange, watchDelete, ignorePatterns)",
          "outputs": "Disposable object to unregister the watcher"
        },
        {
          "name": "onDocumentSave",
          "desc": "Registers a handler to be called whenever any document is saved in the workspace",
          "inputs": "handler function that receives a TextDocument",
          "outputs": "Disposable object to unregister the handler"
        },
        {
          "name": "unwatch",
          "desc": "Removes a specific file watcher by its unique identifier",
          "inputs": "id (string)",
          "outputs": "void"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all watchers and handlers, releasing system resources",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getPatternKey",
          "desc": "Generates a unique key for a file pattern to identify and deduplicate watchers",
          "inputs": "pattern (string or RelativePattern)",
          "outputs": "string key"
        },
        {
          "name": "shouldIgnore",
          "desc": "Determines if a file URI should be ignored based on configured ignore patterns",
          "inputs": "uri (vscode.Uri), ignorePatterns (array of strings)",
          "outputs": "boolean"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "This file exists to consolidate duplicate file watching logic that was previously scattered across multiple files (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It solves the problem of maintaining consistent file watching behavior and prevents resource leaks by providing a single, well-managed service that can handle multiple watchers with different patterns, ignore rules, and event handlers while ensuring proper cleanup and disposal.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a unified service for watching file system changes and document saves across the extension to eliminate code duplication.\",\n  \"userVisibleActions\": [\n    \"File changes are automatically detected when files matching watched patterns are created, modified, or deleted\",\n    \"Document saves trigger automatic updates and refreshes in related UI components\",\n    \"Changes to specific file types (like documentation files) are monitored and processed\",\n    \"File system events are consolidated to prevent duplicate processing of the same changes\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register file watchers with custom patterns and handlers to respond to file system changes\",\n    \"Subscribe to document save events with custom callback functions\",\n    \"Configure ignore patterns to exclude specific files or directories from being watched\",\n    \"Control which types of events to watch (create, change, delete) per pattern\",\n    \"Manage multiple handlers for the same file pattern with unique identifiers\",\n    \"Dispose of specific watchers or all watchers to clean up resources\",\n    \"Receive standardized FileChangeEvent objects with URI and event type information\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"watch\",\n      \"desc\": \"Registers a file system watcher for a specific pattern with options to filter event types and ignore patterns\",\n      \"inputs\": \"id (string), pattern (string or RelativePattern), handler (FileChangeHandler), options (watchCreate, watchChange, watchDelete, ignorePatterns)\",\n      \"outputs\": \"Disposable object to unregister the watcher\"\n    },\n    {\n      \"name\": \"onDocumentSave\",\n      \"desc\": \"Registers a handler to be called whenever any document is saved in the workspace\",\n      \"inputs\": \"handler function that receives a TextDocument\",\n      \"outputs\": \"Disposable object to unregister the handler\"\n    },\n    {\n      \"name\": \"unwatch\",\n      \"desc\": \"Removes a specific file watcher by its unique identifier\",\n      \"inputs\": \"id (string)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all watchers and handlers, releasing system resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getPatternKey\",\n      \"desc\": \"Generates a unique key for a file pattern to identify and deduplicate watchers\",\n      \"inputs\": \"pattern (string or RelativePattern)\",\n      \"outputs\": \"string key\"\n    },\n    {\n      \"name\": \"shouldIgnore\",\n      \"desc\": \"Determines if a file URI should be ignored based on configured ignore patterns\",\n      \"inputs\": \"uri (vscode.Uri), ignorePatterns (array of strings)\",\n      \"outputs\": \"boolean\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"This file exists to consolidate duplicate file watching logic that was previously scattered across multiple files (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It solves the problem of maintaining consistent file watching behavior and prevents resource leaks by providing a single, well-managed service that can handle multiple watchers with different patterns, ignore rules, and event handlers while ensuring proper cleanup and disposal.\"\n}\n```"
    },
    {
      "file": "src/domain/services/incrementalAnalysisService.ts",
      "role": "Core Logic",
      "purpose": "Manages iterative AI analysis sessions where the LLM can request additional file content or grep searches across multiple iterations until it has enough information to complete its task",
      "userVisibleActions": [
        "AI progressively gathers more information about the codebase by requesting specific files",
        "AI performs grep searches to find relevant code patterns across the project",
        "Analysis completes after gathering sufficient information or reaching maximum iteration limit",
        "Receives additional context information formatted as markdown sections"
      ],
      "developerVisibleActions": [
        "Trigger incremental analysis that automatically handles LLM requests for files and grep searches",
        "Monitor analysis progress through iteration callbacks (onIterationStart, onIterationComplete)",
        "Control maximum number of analysis iterations to prevent infinite loops",
        "Receive structured results including all processed requests and conversation history",
        "Access shouldContinue flag to determine if analysis needs more iterations"
      ],
      "keyFunctions": [
        {
          "name": "processRequests",
          "desc": "Processes LLM-requested file reads and grep searches, returning formatted additional information and updated conversation messages",
          "inputs": "requests (LLMRequest[]), currentResult (any), messages (conversation history)",
          "outputs": "ProcessRequestsResult with additionalInfo string and updated messages array"
        },
        {
          "name": "iterativeAnalysis (implied by async iterator pattern)",
          "desc": "Executes multiple analysis iterations, processing file/grep requests between each iteration until completion or max iterations reached",
          "inputs": "iteration callbacks, max iterations, initial result and messages",
          "outputs": "IterationResult containing final result, iteration count, all requests, and continuation status"
        }
      ],
      "dependencies": [
        "fileAccessHelper",
        "LLMRequest interface",
        "FileAccessHelper class"
      ],
      "intent": "Eliminates code duplication by centralizing the iterative LLM analysis pattern where AI agents can request additional files or perform grep searches during analysis, making the process more testable by converting while loops to async iterators and providing structured callbacks for monitoring progress",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages iterative AI analysis sessions where the LLM can request additional file content or grep searches across multiple iterations until it has enough information to complete its task\",\n  \"userVisibleActions\": [\n    \"AI progressively gathers more information about the codebase by requesting specific files\",\n    \"AI performs grep searches to find relevant code patterns across the project\",\n    \"Analysis completes after gathering sufficient information or reaching maximum iteration limit\",\n    \"Receives additional context information formatted as markdown sections\"\n  ],\n  \"developerVisibleActions\": [\n    \"Trigger incremental analysis that automatically handles LLM requests for files and grep searches\",\n    \"Monitor analysis progress through iteration callbacks (onIterationStart, onIterationComplete)\",\n    \"Control maximum number of analysis iterations to prevent infinite loops\",\n    \"Receive structured results including all processed requests and conversation history\",\n    \"Access shouldContinue flag to determine if analysis needs more iterations\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Processes LLM-requested file reads and grep searches, returning formatted additional information and updated conversation messages\",\n      \"inputs\": \"requests (LLMRequest[]), currentResult (any), messages (conversation history)\",\n      \"outputs\": \"ProcessRequestsResult with additionalInfo string and updated messages array\"\n    },\n    {\n      \"name\": \"iterativeAnalysis (implied by async iterator pattern)\",\n      \"desc\": \"Executes multiple analysis iterations, processing file/grep requests between each iteration until completion or max iterations reached\",\n      \"inputs\": \"iteration callbacks, max iterations, initial result and messages\",\n      \"outputs\": \"IterationResult containing final result, iteration count, all requests, and continuation status\"\n    }\n  ],\n  \"dependencies\": [\n    \"fileAccessHelper\",\n    \"LLMRequest interface\",\n    \"FileAccessHelper class\"\n  ],\n  \"intent\": \"Eliminates code duplication by centralizing the iterative LLM analysis pattern where AI agents can request additional files or perform grep searches during analysis, making the process more testable by converting while loops to async iterators and providing structured callbacks for monitoring progress\"\n}\n```"
    },
    {
      "file": "src/domain/services/testConfigurationService.ts",
      "role": "Core Logic",
      "purpose": "Automatically detects test framework configuration and dependencies to ensure generated tests work without manual user setup",
      "userVisibleActions": [
        "Automatically detects which test framework is being used (Jest, Mocha, Vitest, or Pytest)",
        "Identifies missing test dependencies that need to be installed",
        "Provides setup recommendations when test configuration is incomplete",
        "Warns about missing configuration files needed for tests to run",
        "Reports whether the workspace is ready to run generated tests"
      ],
      "developerVisibleActions": [
        "Scans package.json to detect test framework from scripts and dependencies",
        "Checks for framework-specific configuration files (jest.config.js, .mocharc.json, vitest.config.ts, pytest.ini)",
        "Validates TypeScript-related test dependencies (ts-jest, @jest/globals)",
        "Determines if additional setup actions are required before tests can run",
        "Returns structured status information about test configuration state"
      ],
      "keyFunctions": [
        {
          "name": "detectTestConfiguration",
          "desc": "Analyzes workspace to determine test framework and configuration status",
          "inputs": "workspaceRoot: string (path to workspace folder)",
          "outputs": "TestConfigStatus object containing framework type, configuration state, missing dependencies, and required setup actions"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "SWLogger"
      ],
      "intent": "Eliminates the need for users to manually configure test frameworks by automatically detecting what's available and what's missing, ensuring a smooth experience when generating and running tests. Solves the problem of tests failing due to missing configuration or dependencies by proactively identifying issues.",
      "rawContent": "```json\n{\n  \"purpose\": \"Automatically detects test framework configuration and dependencies to ensure generated tests work without manual user setup\",\n  \"userVisibleActions\": [\n    \"Automatically detects which test framework is being used (Jest, Mocha, Vitest, or Pytest)\",\n    \"Identifies missing test dependencies that need to be installed\",\n    \"Provides setup recommendations when test configuration is incomplete\",\n    \"Warns about missing configuration files needed for tests to run\",\n    \"Reports whether the workspace is ready to run generated tests\"\n  ],\n  \"developerVisibleActions\": [\n    \"Scans package.json to detect test framework from scripts and dependencies\",\n    \"Checks for framework-specific configuration files (jest.config.js, .mocharc.json, vitest.config.ts, pytest.ini)\",\n    \"Validates TypeScript-related test dependencies (ts-jest, @jest/globals)\",\n    \"Determines if additional setup actions are required before tests can run\",\n    \"Returns structured status information about test configuration state\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"detectTestConfiguration\",\n      \"desc\": \"Analyzes workspace to determine test framework and configuration status\",\n      \"inputs\": \"workspaceRoot: string (path to workspace folder)\",\n      \"outputs\": \"TestConfigStatus object containing framework type, configuration state, missing dependencies, and required setup actions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"SWLogger\"\n  ],\n  \"intent\": \"Eliminates the need for users to manually configure test frameworks by automatically detecting what's available and what's missing, ensuring a smooth experience when generating and running tests. Solves the problem of tests failing due to missing configuration or dependencies by proactively identifying issues.\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-20T06:39:44.983Z"
  }
}