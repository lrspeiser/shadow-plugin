{
  "module": "src/domain/services",
  "moduleType": "other",
  "capabilities": [
    "Automatically monitors workspace file system changes in real-time",
    "Progressively analyzes code using AI with iterative context gathering",
    "Automatically detects test framework configuration and setup requirements",
    "Filters and manages which files trigger automated responses",
    "Performs intelligent code searches when AI needs specific information",
    "Validates test environment configuration without manual user intervention"
  ],
  "summary": "This module provides intelligent automation services that enhance the development workflow through file monitoring, AI-powered analysis, and test environment management. Users benefit from automatic detection of file changes (creation, modification, deletion) that trigger relevant UI updates across the extension, while file watching can be configured to ignore specific patterns or directories. The module orchestrates multi-step AI analysis workflows that progressively gather code context by reading additional files and searching for patterns when needed, with built-in safeguards to prevent infinite analysis loops.\n\nThe services work together to minimize manual configuration and provide a seamless experience. When users save documents or modify their workspace, the file watcher automatically propagates these changes to relevant components. During code analysis, the incremental analysis service intelligently determines what additional information is needed and fetches it iteratively, showing progress throughout long-running operations. The test configuration service automatically identifies the project's test framework, detects missing dependencies, and flags configuration issues, ensuring that generated tests work correctly without requiring users to manually configure test setups or specify framework details.",
  "files": [
    {
      "file": "src/domain/services/fileWatcherService.ts",
      "role": "Core Logic",
      "purpose": "Provides a centralized service for monitoring file system changes across the extension, consolidating all file watching functionality to eliminate duplication.",
      "userVisibleActions": [
        "Automatically detects when files are created in the workspace",
        "Automatically detects when files are modified in the workspace",
        "Automatically detects when files are deleted from the workspace",
        "Automatically responds when user saves a document in the editor",
        "Filters out specific files or patterns from being watched (e.g., ignoring certain directories)",
        "Triggers updates in various UI components when relevant files change"
      ],
      "developerVisibleActions": [
        "Register file watchers for specific file patterns (e.g., '**/*.md', '**/*.json')",
        "Receive notifications when files matching patterns are created, changed, or deleted",
        "Subscribe to document save events across all open documents",
        "Configure which file system events to monitor (create, change, delete)",
        "Set up ignore patterns to exclude certain files from being watched",
        "Clean up watchers when components are disposed",
        "Handle file change events asynchronously with custom logic",
        "Use a single service instance to avoid duplicate file watchers"
      ],
      "keyFunctions": [
        {
          "name": "watch",
          "desc": "Registers a file watcher for a specific pattern and returns a disposable to stop watching",
          "inputs": "id (string), pattern (glob or RelativePattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete flags)",
          "outputs": "vscode.Disposable to stop the watcher"
        },
        {
          "name": "onDocumentSave",
          "desc": "Registers a handler to be called whenever any document is saved in the editor",
          "inputs": "handler (callback function accepting TextDocument)",
          "outputs": "vscode.Disposable to unregister the handler"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all active file watchers and document save handlers",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getPatternKey",
          "desc": "Generates a unique key for a file pattern to avoid duplicate watchers",
          "inputs": "pattern (string or RelativePattern)",
          "outputs": "string key"
        },
        {
          "name": "shouldIgnore",
          "desc": "Determines if a file path should be ignored based on configured patterns",
          "inputs": "filePath (string), ignorePatterns (array of glob patterns)",
          "outputs": "boolean indicating whether to ignore the file"
        },
        {
          "name": "handleFileSystemEvent",
          "desc": "Processes file system events and dispatches them to registered handlers",
          "inputs": "uri (file URI), type (created/changed/deleted), patternKey (string)",
          "outputs": "void (triggers async handlers)"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "This file exists to eliminate code duplication across multiple extension components that need to watch for file changes. Previously, fileWatcher.ts, productNavigator.ts, and insightsViewer.ts each had their own file watching logic. By consolidating into a single service, the extension can efficiently manage file system monitoring, avoid redundant watchers, ensure consistent behavior, and make it easier to maintain file watching functionality across the entire codebase.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a centralized service for monitoring file system changes across the extension, consolidating all file watching functionality to eliminate duplication.\",\n  \"userVisibleActions\": [\n    \"Automatically detects when files are created in the workspace\",\n    \"Automatically detects when files are modified in the workspace\",\n    \"Automatically detects when files are deleted from the workspace\",\n    \"Automatically responds when user saves a document in the editor\",\n    \"Filters out specific files or patterns from being watched (e.g., ignoring certain directories)\",\n    \"Triggers updates in various UI components when relevant files change\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register file watchers for specific file patterns (e.g., '**/*.md', '**/*.json')\",\n    \"Receive notifications when files matching patterns are created, changed, or deleted\",\n    \"Subscribe to document save events across all open documents\",\n    \"Configure which file system events to monitor (create, change, delete)\",\n    \"Set up ignore patterns to exclude certain files from being watched\",\n    \"Clean up watchers when components are disposed\",\n    \"Handle file change events asynchronously with custom logic\",\n    \"Use a single service instance to avoid duplicate file watchers\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"watch\",\n      \"desc\": \"Registers a file watcher for a specific pattern and returns a disposable to stop watching\",\n      \"inputs\": \"id (string), pattern (glob or RelativePattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete flags)\",\n      \"outputs\": \"vscode.Disposable to stop the watcher\"\n    },\n    {\n      \"name\": \"onDocumentSave\",\n      \"desc\": \"Registers a handler to be called whenever any document is saved in the editor\",\n      \"inputs\": \"handler (callback function accepting TextDocument)\",\n      \"outputs\": \"vscode.Disposable to unregister the handler\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all active file watchers and document save handlers\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getPatternKey\",\n      \"desc\": \"Generates a unique key for a file pattern to avoid duplicate watchers\",\n      \"inputs\": \"pattern (string or RelativePattern)\",\n      \"outputs\": \"string key\"\n    },\n    {\n      \"name\": \"shouldIgnore\",\n      \"desc\": \"Determines if a file path should be ignored based on configured patterns\",\n      \"inputs\": \"filePath (string), ignorePatterns (array of glob patterns)\",\n      \"outputs\": \"boolean indicating whether to ignore the file\"\n    },\n    {\n      \"name\": \"handleFileSystemEvent\",\n      \"desc\": \"Processes file system events and dispatches them to registered handlers\",\n      \"inputs\": \"uri (file URI), type (created/changed/deleted), patternKey (string)\",\n      \"outputs\": \"void (triggers async handlers)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication across multiple extension components that need to watch for file changes. Previously, fileWatcher.ts, productNavigator.ts, and insightsViewer.ts each had their own file watching logic. By consolidating into a single service, the extension can efficiently manage file system monitoring, avoid redundant watchers, ensure consistent behavior, and make it easier to maintain file watching functionality across the entire codebase.\"\n}\n```"
    },
    {
      "file": "src/domain/services/incrementalAnalysisService.ts",
      "role": "Core Logic",
      "purpose": "Manages iterative LLM analysis by processing file and grep requests across multiple analysis iterations until completion or limit is reached",
      "userVisibleActions": [
        "Performs multi-step code analysis that progressively gathers more information",
        "Reads additional files when the AI needs more context",
        "Searches code using grep when the AI needs to find specific patterns",
        "Limits analysis to prevent infinite loops (max iterations)",
        "Shows progress through iteration callbacks during long-running analysis"
      ],
      "developerVisibleActions": [
        "Provides async iterator pattern for testable incremental analysis",
        "Executes file read requests from LLM responses",
        "Executes grep search requests from LLM responses",
        "Limits requests to 5 per iteration to prevent overload",
        "Maintains conversation history across iterations",
        "Returns structured results with iteration count and request history",
        "Notifies through callbacks when iterations start and complete",
        "Determines when to continue or stop iterations"
      ],
      "keyFunctions": [
        {
          "name": "processRequests",
          "desc": "Processes LLM file and grep requests to gather additional information",
          "inputs": "requests (LLMRequest[]), currentResult (any), messages (conversation history)",
          "outputs": "ProcessRequestsResult with additionalInfo string and updated messages array"
        },
        {
          "name": "readFiles",
          "desc": "Reads requested files through FileAccessHelper",
          "inputs": "file paths from LLM requests",
          "outputs": "formatted file content as additional info"
        },
        {
          "name": "performGrep",
          "desc": "Executes grep searches through FileAccessHelper",
          "inputs": "grep requests with patterns and paths",
          "outputs": "formatted search results as additional info"
        },
        {
          "name": "async iterator pattern",
          "desc": "Converts while loops to async iterator for iteration control",
          "inputs": "iteration callbacks and max iterations",
          "outputs": "IterationResult with result, iteration count, requests, and continuation flag"
        }
      ],
      "dependencies": [
        "FileAccessHelper",
        "LLMRequest types"
      ],
      "intent": "Eliminates code duplication from llmService.ts by extracting iterative analysis logic into a testable, reusable service that handles the common pattern of LLM requesting additional files and performing searches during multi-step code analysis",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages iterative LLM analysis by processing file and grep requests across multiple analysis iterations until completion or limit is reached\",\n  \"userVisibleActions\": [\n    \"Performs multi-step code analysis that progressively gathers more information\",\n    \"Reads additional files when the AI needs more context\",\n    \"Searches code using grep when the AI needs to find specific patterns\",\n    \"Limits analysis to prevent infinite loops (max iterations)\",\n    \"Shows progress through iteration callbacks during long-running analysis\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provides async iterator pattern for testable incremental analysis\",\n    \"Executes file read requests from LLM responses\",\n    \"Executes grep search requests from LLM responses\",\n    \"Limits requests to 5 per iteration to prevent overload\",\n    \"Maintains conversation history across iterations\",\n    \"Returns structured results with iteration count and request history\",\n    \"Notifies through callbacks when iterations start and complete\",\n    \"Determines when to continue or stop iterations\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Processes LLM file and grep requests to gather additional information\",\n      \"inputs\": \"requests (LLMRequest[]), currentResult (any), messages (conversation history)\",\n      \"outputs\": \"ProcessRequestsResult with additionalInfo string and updated messages array\"\n    },\n    {\n      \"name\": \"readFiles\",\n      \"desc\": \"Reads requested files through FileAccessHelper\",\n      \"inputs\": \"file paths from LLM requests\",\n      \"outputs\": \"formatted file content as additional info\"\n    },\n    {\n      \"name\": \"performGrep\",\n      \"desc\": \"Executes grep searches through FileAccessHelper\",\n      \"inputs\": \"grep requests with patterns and paths\",\n      \"outputs\": \"formatted search results as additional info\"\n    },\n    {\n      \"name\": \"async iterator pattern\",\n      \"desc\": \"Converts while loops to async iterator for iteration control\",\n      \"inputs\": \"iteration callbacks and max iterations\",\n      \"outputs\": \"IterationResult with result, iteration count, requests, and continuation flag\"\n    }\n  ],\n  \"dependencies\": [\n    \"FileAccessHelper\",\n    \"LLMRequest types\"\n  ],\n  \"intent\": \"Eliminates code duplication from llmService.ts by extracting iterative analysis logic into a testable, reusable service that handles the common pattern of LLM requesting additional files and performing searches during multi-step code analysis\"\n}\n```"
    },
    {
      "file": "src/domain/services/testConfigurationService.ts",
      "role": "Core Logic",
      "purpose": "Automatically detects test framework configuration and identifies setup requirements to ensure generated tests work without manual user configuration",
      "userVisibleActions": [
        "Test framework is automatically detected from project files",
        "Missing test dependencies are identified and reported",
        "Configuration issues are detected and flagged",
        "Setup requirements are automatically determined",
        "Test configuration status is provided"
      ],
      "developerVisibleActions": [
        "Service scans workspace root for package.json and test configuration files",
        "Detects which test framework is in use (Jest, Mocha, Vitest, Pytest)",
        "Checks if test dependencies are installed",
        "Identifies missing dependencies that need to be installed",
        "Determines if TypeScript test support is configured",
        "Provides list of setup actions needed to make tests work",
        "Returns comprehensive test configuration status"
      ],
      "keyFunctions": [
        {
          "name": "detectTestConfiguration",
          "desc": "Analyzes workspace to detect test framework and configuration status",
          "inputs": "workspaceRoot: string (path to workspace)",
          "outputs": "TestConfigStatus (framework type, configuration state, missing dependencies, setup actions)"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "SWLogger"
      ],
      "intent": "Eliminates the need for users to manually configure test environments by automatically detecting what test framework is being used, what's already configured, and what needs to be set up to make generated tests run successfully",
      "rawContent": "```json\n{\n  \"purpose\": \"Automatically detects test framework configuration and identifies setup requirements to ensure generated tests work without manual user configuration\",\n  \"userVisibleActions\": [\n    \"Test framework is automatically detected from project files\",\n    \"Missing test dependencies are identified and reported\",\n    \"Configuration issues are detected and flagged\",\n    \"Setup requirements are automatically determined\",\n    \"Test configuration status is provided\"\n  ],\n  \"developerVisibleActions\": [\n    \"Service scans workspace root for package.json and test configuration files\",\n    \"Detects which test framework is in use (Jest, Mocha, Vitest, Pytest)\",\n    \"Checks if test dependencies are installed\",\n    \"Identifies missing dependencies that need to be installed\",\n    \"Determines if TypeScript test support is configured\",\n    \"Provides list of setup actions needed to make tests work\",\n    \"Returns comprehensive test configuration status\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"detectTestConfiguration\",\n      \"desc\": \"Analyzes workspace to detect test framework and configuration status\",\n      \"inputs\": \"workspaceRoot: string (path to workspace)\",\n      \"outputs\": \"TestConfigStatus (framework type, configuration state, missing dependencies, setup actions)\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"SWLogger\"\n  ],\n  \"intent\": \"Eliminates the need for users to manually configure test environments by automatically detecting what test framework is being used, what's already configured, and what needs to be set up to make generated tests run successfully\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-20T02:48:06.490Z"
  }
}