{
  "module": "src/domain/services",
  "moduleType": "other",
  "capabilities": [
    "Automatic file system monitoring that detects when files are created, modified, or deleted",
    "Multi-round intelligent analysis that iteratively requests additional context until sufficient information is gathered",
    "Automatic test framework detection and configuration setup for Jest, Mocha, Vitest, and Pytest",
    "Event-driven architecture that triggers appropriate handlers when workspace files change",
    "Dynamic file and pattern searching across the codebase during analysis",
    "Zero-configuration test generation with automatic dependency and configuration detection"
  ],
  "summary": "This services module provides the core automation and intelligence layer that makes the extension reactive and context-aware. It handles three critical workflows: monitoring the file system for changes and triggering appropriate responses, managing iterative analysis sessions where the LLM can request additional files or search for patterns across multiple rounds until it has enough context, and automatically detecting and configuring test frameworks to ensure generated tests work without manual setup.\n\nUsers benefit from automatic change detection - when they create, modify, or delete files, the system automatically updates relevant views and features without manual refresh. When the LLM needs more information to complete a task, the incremental analysis service orchestrates multiple rounds of context gathering, dynamically including additional files and performing grep searches until the analysis is complete or reaches maximum iterations.\n\nThe test configuration service eliminates manual setup by detecting which testing framework is in use (Jest, Mocha, Vitest, or Pytest), identifying missing dependencies and configuration files, and providing setup guidance. This ensures that generated tests are immediately executable without requiring users to manually configure their test environment, creating a seamless test generation experience.",
  "files": [
    {
      "file": "src/domain/services/fileWatcherService.ts",
      "role": "Core Logic",
      "purpose": "Provides centralized file system watching to detect when files are created, modified, or deleted in the workspace",
      "userVisibleActions": [
        "When user creates a new file matching a watched pattern, registered handlers are automatically triggered",
        "When user modifies an existing file, change detection triggers updates to relevant views or features",
        "When user deletes a file, cleanup and refresh actions occur automatically",
        "When user saves a document, save handlers execute to update related features"
      ],
      "developerVisibleActions": [
        "Provides a unified service to watch file system changes without creating duplicate watchers",
        "Allows multiple components to register handlers for the same file patterns efficiently",
        "Automatically manages watcher lifecycle and cleanup to prevent memory leaks",
        "Supports pattern-based filtering with ignore patterns to exclude specific files",
        "Consolidates document save event handling across multiple features",
        "Provides disposable pattern for proper cleanup of watch registrations"
      ],
      "keyFunctions": [
        {
          "name": "watch",
          "desc": "Registers a handler to be called when files matching a pattern are created, changed, or deleted",
          "inputs": "id (string), pattern (file glob or relative pattern), handler (callback function), options (watch create/change/delete flags, ignore patterns)",
          "outputs": "Disposable object to unregister the watch"
        },
        {
          "name": "onDocumentSave",
          "desc": "Registers a handler to be called whenever a document is saved in the editor",
          "inputs": "handler (callback function receiving the saved document)",
          "outputs": "Disposable object to unregister the handler"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all file watchers and handlers, releasing system resources",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getPatternKey",
          "desc": "Generates a unique key for a file pattern to enable watcher reuse",
          "inputs": "pattern (string or RelativePattern)",
          "outputs": "string key"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "This file exists to eliminate duplication of file watching logic across multiple extension features. Previously, separate components (fileWatcher.ts, productNavigator.ts, insightsViewer.ts) each created their own file watchers, leading to redundant system resource usage and inconsistent behavior. This service consolidates all file watching into a single, efficient implementation that can be shared across the extension, ensuring consistent file change detection and proper resource management.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides centralized file system watching to detect when files are created, modified, or deleted in the workspace\",\n  \"userVisibleActions\": [\n    \"When user creates a new file matching a watched pattern, registered handlers are automatically triggered\",\n    \"When user modifies an existing file, change detection triggers updates to relevant views or features\",\n    \"When user deletes a file, cleanup and refresh actions occur automatically\",\n    \"When user saves a document, save handlers execute to update related features\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provides a unified service to watch file system changes without creating duplicate watchers\",\n    \"Allows multiple components to register handlers for the same file patterns efficiently\",\n    \"Automatically manages watcher lifecycle and cleanup to prevent memory leaks\",\n    \"Supports pattern-based filtering with ignore patterns to exclude specific files\",\n    \"Consolidates document save event handling across multiple features\",\n    \"Provides disposable pattern for proper cleanup of watch registrations\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"watch\",\n      \"desc\": \"Registers a handler to be called when files matching a pattern are created, changed, or deleted\",\n      \"inputs\": \"id (string), pattern (file glob or relative pattern), handler (callback function), options (watch create/change/delete flags, ignore patterns)\",\n      \"outputs\": \"Disposable object to unregister the watch\"\n    },\n    {\n      \"name\": \"onDocumentSave\",\n      \"desc\": \"Registers a handler to be called whenever a document is saved in the editor\",\n      \"inputs\": \"handler (callback function receiving the saved document)\",\n      \"outputs\": \"Disposable object to unregister the handler\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all file watchers and handlers, releasing system resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getPatternKey\",\n      \"desc\": \"Generates a unique key for a file pattern to enable watcher reuse\",\n      \"inputs\": \"pattern (string or RelativePattern)\",\n      \"outputs\": \"string key\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"This file exists to eliminate duplication of file watching logic across multiple extension features. Previously, separate components (fileWatcher.ts, productNavigator.ts, insightsViewer.ts) each created their own file watchers, leading to redundant system resource usage and inconsistent behavior. This service consolidates all file watching into a single, efficient implementation that can be shared across the extension, ensuring consistent file change detection and proper resource management.\"\n}\n```"
    },
    {
      "file": "src/domain/services/incrementalAnalysisService.ts",
      "role": "Core Logic",
      "purpose": "Manages iterative analysis where an LLM can request additional files or grep searches across multiple rounds until it has enough information to complete its task",
      "userVisibleActions": [
        "Analysis progresses through multiple iterations automatically when the LLM needs more context",
        "Additional files are read and included in the analysis when requested",
        "Grep searches are performed across the codebase when the LLM needs to find specific patterns",
        "Analysis stops after reaching maximum iterations or when the LLM has sufficient information"
      ],
      "developerVisibleActions": [
        "Create an IncrementalAnalysisService instance with a FileAccessHelper",
        "Call processRequests() to handle LLM file and grep requests within an iteration",
        "Receive ProcessRequestsResult containing formatted additional information and updated conversation messages",
        "Use IterationCallbacks to monitor iteration start and completion events",
        "Access IterationResult to see final result, iteration count, all requests made, and continuation status",
        "LLM requests are automatically limited to 5 per iteration to prevent excessive processing"
      ],
      "keyFunctions": [
        {
          "name": "processRequests",
          "desc": "Processes LLM-requested file reads and grep searches, returning formatted results and updated conversation messages",
          "inputs": "requests (array of LLMRequest), currentResult (any), messages (conversation history)",
          "outputs": "ProcessRequestsResult containing additionalInfo string and updated messages array"
        }
      ],
      "dependencies": [
        "FileAccessHelper",
        "LLMRequest"
      ],
      "intent": "This file exists to eliminate code duplication from llmService.ts by extracting the iterative analysis logic into a reusable, testable service. It solves the problem of LLMs needing multiple rounds of context gathering (files and grep searches) before producing a final analysis, converting while-loop patterns into structured async iteration patterns for better testing and maintainability.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages iterative analysis where an LLM can request additional files or grep searches across multiple rounds until it has enough information to complete its task\",\n  \"userVisibleActions\": [\n    \"Analysis progresses through multiple iterations automatically when the LLM needs more context\",\n    \"Additional files are read and included in the analysis when requested\",\n    \"Grep searches are performed across the codebase when the LLM needs to find specific patterns\",\n    \"Analysis stops after reaching maximum iterations or when the LLM has sufficient information\"\n  ],\n  \"developerVisibleActions\": [\n    \"Create an IncrementalAnalysisService instance with a FileAccessHelper\",\n    \"Call processRequests() to handle LLM file and grep requests within an iteration\",\n    \"Receive ProcessRequestsResult containing formatted additional information and updated conversation messages\",\n    \"Use IterationCallbacks to monitor iteration start and completion events\",\n    \"Access IterationResult to see final result, iteration count, all requests made, and continuation status\",\n    \"LLM requests are automatically limited to 5 per iteration to prevent excessive processing\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Processes LLM-requested file reads and grep searches, returning formatted results and updated conversation messages\",\n      \"inputs\": \"requests (array of LLMRequest), currentResult (any), messages (conversation history)\",\n      \"outputs\": \"ProcessRequestsResult containing additionalInfo string and updated messages array\"\n    }\n  ],\n  \"dependencies\": [\n    \"FileAccessHelper\",\n    \"LLMRequest\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication from llmService.ts by extracting the iterative analysis logic into a reusable, testable service. It solves the problem of LLMs needing multiple rounds of context gathering (files and grep searches) before producing a final analysis, converting while-loop patterns into structured async iteration patterns for better testing and maintainability.\"\n}\n```"
    },
    {
      "file": "src/domain/services/testConfigurationService.ts",
      "role": "Core Logic",
      "purpose": "Automatically detects and configures test frameworks (Jest, Mocha, Vitest, Pytest) to ensure generated tests work without manual user setup",
      "userVisibleActions": [
        "Automatically detects which test framework is being used in the project",
        "Identifies missing test dependencies and configuration files",
        "Provides setup actions needed to make tests work",
        "Ensures generated tests run without manual configuration"
      ],
      "developerVisibleActions": [
        "Scans workspace for package.json to detect test framework from scripts and dependencies",
        "Checks for framework-specific config files (jest.config.js, vitest.config.ts, pytest.ini, etc.)",
        "Validates that required test dependencies are installed",
        "Returns configuration status with framework type, missing dependencies, and setup requirements",
        "Detects TypeScript test setups (ts-jest, @jest/globals) for Jest projects",
        "Identifies Python virtual environments and pytest installations"
      ],
      "keyFunctions": [
        {
          "name": "detectTestConfiguration",
          "desc": "Analyzes workspace to detect test framework and configuration completeness",
          "inputs": "workspaceRoot: string (path to project root)",
          "outputs": "TestConfigStatus object with framework type, configuration state, missing dependencies, and required setup actions"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "../../logger"
      ],
      "intent": "This file exists to eliminate the friction of setting up test environments by automatically detecting what test framework a project uses and determining if it's properly configured. It solves the problem of generated tests failing due to missing configuration, making the test generation feature work seamlessly across different project setups without requiring users to manually configure test frameworks.",
      "rawContent": "```json\n{\n  \"purpose\": \"Automatically detects and configures test frameworks (Jest, Mocha, Vitest, Pytest) to ensure generated tests work without manual user setup\",\n  \"userVisibleActions\": [\n    \"Automatically detects which test framework is being used in the project\",\n    \"Identifies missing test dependencies and configuration files\",\n    \"Provides setup actions needed to make tests work\",\n    \"Ensures generated tests run without manual configuration\"\n  ],\n  \"developerVisibleActions\": [\n    \"Scans workspace for package.json to detect test framework from scripts and dependencies\",\n    \"Checks for framework-specific config files (jest.config.js, vitest.config.ts, pytest.ini, etc.)\",\n    \"Validates that required test dependencies are installed\",\n    \"Returns configuration status with framework type, missing dependencies, and setup requirements\",\n    \"Detects TypeScript test setups (ts-jest, @jest/globals) for Jest projects\",\n    \"Identifies Python virtual environments and pytest installations\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"detectTestConfiguration\",\n      \"desc\": \"Analyzes workspace to detect test framework and configuration completeness\",\n      \"inputs\": \"workspaceRoot: string (path to project root)\",\n      \"outputs\": \"TestConfigStatus object with framework type, configuration state, missing dependencies, and required setup actions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"../../logger\"\n  ],\n  \"intent\": \"This file exists to eliminate the friction of setting up test environments by automatically detecting what test framework a project uses and determining if it's properly configured. It solves the problem of generated tests failing due to missing configuration, making the test generation feature work seamlessly across different project setups without requiring users to manually configure test frameworks.\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-21T04:26:41.181Z"
  }
}