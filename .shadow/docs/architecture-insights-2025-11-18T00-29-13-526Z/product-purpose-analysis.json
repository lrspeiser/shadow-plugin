{
  "productPurpose": "Shadow Watch exists to bridge the gap between traditional static code analysis and modern AI-assisted development workflows. Its core mission is to make codebases continuously understandable and maintainable by automatically detecting architecture issues in real-time and formatting those insights specifically for AI assistants like Cursor and ChatGPT. Rather than simply finding problems, it translates code health into actionable prompts that developers can immediately use with AI tools to get refactoring guidance, architectural explanations, and documentation updates.",
  "architectureRationale": "The architecture exists as a VS Code extension with a single entry point because developers need architecture insights in the same environment where they write code, not in a separate tool. The multi-layered design (monitoring → analysis → AI integration → presentation) reflects the product's dual nature: it must respond immediately to code changes (continuous monitoring) while also supporting on-demand deep analysis (AI-powered documentation generation). Multiple view components (sidebar, webview, inline diagnostics) exist because developers consume information differently depending on context: quick glances during coding (sidebar), deep dives when reviewing (webview), and immediate feedback while editing (inline). The AI provider abstraction layer exists because different teams use different AI services, and the product must work with OpenAI, Anthropic, or custom endpoints without changing core functionality. The LLM formatter generating provider-specific prompts exists because each AI assistant (Cursor vs ChatGPT vs generic) expects different input formats, and manually reformatting would break the speed advantage of one-click copying.",
  "designDecisions": [
    "Single Node.js entry point (./dist/extension.js) - Reason: VS Code extensions must initialize through one activation point to integrate with the editor's lifecycle, and all functionality branches from there to maintain state consistency across features",
    "File system watcher triggering analysis on save - Reason: Developers need immediate feedback while coding, not after committing, so architecture issues must surface within seconds of writing problematic code",
    "Caching layer for analysis results - Reason: Re-analyzing entire codebases on every save would block development workflow, so incremental caching ensures sub-second response times for unchanged files",
    "Multiple AI provider support with abstraction layer - Reason: Teams have different AI service preferences and budget constraints, so hard-coding one provider would exclude potential users",
    "LLM-ready prompt generation with format variants - Reason: AI assistants parse prompts differently, and formatting issues specifically for each tool (Cursor, ChatGPT, generic) eliminates manual reformatting friction",
    "Sidebar + webview + inline diagnostics presentation - Reason: Different information consumption patterns require different views: sidebar for navigation, webview for detailed reading, inline for contextual awareness while editing",
    "JSON schema validation for AI responses - Reason: AI services return unstructured text, but the extension needs structured data to display insights consistently and enable programmatic navigation",
    "Severity-based categorization (error, warning, info) - Reason: Developers must prioritize fixes, so visual severity indicators help distinguish critical architecture violations from suggestions",
    "Direct code navigation from issues - Reason: Reading about problems is useless without knowing where they exist, so one-click navigation eliminates the search step",
    "Multi-language AST parsing support - Reason: Teams work in polyglot codebases, and language-specific tools would require switching contexts, so supporting Python, JavaScript, TypeScript, Java, Go, Rust, C/C++, Ruby, and PHP in one tool streamlines workflow"
  ],
  "userGoals": [
    "Understand what their codebase does from a product perspective without reading implementation details",
    "Detect architecture anti-patterns like god objects and circular dependencies before they require major refactoring",
    "Get AI-powered refactoring guidance by copying architecture issues directly into Cursor or ChatGPT",
    "Maintain up-to-date product documentation that explains what applications do for users without manual writing",
    "Navigate quickly from architecture issues to specific code locations that need attention",
    "Onboard to unfamiliar codebases by reading AI-generated architectural insights about design patterns and component relationships",
    "Prevent technical debt accumulation through real-time feedback on every code save",
    "Switch between different AI providers (OpenAI, Claude, custom) based on budget, performance, or organizational policies",
    "Understand test coverage and purposes through AI-generated unit test documentation",
    "Work efficiently across multiple programming languages without learning separate analysis tools for each",
    "See codebase health at a glance through percentage scores that summarize architecture quality",
    "Collaborate with AI assistants using properly formatted prompts without manual reformatting effort"
  ],
  "contextualFactors": [
    "VS Code extension ecosystem constraints requiring single activation entry point and event-driven architecture",
    "Real-time feedback requirements necessitating incremental analysis and aggressive caching strategies",
    "AI assistant integration requirements driving need for multiple prompt format generators and one-click copying",
    "Multi-language codebase reality requiring polyglot AST parsing and universal architecture pattern detection",
    "Developer workflow continuity requiring insights accessible without leaving code editor environment",
    "AI service diversity requiring provider abstraction to support OpenAI, Anthropic, and custom endpoints",
    "Performance constraints of large codebases requiring intelligent caching and incremental analysis",
    "Information consumption patterns requiring multiple views (sidebar, webview, inline) for different contexts",
    "Architecture issue prioritization requiring severity-based categorization and visual indicators",
    "Code navigation efficiency requiring direct jumping from issues to source locations",
    "Documentation currency requirements necessitating automatic regeneration triggered by code changes",
    "AI response unpredictability requiring JSON schema validation to ensure structured output"
  ],
  "_metadata": {
    "savedAt": "2025-11-18T00:29:13.527Z"
  }
}