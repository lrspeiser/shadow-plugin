{
  "overview": "Shadow Watch is a VS Code extension that provides AI-powered code intelligence and documentation capabilities for TypeScript and JavaScript projects. It analyzes your codebase to understand its structure, patterns, and quality, then generates comprehensive human-readable documentation automatically. The extension integrates with OpenAI GPT and Anthropic Claude models to transform raw code analysis into architectural insights, product documentation, and actionable recommendations. Users interact with Shadow Watch through multiple sidebar views, commands, and automated workflows that make understanding and documenting large codebases effortless.\n\nThe extension continuously monitors your workspace and can automatically analyze code as you save files, providing real-time feedback through VS Code's Problems panel. It identifies issues like orphaned files, circular dependencies, untested functions, code duplication, and complexity hotspots. All findings are presented with clickable diagnostics that navigate directly to problem locations. Shadow Watch also maintains a persistent cache of analysis results, so reopening your workspace provides instant access to previous insights without re-running expensive AI operations.\n\nBeyond analysis, Shadow Watch transforms how developers navigate and understand codebases. Instead of browsing by file structure, users can explore code through a product-centric view organized by features and capabilities. The extension generates multiple report types including workspace summaries, architecture diagrams, refactoring guides, and test documentation, all accessible through a unified reports dashboard. For teams working with AI coding assistants, Shadow Watch provides specialized context generation that helps LLMs understand your codebase structure and make better recommendations.",
  "whatItDoes": [
    "Automatically analyzes TypeScript and JavaScript codebases to identify quality issues, architectural patterns, and complexity metrics",
    "Generates AI-powered documentation including product overviews, architecture insights, and feature descriptions",
    "Provides multiple sidebar views for browsing code by functionality rather than file structure",
    "Displays real-time diagnostics in VS Code's Problems panel with clickable navigation to issues",
    "Creates comprehensive reports including workspace summaries, refactoring guides, and test documentation",
    "Monitors file changes and can automatically re-analyze code on save for continuous feedback",
    "Caches analysis results for 24 hours to provide instant access when reopening workspaces",
    "Identifies code quality issues like orphaned files, circular dependencies, duplicate code, and untested functions",
    "Generates structured context for AI coding assistants to improve their understanding of your codebase",
    "Supports both manual on-demand analysis and automatic analysis triggered by file saves"
  ],
  "userPerspective": {
    "gui": [
      "Multiple tree view sidebars display analysis results, insights, product navigation, static analysis issues, and available reports",
      "Analysis Viewer shows codebase statistics, file classifications, function listings, and entry points in an expandable tree structure",
      "Insights Viewer displays AI-generated architectural analysis and documentation with automatic updates when files change",
      "Product Navigator organizes code by features and capabilities instead of file structure, allowing functional exploration",
      "Static Analysis Viewer categorizes issues by severity (errors, warnings, info) for easy browsing and navigation",
      "Reports Viewer shows a dashboard of all generated reports with generation timestamps and clickable cards to open reports in browser",
      "Status bar indicator displays current analysis state and provides quick access to commands",
      "Problems panel integration shows all detected issues with clickable diagnostics that jump to source locations",
      "Webview panels display rich HTML reports with formatted documentation, tables, and visual organization",
      "Context menus on sidebar items provide actions like regenerating content, opening files, copying to clipboard, and navigating to code"
    ],
    "cli": [],
    "api": [],
    "cicd": []
  },
  "workflowIntegration": [
    "Automatic code analysis workflow: Save TypeScript files → Extension analyzes changes → Updates diagnostics and views → Displays new insights",
    "Documentation generation workflow: Trigger analysis command → Extension scans codebase → AI generates documentation → Reports saved and displayed",
    "Code exploration workflow: Open Product Navigator → Browse features/modules → Click items → Navigate to source code → View function details",
    "Issue investigation workflow: View problems in Problems panel → Click diagnostic → Navigate to issue location → Review context and recommendations",
    "Report generation workflow: Trigger report command → AI analyzes codebase → Multiple report types generated → Access via Reports Viewer dashboard",
    "Refactoring planning workflow: Analyze large files → Review refactoring suggestions → View extraction plans → Access step-by-step migration guides",
    "Test documentation workflow: Analyze test files → Generate test plans → Review coverage gaps → Access recommendations for missing tests",
    "AI assistant integration workflow: Export analysis context → Provide to AI coding assistant → Receive codebase-aware suggestions",
    "Workspace initialization workflow: Open project → Load cached analysis → Display previous insights → Optionally trigger fresh analysis"
  ],
  "problemsSolved": [
    "Eliminates manual effort required to understand large, unfamiliar codebases by automatically generating comprehensive documentation",
    "Reduces time spent searching for specific functionality by providing product-centric navigation instead of file-based browsing",
    "Identifies code quality issues and technical debt that might otherwise go unnoticed until they cause problems",
    "Provides actionable refactoring guidance for large, complex files that need to be split or reorganized",
    "Reveals gaps in test coverage by mapping functions to their tests and identifying untested code paths",
    "Detects architectural problems like circular dependencies and orphaned files that impact maintainability",
    "Creates documentation that stays synchronized with code through automatic regeneration workflows",
    "Helps AI coding assistants understand project structure by generating structured context from code analysis",
    "Eliminates need to read through thousands of lines of code to understand what an application does",
    "Provides historical tracking of code insights and documentation through timestamped report preservation"
  ],
  "architecture": "Shadow Watch is built as a VS Code extension with a modular architecture centered around code analysis, AI integration, and persistent state management. The core analysis engine examines TypeScript and JavaScript code using Abstract Syntax Tree (AST) parsing to extract detailed metadata about functions, dependencies, complexity metrics, and relationships. This analysis feeds into an insight generation system that identifies patterns, issues, and opportunities for improvement. All analysis results are cached in memory with automatic expiration and persisted to disk in the .shadow directory for historical tracking.\n\nThe AI integration layer connects to either OpenAI GPT or Anthropic Claude models through a provider abstraction that handles rate limiting, retry logic, and response parsing. Prompts are constructed through specialized builders that format analysis results into LLM-optimized inputs, ensuring consistent, high-quality documentation generation. The AI responses are parsed into structured formats and transformed into markdown documentation through formatters that organize content by section and category.\n\nThe user interface consists of multiple tree view providers that display different perspectives on the codebase: analysis results, AI insights, product navigation, static analysis issues, test structure, and available reports. A diagnostics provider integrates with VS Code's Problems panel to surface issues with clickable navigation. State management coordinates data flow between components, persisting user preferences and generated content across sessions. A file watcher service monitors changes and triggers automatic re-analysis, while an incremental analysis service supports iterative workflows where the system makes multiple rounds of file access and code searches until sufficient context is gathered.",
  "titles": [
    "Shadow Watch Extension",
    "Analysis Viewer",
    "Insights Viewer",
    "Product Navigator",
    "Static Analysis Viewer",
    "Reports Viewer",
    "Unit Tests Navigator",
    "AI-Powered Documentation Generation",
    "Automatic Code Analysis",
    "Code Quality Diagnostics",
    "Refactoring Guidance",
    "Test Coverage Analysis",
    "LLM Integration",
    "Codebase Context Generation",
    "Product-Centric Navigation",
    "Workspace Summary Reports",
    "Architecture Insights",
    "Function-Level Analysis",
    "Dependency Mapping",
    "Circular Dependency Detection",
    "Orphaned File Detection",
    "Duplicate Code Detection",
    "Complexity Metrics",
    "Iterative Analysis",
    "Rate-Limited API Access",
    "Retry Handling",
    "Response Parsing",
    "Progress Notifications",
    "File System Monitoring",
    "Incremental Storage",
    "Analysis Result Caching"
  ],
  "descriptions": [
    {
      "title": "Shadow Watch Extension",
      "description": "A VS Code extension that provides AI-powered code intelligence, automated documentation generation, and quality analysis for TypeScript and JavaScript projects. It transforms code analysis into human-readable insights and enables product-centric navigation of codebases.",
      "category": "feature"
    },
    {
      "title": "Analysis Viewer",
      "description": "A sidebar tree view that displays comprehensive codebase statistics, file classifications, function listings, and entry points. Users can browse the analyzed code structure and click items to navigate to source locations.",
      "category": "feature"
    },
    {
      "title": "Insights Viewer",
      "description": "A sidebar tree view that displays AI-generated architectural insights and documentation with automatic updates when insight files change. Shows the current state of documentation and provides actions to regenerate content.",
      "category": "feature"
    },
    {
      "title": "Product Navigator",
      "description": "A sidebar view that organizes code by features and capabilities instead of file structure, allowing users to explore the codebase from a product perspective. Users can click on features, modules, or components to navigate to their implementations.",
      "category": "feature"
    },
    {
      "title": "Static Analysis Viewer",
      "description": "A sidebar tree view that categorizes code quality issues by severity level (errors, warnings, info). Users can browse issues and click them to navigate directly to problem locations in the source code.",
      "category": "feature"
    },
    {
      "title": "Reports Viewer",
      "description": "A unified dashboard that displays all generated reports with their availability status and generation timestamps. Users can click report cards to open HTML reports in their default browser.",
      "category": "feature"
    },
    {
      "title": "AI-Powered Documentation Generation",
      "description": "Automatically generates comprehensive product documentation, architecture insights, and refactoring guides by analyzing code and using LLM models to create human-readable narratives about what the application does and how it's organized.",
      "category": "feature"
    },
    {
      "title": "Automatic Code Analysis",
      "description": "Monitors file saves and automatically triggers code analysis when TypeScript files are modified, providing continuous feedback without manual intervention. Users can also trigger analysis on-demand through commands.",
      "category": "feature"
    },
    {
      "title": "Code Quality Diagnostics",
      "description": "Integrates with VS Code's Problems panel to display detected issues like orphaned files, circular dependencies, untested functions, and code duplication. All diagnostics are clickable and navigate to the relevant source code location.",
      "category": "feature"
    },
    {
      "title": "Refactoring Guidance",
      "description": "Analyzes large, complex files and generates detailed refactoring recommendations including extraction plans, step-by-step migration instructions, and before-and-after code examples to help developers improve code organization.",
      "category": "feature"
    },
    {
      "title": "Test Coverage Analysis",
      "description": "Maps functions to their corresponding tests and identifies gaps in test coverage. Generates test documentation and recommendations for missing tests to improve code quality.",
      "category": "feature"
    },
    {
      "title": "LLM Integration",
      "description": "Connects to OpenAI GPT or Anthropic Claude models through a flexible provider system that handles API communication, rate limiting, and response parsing. Supports switching between providers based on user configuration.",
      "category": "component"
    },
    {
      "title": "Codebase Context Generation",
      "description": "Creates structured context from code analysis that's optimized for consumption by AI coding assistants, helping them understand project structure and make better recommendations.",
      "category": "feature"
    },
    {
      "title": "Product-Centric Navigation",
      "description": "Organizes and displays code by what it does (features, capabilities, workflows) rather than how it's structured (files, folders), making it easier to understand application functionality.",
      "category": "workflow"
    },
    {
      "title": "Iterative Analysis",
      "description": "Supports multi-round analysis workflows where the system automatically requests additional files and performs code searches across multiple iterations until sufficient context is gathered to complete documentation tasks.",
      "category": "workflow"
    },
    {
      "title": "Analysis Result Caching",
      "description": "Stores analysis results in memory and on disk with automatic 24-hour expiration, providing instant access to previous insights when reopening workspaces without re-running expensive AI operations.",
      "category": "component"
    },
    {
      "title": "File System Monitoring",
      "description": "Watches for file changes, creations, and deletions across the workspace, automatically updating views and triggering re-analysis when relevant files are modified.",
      "category": "component"
    },
    {
      "title": "Rate-Limited API Access",
      "description": "Manages LLM API requests to prevent exceeding provider quotas by implementing intelligent throttling and request queuing based on provider-specific rate limits.",
      "category": "component"
    },
    {
      "title": "Progress Notifications",
      "description": "Displays informative progress indicators during long-running operations like analysis and documentation generation, with support for cancellation and dynamic status updates.",
      "category": "component"
    },
    {
      "title": "Incremental Storage",
      "description": "Saves analysis results and generated documentation with timestamps and version tracking, preserving historical data for audit trails and comparison over time.",
      "category": "component"
    }
  ],
  "relevantFunctions": [
    {
      "name": "activate",
      "description": "Main extension entry point that initializes all components, registers commands, and sets up UI elements when the extension is activated in VS Code",
      "file": "src/extension.ts"
    },
    {
      "name": "analyzeWorkspace",
      "description": "Triggers comprehensive analysis of the entire workspace, scanning all TypeScript and JavaScript files to generate insights and documentation",
      "file": "src/extension.ts"
    },
    {
      "name": "generateArchitectureInsights",
      "description": "Uses AI to analyze code structure and generate architectural documentation describing what the application does, its components, and how they relate",
      "file": "src/llmService.ts"
    },
    {
      "name": "generateProductDocumentation",
      "description": "Creates user-facing product documentation from code analysis, describing features, capabilities, and workflows in human-readable format",
      "file": "src/llmService.ts"
    },
    {
      "name": "navigateToLocation",
      "description": "Opens a file at a specific line and column position, highlights the relevant code section, and brings it into focus for the user",
      "file": "src/domain/handlers/navigationHandler.ts"
    },
    {
      "name": "performIncrementalAnalysis",
      "description": "Executes multi-round analysis where the system iteratively requests files and performs searches until it has sufficient context to complete the task",
      "file": "src/domain/services/incrementalAnalysisService.ts"
    },
    {
      "name": "parseProductDocumentation",
      "description": "Extracts structured product documentation from AI responses, handling both well-formed JSON and malformed text responses with fallback extraction",
      "file": "src/ai/llmResponseParser.ts"
    },
    {
      "name": "updateDiagnostics",
      "description": "Updates the VS Code Problems panel with detected code quality issues, creating clickable diagnostics that navigate to problem locations",
      "file": "src/diagnosticsProvider.ts"
    },
    {
      "name": "generateRefactoringReport",
      "description": "Analyzes large files and produces detailed refactoring guidance including extraction plans and step-by-step migration instructions",
      "file": "src/llmService.ts"
    },
    {
      "name": "getFileContent",
      "description": "Reads and returns the content of a specified file, supporting iterative analysis workflows where AI agents request additional files to examine",
      "file": "src/fileAccessHelper.ts"
    },
    {
      "name": "performGrepSearch",
      "description": "Executes regex-based code searches across the workspace, returning matching lines and locations to help AI agents explore and understand the codebase",
      "file": "src/fileAccessHelper.ts"
    }
  ],
  "relevantDataStructures": [
    {
      "name": "AnalysisResult",
      "description": "Comprehensive structure containing all code analysis data including files, functions, dependencies, test mappings, duplications, and quality metrics",
      "type": "interface",
      "file": "src/analyzer.ts"
    },
    {
      "name": "ProductDocumentation",
      "description": "Structured documentation describing what the application does from a user perspective, including features, workflows, and problems solved",
      "type": "interface",
      "file": "src/fileDocumentation.ts"
    },
    {
      "name": "ArchitectureInsights",
      "description": "AI-generated insights about code architecture including high-level components, relationships, patterns, and recommendations",
      "type": "interface"
    },
    {
      "name": "InsightData",
      "description": "Container for various types of insights including code quality issues, architectural patterns, complexity metrics, and refactoring opportunities",
      "type": "interface"
    },
    {
      "name": "FunctionMetadata",
      "description": "Detailed information about a function including its signature, complexity, dependencies, state changes, and behavioral characteristics",
      "type": "interface",
      "file": "src/analyzer.ts"
    },
    {
      "name": "RefactoringReport",
      "description": "Comprehensive refactoring guidance for large files including extraction plans, migration steps, and code examples",
      "type": "interface"
    },
    {
      "name": "TestCoverageData",
      "description": "Mapping between functions and their corresponding tests, identifying which functions lack test coverage",
      "type": "interface"
    },
    {
      "name": "DiagnosticInfo",
      "description": "Structure representing a code quality issue with severity, location, message, and navigation information for display in Problems panel",
      "type": "interface"
    },
    {
      "name": "LLMProviderConfig",
      "description": "Configuration for AI provider connections including API keys, model selection, and provider-specific settings",
      "type": "interface"
    },
    {
      "name": "NavigationItem",
      "description": "Tree view item representing a navigable code element like a file, function, feature, or module with associated metadata and actions",
      "type": "class"
    }
  ],
  "relevantCodeFiles": [
    {
      "path": "src/extension.ts",
      "description": "Main extension entry point that initializes Shadow Watch, registers all commands, and coordinates between analysis, AI services, and UI components",
      "purpose": "Serves as the extension's activation point and orchestrates the initialization of all features and services",
      "role": "Entry point and coordinator"
    },
    {
      "path": "src/llmService.ts",
      "description": "Orchestrates AI-powered analysis features including insights generation, documentation creation, and refactoring guidance by connecting to LLM providers",
      "purpose": "Manages all AI-powered features that transform code analysis into human-readable documentation and insights",
      "role": "AI orchestration service"
    },
    {
      "path": "src/analyzer.ts",
      "description": "Defines core data structures for code analysis results and provides interfaces for representing files, functions, dependencies, and quality metrics",
      "purpose": "Establishes the type system and data models for representing analyzed code structure and metadata",
      "role": "Data model definitions"
    },
    {
      "path": "src/insightsTreeView.ts",
      "description": "Implements the Insights Viewer sidebar that displays AI-generated documentation status with actions to regenerate or view content",
      "purpose": "Provides the UI for viewing and managing AI-generated documentation and insights within VS Code",
      "role": "UI component"
    },
    {
      "path": "src/productNavigator.ts",
      "description": "Implements the Product Navigator sidebar that organizes code by features and capabilities instead of file structure",
      "purpose": "Enables product-centric code exploration where users browse by what the code does rather than where files are located",
      "role": "UI component"
    },
    {
      "path": "src/diagnosticsProvider.ts",
      "description": "Manages the integration with VS Code's Problems panel, creating and updating diagnostics for detected code quality issues",
      "purpose": "Surfaces code quality issues in VS Code's native Problems panel with clickable navigation to source locations",
      "role": "Diagnostics integration"
    },
    {
      "path": "src/domain/handlers/navigationHandler.ts",
      "description": "Handles user navigation requests from tree views to source code, including opening files, jumping to functions, and highlighting code sections",
      "purpose": "Implements all navigation workflows that allow users to jump from analysis views to source code locations",
      "role": "Navigation logic"
    },
    {
      "path": "src/ai/llmResponseParser.ts",
      "description": "Parses AI responses into structured data formats, handling both well-formed JSON and malformed responses with fallback extraction",
      "purpose": "Ensures reliable extraction of structured documentation from AI responses even when formats are inconsistent",
      "role": "Response parsing"
    },
    {
      "path": "src/domain/prompts/promptBuilder.ts",
      "description": "Constructs specialized prompts for different AI analysis tasks including architecture documentation, product features, and code understanding",
      "purpose": "Centralizes prompt generation to ensure consistent, high-quality inputs to AI models for all analysis tasks",
      "role": "Prompt construction"
    },
    {
      "path": "src/cache.ts",
      "description": "Manages persistent storage and retrieval of analysis results with automatic 24-hour expiration to improve performance",
      "purpose": "Provides fast access to previous analysis results without re-running expensive operations",
      "role": "Caching layer"
    },
    {
      "path": "src/domain/services/incrementalAnalysisService.ts",
      "description": "Supports iterative analysis workflows where the system makes multiple rounds of file requests and code searches until sufficient context is gathered",
      "purpose": "Enables AI agents to explore codebases incrementally by requesting files and performing searches across multiple iterations",
      "role": "Iterative workflow support"
    }
  ],
  "exampleInput": {
    "description": "Example configuration and analysis request showing how users configure the extension and trigger analysis",
    "json": "{\"configuration\":{\"llmProvider\":\"openai\",\"openaiApiKey\":\"sk-...\",\"model\":\"gpt-4\",\"autoAnalyzeOnSave\":true,\"severityThresholds\":{\"error\":8,\"warning\":5,\"info\":3}},\"analysisRequest\":{\"type\":\"workspace\",\"includeTests\":true,\"generateDocumentation\":true,\"documentationTypes\":[\"product\",\"architecture\",\"refactoring\"]}}"
  },
  "exampleOutput": {
    "description": "Example analysis result showing detected issues, generated insights, and documentation structure",
    "json": "{\"analysisResult\":{\"totalFiles\":127,\"totalFunctions\":843,\"issuesFound\":{\"errors\":3,\"warnings\":12,\"info\":8},\"insights\":[{\"type\":\"circular_dependency\",\"severity\":\"error\",\"message\":\"Circular dependency detected between UserService and AuthService\",\"locations\":[{\"file\":\"src/services/UserService.ts\",\"line\":15},{\"file\":\"src/services/AuthService.ts\",\"line\":23}]},{\"type\":\"untested_function\",\"severity\":\"warning\",\"message\":\"Function calculateDiscount has no test coverage\",\"location\":{\"file\":\"src/utils/pricing.ts\",\"line\":45}}],\"documentation\":{\"product\":{\"overview\":\"E-commerce platform that enables users to browse products, manage shopping carts, and complete purchases with integrated payment processing\",\"features\":[\"Product search and filtering\",\"Shopping cart management\",\"Secure checkout and payment\",\"Order tracking\"],\"generatedAt\":\"2024-01-15T14:30:00Z\"},\"architecture\":{\"components\":[{\"name\":\"API Layer\",\"purpose\":\"Handles HTTP requests and routes them to appropriate services\"},{\"name\":\"Service Layer\",\"purpose\":\"Contains business logic for cart management, orders, and payments\"}],\"generatedAt\":\"2024-01-15T14:32:00Z\"}},\"reports\":{\"workspace\":{\"available\":true,\"path\":\".shadow/reports/workspace-summary.html\",\"generatedAt\":\"2024-01-15T14:30:00Z\"},\"refactoring\":{\"available\":true,\"path\":\".shadow/reports/refactoring-guide.html\",\"generatedAt\":\"2024-01-15T14:35:00Z\"}}},\"cacheStatus\":{\"cached\":true,\"expiresAt\":\"2024-01-16T14:30:00Z\"}}"
  },
  "modules": [
    {
      "module": ".",
      "moduleType": "other",
      "capabilities": [
        "Automated testing infrastructure that validates extension functionality and prevents regressions",
        "Code coverage reporting that ensures comprehensive test coverage across the codebase",
        "Integration with VS Code environment through mocking support for extension APIs",
        "TypeScript-native testing configuration for type-safe test development"
      ],
      "summary": "This module provides the testing infrastructure foundation that ensures the reliability and stability of the extension. It configures Jest as the testing framework with TypeScript support, enabling automated unit tests that validate functionality and catch bugs before they reach users. The configuration includes coverage reporting capabilities that track which parts of the codebase are tested, helping maintain high quality standards.\n\nUsers benefit from this module indirectly through improved extension quality and reliability. Every feature and function can be automatically tested to ensure it works as expected, reducing the likelihood of bugs and unexpected behavior. The testing infrastructure includes special support for mocking VS Code APIs, allowing comprehensive testing of extension functionality without requiring a full VS Code environment.\n\nThe coverage reporting capability provides transparency into code quality, giving users confidence that the extension has been thoroughly tested. This testing foundation enables continuous integration workflows where code changes are automatically validated, ensuring that updates and new features maintain the extension's stability and don't introduce breaking changes.",
      "files": [
        {
          "file": "jest.config.js",
          "role": "Core Logic",
          "purpose": "Configures Jest testing framework for TypeScript unit tests with coverage reporting and VS Code mocking support.",
          "userVisibleActions": [
            "Users indirectly benefit from automated testing ensuring code quality and stability",
            "Test results and coverage reports help users trust the extension's reliability"
          ],
          "developerVisibleActions": [
            "Developers can run unit tests using Jest framework with TypeScript support",
            "Developers can view test coverage reports in text, HTML, and lcov formats",
            "Developers can execute tests with 'npm test' or 'jest' commands",
            "Test files are automatically discovered in __tests__ folders or files matching *.test.ts or *.spec.ts patterns",
            "VS Code API calls are mocked during testing to enable unit testing without the actual VS Code environment",
            "TypeScript code is transpiled on-the-fly during test execution",
            "Coverage reports exclude test files, type definitions, and mock files from analysis",
            "Tests run in Node.js environment with 10-second timeout per test"
          ],
          "keyFunctions": [],
          "dependencies": [
            "ts-jest",
            "jest",
            "vscode"
          ],
          "intent": "This file exists to configure the Jest testing framework for a TypeScript-based VS Code extension, enabling developers to write and run unit tests with proper TypeScript compilation, VS Code API mocking, and comprehensive coverage reporting to ensure code quality and maintainability.",
          "rawContent": "```json\n{\n  \"purpose\": \"Configures Jest testing framework for TypeScript unit tests with coverage reporting and VS Code mocking support.\",\n  \"userVisibleActions\": [\n    \"Users indirectly benefit from automated testing ensuring code quality and stability\",\n    \"Test results and coverage reports help users trust the extension's reliability\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developers can run unit tests using Jest framework with TypeScript support\",\n    \"Developers can view test coverage reports in text, HTML, and lcov formats\",\n    \"Developers can execute tests with 'npm test' or 'jest' commands\",\n    \"Test files are automatically discovered in __tests__ folders or files matching *.test.ts or *.spec.ts patterns\",\n    \"VS Code API calls are mocked during testing to enable unit testing without the actual VS Code environment\",\n    \"TypeScript code is transpiled on-the-fly during test execution\",\n    \"Coverage reports exclude test files, type definitions, and mock files from analysis\",\n    \"Tests run in Node.js environment with 10-second timeout per test\"\n  ],\n  \"keyFunctions\": [],\n  \"dependencies\": [\n    \"ts-jest\",\n    \"jest\",\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to configure the Jest testing framework for a TypeScript-based VS Code extension, enabling developers to write and run unit tests with proper TypeScript compilation, VS Code API mocking, and comprehensive coverage reporting to ensure code quality and maintainability.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/ai",
      "moduleType": "other",
      "capabilities": [
        "Automatic rate limiting for multiple LLM providers (OpenAI, Claude) to prevent quota violations",
        "Intelligent retry handling with exponential backoff for transient API failures",
        "Structured parsing of LLM responses into standardized documentation formats",
        "Graceful degradation with fallback text extraction when AI responses are malformed",
        "Provider-specific rate limit management with automatic request throttling"
      ],
      "summary": "The AI module provides a robust infrastructure layer for interacting with Large Language Model (LLM) providers like OpenAI and Claude. It ensures reliable API communication through three key mechanisms: rate limiting, retry handling, and response parsing. Users benefit from automatic protection against API quota violations, with requests being intelligently throttled or delayed based on provider-specific limits.\n\nWhen temporary failures occur (network issues, timeouts, rate limits), the module automatically retries requests with increasing wait times between attempts, maximizing the chance of success without user intervention. All LLM responses are parsed into standardized, structured formats suitable for file summaries, module summaries, and product documentation, with clear sections for purpose, user actions, and dependencies.\n\nThe module operates transparently in the background, handling all complexity of API communication while delivering clean, organized documentation to users. Even when AI responses are incomplete or malformed, the system provides partial data through fallback extraction mechanisms, ensuring users always receive useful output from their documentation generation requests.",
      "files": [
        {
          "file": "src/ai/llmRateLimiter.ts",
          "role": "Core Logic",
          "purpose": "Manages API rate limiting for LLM providers (OpenAI and Claude) to prevent exceeding their request quotas",
          "userVisibleActions": [
            "API requests are automatically throttled to stay within provider limits",
            "Requests may be delayed or rejected if rate limits are exceeded",
            "Different LLM providers (OpenAI, Claude) have different rate limit allowances"
          ],
          "developerVisibleActions": [
            "Configure custom rate limits for each LLM provider (max requests per time window)",
            "Check if a request can be made before calling the LLM API",
            "Record requests to track usage against rate limits",
            "OpenAI defaults to 60 requests per minute, Claude defaults to 50 requests per minute",
            "Rate limits are enforced using a sliding time window approach"
          ],
          "keyFunctions": [
            {
              "name": "constructor",
              "desc": "Initializes rate limiter with default limits for OpenAI (60 req/min) and Claude (50 req/min)",
              "inputs": "none",
              "outputs": "RateLimiter instance"
            },
            {
              "name": "configure",
              "desc": "Sets custom rate limit configuration for a specific LLM provider",
              "inputs": "provider (openai|claude), config (maxRequests, windowMs)",
              "outputs": "void"
            },
            {
              "name": "canMakeRequest",
              "desc": "Checks if a request can be made without exceeding the rate limit for the provider",
              "inputs": "provider (openai|claude)",
              "outputs": "boolean (true if request allowed, false if rate limit exceeded)"
            },
            {
              "name": "recordRequest",
              "desc": "Records the timestamp of a request to track usage against rate limits",
              "inputs": "provider (openai|claude)",
              "outputs": "void"
            }
          ],
          "dependencies": [],
          "intent": "Prevents the application from exceeding LLM provider API rate limits by tracking request timestamps and enforcing configurable request quotas per time window, ensuring reliable API access and avoiding service interruptions or penalties",
          "rawContent": "```json\n{\n  \"purpose\": \"Manages API rate limiting for LLM providers (OpenAI and Claude) to prevent exceeding their request quotas\",\n  \"userVisibleActions\": [\n    \"API requests are automatically throttled to stay within provider limits\",\n    \"Requests may be delayed or rejected if rate limits are exceeded\",\n    \"Different LLM providers (OpenAI, Claude) have different rate limit allowances\"\n  ],\n  \"developerVisibleActions\": [\n    \"Configure custom rate limits for each LLM provider (max requests per time window)\",\n    \"Check if a request can be made before calling the LLM API\",\n    \"Record requests to track usage against rate limits\",\n    \"OpenAI defaults to 60 requests per minute, Claude defaults to 50 requests per minute\",\n    \"Rate limits are enforced using a sliding time window approach\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes rate limiter with default limits for OpenAI (60 req/min) and Claude (50 req/min)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"RateLimiter instance\"\n    },\n    {\n      \"name\": \"configure\",\n      \"desc\": \"Sets custom rate limit configuration for a specific LLM provider\",\n      \"inputs\": \"provider (openai|claude), config (maxRequests, windowMs)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"canMakeRequest\",\n      \"desc\": \"Checks if a request can be made without exceeding the rate limit for the provider\",\n      \"inputs\": \"provider (openai|claude)\",\n      \"outputs\": \"boolean (true if request allowed, false if rate limit exceeded)\"\n    },\n    {\n      \"name\": \"recordRequest\",\n      \"desc\": \"Records the timestamp of a request to track usage against rate limits\",\n      \"inputs\": \"provider (openai|claude)\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"Prevents the application from exceeding LLM provider API rate limits by tracking request timestamps and enforcing configurable request quotas per time window, ensuring reliable API access and avoiding service interruptions or penalties\"\n}\n```"
        },
        {
          "file": "src/ai/llmResponseParser.ts",
          "role": "Core Logic",
          "purpose": "Parses and extracts structured data from LLM text responses into standardized formats for file summaries, module summaries, and product documentation.",
          "userVisibleActions": [
            "When AI analysis completes, user receives structured documentation with clear sections for purpose, actions, and dependencies",
            "User sees organized file and module summaries with extracted key information",
            "User receives product documentation with categorized features and use cases",
            "When AI responses are malformed, user still gets partial data with fallback text extraction"
          ],
          "developerVisibleActions": [
            "Developer calls parser methods with raw LLM response text and receives typed objects (FileSummary, ModuleSummary, EnhancedProductDocumentation)",
            "Developer provides file paths and role information to get parsed file summaries",
            "Developer passes module paths to get consolidated module analysis",
            "Developer triggers product documentation parsing to extract features, use cases, and target users",
            "Parser attempts JSON parsing first, then falls back to text extraction if JSON parsing fails",
            "Developer receives LLMInsights objects with parsed purpose, capabilities, and context",
            "Parser handles extraction of list sections, nested structures, and specific data fields from unstructured text"
          ],
          "keyFunctions": [
            {
              "name": "parseFileSummary",
              "desc": "Extracts file-level documentation from LLM response",
              "inputs": "content (string), filePath (string), role (string)",
              "outputs": "FileSummary object with purpose, actions, functions, and dependencies"
            },
            {
              "name": "parseModuleSummary",
              "desc": "Extracts module-level documentation from LLM response",
              "inputs": "content (string), modulePath (string)",
              "outputs": "ModuleSummary object with organized module information"
            },
            {
              "name": "parseEnhancedProductDocumentation",
              "desc": "Extracts comprehensive product documentation from LLM response",
              "inputs": "content (string)",
              "outputs": "EnhancedProductDocumentation object with features, use cases, and target users"
            },
            {
              "name": "parseInsights",
              "desc": "Extracts general insights and analysis from LLM response",
              "inputs": "content (string)",
              "outputs": "LLMInsights object with purpose, capabilities, and context"
            },
            {
              "name": "extractSection",
              "desc": "Extracts a specific named section from text content",
              "inputs": "content (string), sectionName (string)",
              "outputs": "Extracted text string or empty string"
            },
            {
              "name": "extractListSection",
              "desc": "Extracts a list of items from a named section",
              "inputs": "content (string), sectionName (string)",
              "outputs": "Array of strings extracted from the section"
            }
          ],
          "dependencies": [
            "../fileDocumentation (FileSummary, ModuleSummary, EnhancedProductDocumentation)",
            "../llmService (LLMInsights, ProductPurposeAnalysis, AnalysisContext)"
          ],
          "intent": "Solves the problem of converting unstructured LLM text responses into consistent, typed data structures that can be programmatically used throughout the application. Acts as the bridge between raw AI output and structured documentation objects, handling both JSON and freeform text responses with fallback strategies.",
          "rawContent": "```json\n{\n  \"purpose\": \"Parses and extracts structured data from LLM text responses into standardized formats for file summaries, module summaries, and product documentation.\",\n  \"userVisibleActions\": [\n    \"When AI analysis completes, user receives structured documentation with clear sections for purpose, actions, and dependencies\",\n    \"User sees organized file and module summaries with extracted key information\",\n    \"User receives product documentation with categorized features and use cases\",\n    \"When AI responses are malformed, user still gets partial data with fallback text extraction\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer calls parser methods with raw LLM response text and receives typed objects (FileSummary, ModuleSummary, EnhancedProductDocumentation)\",\n    \"Developer provides file paths and role information to get parsed file summaries\",\n    \"Developer passes module paths to get consolidated module analysis\",\n    \"Developer triggers product documentation parsing to extract features, use cases, and target users\",\n    \"Parser attempts JSON parsing first, then falls back to text extraction if JSON parsing fails\",\n    \"Developer receives LLMInsights objects with parsed purpose, capabilities, and context\",\n    \"Parser handles extraction of list sections, nested structures, and specific data fields from unstructured text\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"parseFileSummary\",\n      \"desc\": \"Extracts file-level documentation from LLM response\",\n      \"inputs\": \"content (string), filePath (string), role (string)\",\n      \"outputs\": \"FileSummary object with purpose, actions, functions, and dependencies\"\n    },\n    {\n      \"name\": \"parseModuleSummary\",\n      \"desc\": \"Extracts module-level documentation from LLM response\",\n      \"inputs\": \"content (string), modulePath (string)\",\n      \"outputs\": \"ModuleSummary object with organized module information\"\n    },\n    {\n      \"name\": \"parseEnhancedProductDocumentation\",\n      \"desc\": \"Extracts comprehensive product documentation from LLM response\",\n      \"inputs\": \"content (string)\",\n      \"outputs\": \"EnhancedProductDocumentation object with features, use cases, and target users\"\n    },\n    {\n      \"name\": \"parseInsights\",\n      \"desc\": \"Extracts general insights and analysis from LLM response\",\n      \"inputs\": \"content (string)\",\n      \"outputs\": \"LLMInsights object with purpose, capabilities, and context\"\n    },\n    {\n      \"name\": \"extractSection\",\n      \"desc\": \"Extracts a specific named section from text content\",\n      \"inputs\": \"content (string), sectionName (string)\",\n      \"outputs\": \"Extracted text string or empty string\"\n    },\n    {\n      \"name\": \"extractListSection\",\n      \"desc\": \"Extracts a list of items from a named section\",\n      \"inputs\": \"content (string), sectionName (string)\",\n      \"outputs\": \"Array of strings extracted from the section\"\n    }\n  ],\n  \"dependencies\": [\n    \"../fileDocumentation (FileSummary, ModuleSummary, EnhancedProductDocumentation)\",\n    \"../llmService (LLMInsights, ProductPurposeAnalysis, AnalysisContext)\"\n  ],\n  \"intent\": \"Solves the problem of converting unstructured LLM text responses into consistent, typed data structures that can be programmatically used throughout the application. Acts as the bridge between raw AI output and structured documentation objects, handling both JSON and freeform text responses with fallback strategies.\"\n}\n```"
        },
        {
          "file": "src/ai/llmRetryHandler.ts",
          "role": "Core Logic",
          "purpose": "Handles automatic retry logic for LLM API requests with exponential backoff when errors occur",
          "userVisibleActions": [
            "API requests automatically retry when temporary failures occur (rate limits, timeouts, network issues)",
            "Longer wait times occur between successive retry attempts",
            "Failed requests eventually succeed or show error after maximum retries exhausted"
          ],
          "developerVisibleActions": [
            "Wrap API calls with retry handler to get automatic retry behavior",
            "Configure retry behavior (max attempts, delays, which errors trigger retries)",
            "Receive callbacks when retries occur to track attempt progress",
            "Get final result with number of attempts made",
            "Non-retryable errors immediately throw without retry attempts"
          ],
          "keyFunctions": [
            {
              "name": "executeWithRetry",
              "desc": "Executes an async operation with automatic retry logic and exponential backoff",
              "inputs": "operation function to execute, optional retry configuration (maxRetries, delays, error types)",
              "outputs": "Promise resolving to operation result with attempt count"
            },
            {
              "name": "isRetryableError",
              "desc": "Determines if an error should trigger a retry based on error type classification",
              "inputs": "error object, list of retryable error patterns",
              "outputs": "boolean indicating if error is retryable"
            }
          ],
          "dependencies": [],
          "intent": "Provides resilient LLM API communication by automatically handling transient failures like rate limits, timeouts, and network issues without requiring manual retry logic in calling code",
          "rawContent": "```json\n{\n  \"purpose\": \"Handles automatic retry logic for LLM API requests with exponential backoff when errors occur\",\n  \"userVisibleActions\": [\n    \"API requests automatically retry when temporary failures occur (rate limits, timeouts, network issues)\",\n    \"Longer wait times occur between successive retry attempts\",\n    \"Failed requests eventually succeed or show error after maximum retries exhausted\"\n  ],\n  \"developerVisibleActions\": [\n    \"Wrap API calls with retry handler to get automatic retry behavior\",\n    \"Configure retry behavior (max attempts, delays, which errors trigger retries)\",\n    \"Receive callbacks when retries occur to track attempt progress\",\n    \"Get final result with number of attempts made\",\n    \"Non-retryable errors immediately throw without retry attempts\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"executeWithRetry\",\n      \"desc\": \"Executes an async operation with automatic retry logic and exponential backoff\",\n      \"inputs\": \"operation function to execute, optional retry configuration (maxRetries, delays, error types)\",\n      \"outputs\": \"Promise resolving to operation result with attempt count\"\n    },\n    {\n      \"name\": \"isRetryableError\",\n      \"desc\": \"Determines if an error should trigger a retry based on error type classification\",\n      \"inputs\": \"error object, list of retryable error patterns\",\n      \"outputs\": \"boolean indicating if error is retryable\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"Provides resilient LLM API communication by automatically handling transient failures like rate limits, timeouts, and network issues without requiring manual retry logic in calling code\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/ai/providers",
      "moduleType": "other",
      "capabilities": [
        "Switch between multiple AI language model providers (OpenAI GPT and Anthropic Claude) based on user configuration",
        "Generate AI-powered text responses to user prompts through a unified interface",
        "Produce structured JSON outputs from AI models based on defined schemas",
        "Automatically select and use available AI providers based on API key configuration",
        "Maintain consistent AI behavior and response handling across different provider backends",
        "Control AI response characteristics through configurable parameters like temperature and token limits"
      ],
      "summary": "This module provides a flexible AI provider abstraction layer that enables users to interact with multiple language model services through a single, consistent interface. Users can seamlessly work with either OpenAI's GPT models or Anthropic's Claude models without changing how they interact with the application, with the system automatically selecting the configured provider.\n\nThe module handles all aspects of AI communication including sending prompts, receiving text responses, and generating structured JSON outputs based on schemas. Users benefit from provider flexibility—if one service is unavailable or preferred over another, the application can switch providers without disrupting the user experience. The factory pattern implementation ensures that only properly configured providers (those with valid API keys) are made available, preventing runtime errors.\n\nTypical workflows include: requesting AI-generated text content where prompts are sent to the configured provider and responses are returned, generating structured data where the AI produces JSON matching specific schemas, and managing provider configuration where users can choose their preferred AI service. The module abstracts away provider-specific implementation details, ensuring users receive consistent, high-quality AI responses regardless of the underlying service being used.",
      "files": [
        {
          "file": "src/ai/providers/ILLMProvider.ts",
          "role": "Core Logic",
          "purpose": "Defines the standard interface that all AI language model providers (like OpenAI, Claude, etc.) must implement for consistent interaction throughout the application.",
          "userVisibleActions": [
            "User receives AI-generated text responses to their queries",
            "User receives structured JSON data from AI requests when specific formats are needed",
            "User experiences consistent AI behavior regardless of which provider (OpenAI, Claude, etc.) is configured",
            "User sees AI responses that respect configured parameters like temperature and token limits"
          ],
          "developerVisibleActions": [
            "Developer implements this interface to add support for new AI providers",
            "Developer calls sendRequest() to get text responses from any configured AI provider",
            "Developer calls sendStructuredRequest() to get parsed JSON responses with optional schemas",
            "Developer checks isConfigured() to verify provider is ready before making requests",
            "Developer uses standardized message format with role and content for all providers",
            "Developer configures AI behavior using maxTokens, temperature, and responseFormat options",
            "Developer receives additional context like finish reasons and raw responses for debugging"
          ],
          "keyFunctions": [
            {
              "name": "isConfigured",
              "desc": "Verifies if the AI provider has valid credentials and is ready to accept requests",
              "inputs": "none",
              "outputs": "boolean indicating if provider is configured"
            },
            {
              "name": "sendRequest",
              "desc": "Sends a conversation to the AI provider and retrieves a text response",
              "inputs": "LLMRequestOptions containing model, messages, system prompt, and generation parameters",
              "outputs": "Promise<LLMResponse> with content string and metadata"
            },
            {
              "name": "sendStructuredRequest",
              "desc": "Sends a request expecting structured JSON output, with optional schema validation",
              "inputs": "LLMRequestOptions and optional schema definition",
              "outputs": "Promise<StructuredOutputResponse<T>> with parsed typed data and optional follow-up requests"
            },
            {
              "name": "getName",
              "desc": "Returns the human-readable name of the provider for identification",
              "inputs": "none",
              "outputs": "string with provider name"
            }
          ],
          "dependencies": [],
          "intent": "This file exists to create a unified abstraction layer over different AI providers (OpenAI, Claude, custom implementations), allowing the rest of the application to work with any AI provider through a consistent interface without needing to know provider-specific details. It solves the problem of vendor lock-in and makes the codebase provider-agnostic, enabling easy switching or addition of new AI providers.",
          "rawContent": "```json\n{\n  \"purpose\": \"Defines the standard interface that all AI language model providers (like OpenAI, Claude, etc.) must implement for consistent interaction throughout the application.\",\n  \"userVisibleActions\": [\n    \"User receives AI-generated text responses to their queries\",\n    \"User receives structured JSON data from AI requests when specific formats are needed\",\n    \"User experiences consistent AI behavior regardless of which provider (OpenAI, Claude, etc.) is configured\",\n    \"User sees AI responses that respect configured parameters like temperature and token limits\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer implements this interface to add support for new AI providers\",\n    \"Developer calls sendRequest() to get text responses from any configured AI provider\",\n    \"Developer calls sendStructuredRequest() to get parsed JSON responses with optional schemas\",\n    \"Developer checks isConfigured() to verify provider is ready before making requests\",\n    \"Developer uses standardized message format with role and content for all providers\",\n    \"Developer configures AI behavior using maxTokens, temperature, and responseFormat options\",\n    \"Developer receives additional context like finish reasons and raw responses for debugging\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"isConfigured\",\n      \"desc\": \"Verifies if the AI provider has valid credentials and is ready to accept requests\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean indicating if provider is configured\"\n    },\n    {\n      \"name\": \"sendRequest\",\n      \"desc\": \"Sends a conversation to the AI provider and retrieves a text response\",\n      \"inputs\": \"LLMRequestOptions containing model, messages, system prompt, and generation parameters\",\n      \"outputs\": \"Promise<LLMResponse> with content string and metadata\"\n    },\n    {\n      \"name\": \"sendStructuredRequest\",\n      \"desc\": \"Sends a request expecting structured JSON output, with optional schema validation\",\n      \"inputs\": \"LLMRequestOptions and optional schema definition\",\n      \"outputs\": \"Promise<StructuredOutputResponse<T>> with parsed typed data and optional follow-up requests\"\n    },\n    {\n      \"name\": \"getName\",\n      \"desc\": \"Returns the human-readable name of the provider for identification\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string with provider name\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"This file exists to create a unified abstraction layer over different AI providers (OpenAI, Claude, custom implementations), allowing the rest of the application to work with any AI provider through a consistent interface without needing to know provider-specific details. It solves the problem of vendor lock-in and makes the codebase provider-agnostic, enabling easy switching or addition of new AI providers.\"\n}\n```"
        },
        {
          "file": "src/ai/providers/anthropicProvider.ts",
          "role": "Core Logic",
          "purpose": "Integrates Anthropic's Claude AI models as an LLM provider for generating AI responses and structured outputs in the application",
          "userVisibleActions": [
            "Sends prompts to Claude AI and receives text responses",
            "Generates structured JSON outputs from Claude based on schemas",
            "Receives error messages when Claude API is not configured",
            "Experiences AI-powered features using Claude's language models"
          ],
          "developerVisibleActions": [
            "Configure Claude API key through configuration manager to enable the provider",
            "Send requests with custom models, system prompts, and message histories",
            "Request structured JSON outputs with schema validation",
            "Handle Claude-specific message format conversions automatically",
            "Set custom token limits (default 8192 for Claude Sonnet)",
            "Receive extracted JSON from Claude's text responses",
            "Check if provider is configured before use"
          ],
          "keyFunctions": [
            {
              "name": "initialize",
              "desc": "Sets up the Claude API client with API key from configuration",
              "inputs": "None (reads from config manager)",
              "outputs": "void (sets up internal client)"
            },
            {
              "name": "isConfigured",
              "desc": "Checks if Claude provider is ready to use",
              "inputs": "None",
              "outputs": "boolean indicating if API key is configured"
            },
            {
              "name": "getName",
              "desc": "Returns the provider identifier",
              "inputs": "None",
              "outputs": "'claude' string"
            },
            {
              "name": "sendRequest",
              "desc": "Sends a prompt to Claude and returns the AI response",
              "inputs": "LLMRequestOptions (messages, model, systemPrompt, maxTokens)",
              "outputs": "LLMResponse with content and token usage"
            },
            {
              "name": "sendStructuredOutputRequest",
              "desc": "Requests a JSON response from Claude conforming to a schema",
              "inputs": "LLMRequestOptions with schema definition",
              "outputs": "StructuredOutputResponse with extracted JSON data"
            }
          ],
          "dependencies": [
            "@anthropic-ai/sdk",
            "../../config/configurationManager",
            "../../utils/jsonExtractor",
            "./ILLMProvider"
          ],
          "intent": "Provides a unified interface to Anthropic's Claude AI models, handling API authentication, message format conversion, and response parsing so the application can seamlessly integrate Claude as one of multiple LLM providers without knowing Claude-specific implementation details",
          "rawContent": "```json\n{\n  \"purpose\": \"Integrates Anthropic's Claude AI models as an LLM provider for generating AI responses and structured outputs in the application\",\n  \"userVisibleActions\": [\n    \"Sends prompts to Claude AI and receives text responses\",\n    \"Generates structured JSON outputs from Claude based on schemas\",\n    \"Receives error messages when Claude API is not configured\",\n    \"Experiences AI-powered features using Claude's language models\"\n  ],\n  \"developerVisibleActions\": [\n    \"Configure Claude API key through configuration manager to enable the provider\",\n    \"Send requests with custom models, system prompts, and message histories\",\n    \"Request structured JSON outputs with schema validation\",\n    \"Handle Claude-specific message format conversions automatically\",\n    \"Set custom token limits (default 8192 for Claude Sonnet)\",\n    \"Receive extracted JSON from Claude's text responses\",\n    \"Check if provider is configured before use\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initialize\",\n      \"desc\": \"Sets up the Claude API client with API key from configuration\",\n      \"inputs\": \"None (reads from config manager)\",\n      \"outputs\": \"void (sets up internal client)\"\n    },\n    {\n      \"name\": \"isConfigured\",\n      \"desc\": \"Checks if Claude provider is ready to use\",\n      \"inputs\": \"None\",\n      \"outputs\": \"boolean indicating if API key is configured\"\n    },\n    {\n      \"name\": \"getName\",\n      \"desc\": \"Returns the provider identifier\",\n      \"inputs\": \"None\",\n      \"outputs\": \"'claude' string\"\n    },\n    {\n      \"name\": \"sendRequest\",\n      \"desc\": \"Sends a prompt to Claude and returns the AI response\",\n      \"inputs\": \"LLMRequestOptions (messages, model, systemPrompt, maxTokens)\",\n      \"outputs\": \"LLMResponse with content and token usage\"\n    },\n    {\n      \"name\": \"sendStructuredOutputRequest\",\n      \"desc\": \"Requests a JSON response from Claude conforming to a schema\",\n      \"inputs\": \"LLMRequestOptions with schema definition\",\n      \"outputs\": \"StructuredOutputResponse with extracted JSON data\"\n    }\n  ],\n  \"dependencies\": [\n    \"@anthropic-ai/sdk\",\n    \"../../config/configurationManager\",\n    \"../../utils/jsonExtractor\",\n    \"./ILLMProvider\"\n  ],\n  \"intent\": \"Provides a unified interface to Anthropic's Claude AI models, handling API authentication, message format conversion, and response parsing so the application can seamlessly integrate Claude as one of multiple LLM providers without knowing Claude-specific implementation details\"\n}\n```"
        },
        {
          "file": "src/ai/providers/openAIProvider.ts",
          "role": "Core Logic",
          "purpose": "Implements OpenAI API integration to send chat requests and receive responses from GPT models",
          "userVisibleActions": [
            "Enables AI-powered chat interactions using OpenAI's GPT models",
            "Provides structured JSON responses from AI when requested",
            "Returns AI-generated text content based on user prompts",
            "Shows error when OpenAI API key is not configured"
          ],
          "developerVisibleActions": [
            "Configure OpenAI API key through configuration manager",
            "Send chat messages with optional system prompts to OpenAI",
            "Request structured JSON outputs from the AI model",
            "Check if OpenAI provider is properly configured before use",
            "Handle token usage and cost tracking from API responses",
            "Set custom models (defaults to gpt-4o)",
            "Automatically extract JSON from AI responses"
          ],
          "keyFunctions": [
            {
              "name": "initialize",
              "desc": "Sets up OpenAI client with API key from configuration",
              "inputs": "None (reads from config)",
              "outputs": "Initializes client or sets to null if no key"
            },
            {
              "name": "isConfigured",
              "desc": "Checks if the OpenAI provider is ready to use",
              "inputs": "None",
              "outputs": "Boolean indicating if API key is set"
            },
            {
              "name": "getName",
              "desc": "Returns the provider identifier",
              "inputs": "None",
              "outputs": "String 'openai'"
            },
            {
              "name": "sendRequest",
              "desc": "Sends a chat completion request to OpenAI and returns the response",
              "inputs": "LLMRequestOptions (model, messages, systemPrompt, responseFormat)",
              "outputs": "LLMResponse with content, finish reason, and token usage"
            },
            {
              "name": "requestStructuredOutput",
              "desc": "Requests AI response in JSON format and parses it",
              "inputs": "LLMRequestOptions with JSON schema",
              "outputs": "StructuredOutputResponse with parsed JSON object or null"
            }
          ],
          "dependencies": [
            "openai",
            "../../config/configurationManager",
            "../../utils/jsonExtractor",
            "./ILLMProvider"
          ],
          "intent": "This file exists to provide a concrete implementation of the LLM provider interface specifically for OpenAI's API, enabling the application to communicate with GPT models for AI-powered features. It solves the problem of abstracting OpenAI-specific API calls behind a common interface while handling configuration, error cases, and response parsing including structured JSON outputs.",
          "rawContent": "```json\n{\n  \"purpose\": \"Implements OpenAI API integration to send chat requests and receive responses from GPT models\",\n  \"userVisibleActions\": [\n    \"Enables AI-powered chat interactions using OpenAI's GPT models\",\n    \"Provides structured JSON responses from AI when requested\",\n    \"Returns AI-generated text content based on user prompts\",\n    \"Shows error when OpenAI API key is not configured\"\n  ],\n  \"developerVisibleActions\": [\n    \"Configure OpenAI API key through configuration manager\",\n    \"Send chat messages with optional system prompts to OpenAI\",\n    \"Request structured JSON outputs from the AI model\",\n    \"Check if OpenAI provider is properly configured before use\",\n    \"Handle token usage and cost tracking from API responses\",\n    \"Set custom models (defaults to gpt-4o)\",\n    \"Automatically extract JSON from AI responses\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initialize\",\n      \"desc\": \"Sets up OpenAI client with API key from configuration\",\n      \"inputs\": \"None (reads from config)\",\n      \"outputs\": \"Initializes client or sets to null if no key\"\n    },\n    {\n      \"name\": \"isConfigured\",\n      \"desc\": \"Checks if the OpenAI provider is ready to use\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Boolean indicating if API key is set\"\n    },\n    {\n      \"name\": \"getName\",\n      \"desc\": \"Returns the provider identifier\",\n      \"inputs\": \"None\",\n      \"outputs\": \"String 'openai'\"\n    },\n    {\n      \"name\": \"sendRequest\",\n      \"desc\": \"Sends a chat completion request to OpenAI and returns the response\",\n      \"inputs\": \"LLMRequestOptions (model, messages, systemPrompt, responseFormat)\",\n      \"outputs\": \"LLMResponse with content, finish reason, and token usage\"\n    },\n    {\n      \"name\": \"requestStructuredOutput\",\n      \"desc\": \"Requests AI response in JSON format and parses it\",\n      \"inputs\": \"LLMRequestOptions with JSON schema\",\n      \"outputs\": \"StructuredOutputResponse with parsed JSON object or null\"\n    }\n  ],\n  \"dependencies\": [\n    \"openai\",\n    \"../../config/configurationManager\",\n    \"../../utils/jsonExtractor\",\n    \"./ILLMProvider\"\n  ],\n  \"intent\": \"This file exists to provide a concrete implementation of the LLM provider interface specifically for OpenAI's API, enabling the application to communicate with GPT models for AI-powered features. It solves the problem of abstracting OpenAI-specific API calls behind a common interface while handling configuration, error cases, and response parsing including structured JSON outputs.\"\n}\n```"
        },
        {
          "file": "src/ai/providers/providerFactory.ts",
          "role": "Core Logic",
          "purpose": "Creates and manages AI provider instances (OpenAI and Claude) based on configuration settings",
          "userVisibleActions": [
            "Switches between different AI providers (OpenAI or Claude) based on user configuration",
            "Automatically uses the AI provider that is properly configured with API keys",
            "Provides list of available AI providers that have been configured"
          ],
          "developerVisibleActions": [
            "Provides a single factory to get any AI provider instance without manual instantiation",
            "Manages provider lifecycle by reusing existing instances instead of creating duplicates",
            "Reads from configuration manager to determine which AI provider to use",
            "Validates if a provider has required API keys and configuration before use",
            "Throws error when requesting an unknown or unsupported provider type"
          ],
          "keyFunctions": [
            {
              "name": "getProvider",
              "desc": "Returns an instance of the specified AI provider (OpenAI or Claude)",
              "inputs": "provider: 'openai' | 'claude'",
              "outputs": "ILLMProvider instance"
            },
            {
              "name": "getCurrentProvider",
              "desc": "Returns the AI provider instance based on current user configuration",
              "inputs": "none",
              "outputs": "ILLMProvider instance for the configured provider"
            },
            {
              "name": "isProviderConfigured",
              "desc": "Checks if a specific AI provider has valid configuration and API keys",
              "inputs": "provider: 'openai' | 'claude'",
              "outputs": "boolean indicating if provider is ready to use"
            },
            {
              "name": "getConfiguredProviders",
              "desc": "Returns list of all AI providers that are properly configured",
              "inputs": "none",
              "outputs": "Array of configured provider names"
            }
          ],
          "dependencies": [
            "./ILLMProvider",
            "./openAIProvider",
            "./anthropicProvider",
            "../../config/configurationManager"
          ],
          "intent": "This file exists to centralize AI provider creation and management, ensuring only one instance of each provider exists, automatically selecting the correct provider based on user settings, and validating provider configuration before use. It solves the problem of scattered provider instantiation and simplifies switching between different AI services.",
          "rawContent": "```json\n{\n  \"purpose\": \"Creates and manages AI provider instances (OpenAI and Claude) based on configuration settings\",\n  \"userVisibleActions\": [\n    \"Switches between different AI providers (OpenAI or Claude) based on user configuration\",\n    \"Automatically uses the AI provider that is properly configured with API keys\",\n    \"Provides list of available AI providers that have been configured\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provides a single factory to get any AI provider instance without manual instantiation\",\n    \"Manages provider lifecycle by reusing existing instances instead of creating duplicates\",\n    \"Reads from configuration manager to determine which AI provider to use\",\n    \"Validates if a provider has required API keys and configuration before use\",\n    \"Throws error when requesting an unknown or unsupported provider type\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getProvider\",\n      \"desc\": \"Returns an instance of the specified AI provider (OpenAI or Claude)\",\n      \"inputs\": \"provider: 'openai' | 'claude'\",\n      \"outputs\": \"ILLMProvider instance\"\n    },\n    {\n      \"name\": \"getCurrentProvider\",\n      \"desc\": \"Returns the AI provider instance based on current user configuration\",\n      \"inputs\": \"none\",\n      \"outputs\": \"ILLMProvider instance for the configured provider\"\n    },\n    {\n      \"name\": \"isProviderConfigured\",\n      \"desc\": \"Checks if a specific AI provider has valid configuration and API keys\",\n      \"inputs\": \"provider: 'openai' | 'claude'\",\n      \"outputs\": \"boolean indicating if provider is ready to use\"\n    },\n    {\n      \"name\": \"getConfiguredProviders\",\n      \"desc\": \"Returns list of all AI providers that are properly configured\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of configured provider names\"\n    }\n  ],\n  \"dependencies\": [\n    \"./ILLMProvider\",\n    \"./openAIProvider\",\n    \"./anthropicProvider\",\n    \"../../config/configurationManager\"\n  ],\n  \"intent\": \"This file exists to centralize AI provider creation and management, ensuring only one instance of each provider exists, automatically selecting the correct provider based on user settings, and validating provider configuration before use. It solves the problem of scattered provider instantiation and simplifies switching between different AI services.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/analysis",
      "moduleType": "other",
      "capabilities": [
        "Deep code analysis through Abstract Syntax Tree (AST) parsing to understand code structure and behavior",
        "Function-level analysis to identify refactoring opportunities in large code files",
        "Branch complexity and decision point detection to assess code maintainability",
        "Dependency mapping between modules and functions to visualize code relationships",
        "State mutation and side effect identification to understand function behavior",
        "Test coverage mapping to functions for quality assessment",
        "Size threshold detection to flag functions that may need refactoring",
        "Extraction of function signatures, dependencies, and responsibilities for documentation"
      ],
      "summary": "The analysis module provides comprehensive code analysis capabilities for understanding and improving codebases. It performs deep inspection of code using AST parsing to extract detailed metadata about functions, including their complexity, dependencies, state changes, and behavioral characteristics. This enables developers to make informed decisions about code quality and refactoring needs.\n\nUsers can leverage this module to identify problematic code patterns, understand function relationships, and generate detailed refactoring reports for large files. The module analyzes branch complexity to highlight decision-heavy code, maps dependencies to show how components interact, and identifies state mutations that may introduce bugs. It also correlates test coverage with functions to reveal gaps in testing.\n\nThe primary workflow involves analyzing code files to extract function-level insights, then generating comprehensive reports that highlight refactoring opportunities. The module flags functions exceeding size thresholds, provides detailed signatures and responsibilities, and shows call relationships between functions. This systematic analysis helps teams maintain code quality and plan refactoring efforts effectively.",
      "files": [
        {
          "file": "src/analysis/enhancedAnalyzer.ts",
          "role": "Core Logic",
          "purpose": "Performs deep code analysis by parsing Abstract Syntax Trees (AST) to extract detailed function metadata including branches, dependencies, state mutations, and behavioral hints.",
          "userVisibleActions": [
            "Provides detailed insights about code behavior and function characteristics",
            "Shows branch complexity and decision points in code",
            "Reveals dependencies between code modules and functions",
            "Identifies state mutations and side effects in functions",
            "Maps test coverage to functions"
          ],
          "developerVisibleActions": [
            "Analyzes TypeScript/JavaScript files using AST parsing to extract function metadata",
            "Extracts branch information (if/else, switch, loops) from function bodies",
            "Profiles dependencies between functions and external modules",
            "Detects state mutations and tracks which variables/objects are modified",
            "Generates behavioral hints about function purpose and side effects",
            "Maps test files to source code functions",
            "Provides fallback regex-based analysis for non-TypeScript languages",
            "Returns structured metadata including complexity metrics and code patterns"
          ],
          "keyFunctions": [
            {
              "name": "analyzeFileMetadata",
              "desc": "Analyzes a single code file and extracts enhanced metadata for all functions in it",
              "inputs": "filePath: string, content: string, language: string, functions: FunctionInfo[]",
              "outputs": "Map<string, FunctionMetadata> containing detailed function analysis"
            },
            {
              "name": "analyzeTypeScriptFunction",
              "desc": "Uses TypeScript AST parser to deeply analyze a function's structure, branches, dependencies, and behavior",
              "inputs": "filePath: string, content: string, func: FunctionInfo, functionContent: string",
              "outputs": "FunctionMetadata with AST-derived insights"
            },
            {
              "name": "analyzeFunctionWithRegex",
              "desc": "Provides basic function analysis using pattern matching for languages without AST support",
              "inputs": "filePath: string, func: FunctionInfo, functionContent: string, language: string",
              "outputs": "FunctionMetadata with regex-based analysis"
            },
            {
              "name": "extractFunctionContent",
              "desc": "Extracts the source code content of a function between specified line numbers",
              "inputs": "content: string, startLine: number, endLine: number",
              "outputs": "string containing the function's source code"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "typescript",
            "../analyzer"
          ],
          "intent": "This file exists to provide advanced code analysis capabilities beyond basic syntax parsing. It solves the problem of understanding code behavior, complexity, and relationships by parsing the AST structure, enabling features like intelligent test generation, code documentation, and dependency mapping. It bridges the gap between simple text analysis and deep semantic understanding of code.",
          "rawContent": "```json\n{\n  \"purpose\": \"Performs deep code analysis by parsing Abstract Syntax Trees (AST) to extract detailed function metadata including branches, dependencies, state mutations, and behavioral hints.\",\n  \"userVisibleActions\": [\n    \"Provides detailed insights about code behavior and function characteristics\",\n    \"Shows branch complexity and decision points in code\",\n    \"Reveals dependencies between code modules and functions\",\n    \"Identifies state mutations and side effects in functions\",\n    \"Maps test coverage to functions\"\n  ],\n  \"developerVisibleActions\": [\n    \"Analyzes TypeScript/JavaScript files using AST parsing to extract function metadata\",\n    \"Extracts branch information (if/else, switch, loops) from function bodies\",\n    \"Profiles dependencies between functions and external modules\",\n    \"Detects state mutations and tracks which variables/objects are modified\",\n    \"Generates behavioral hints about function purpose and side effects\",\n    \"Maps test files to source code functions\",\n    \"Provides fallback regex-based analysis for non-TypeScript languages\",\n    \"Returns structured metadata including complexity metrics and code patterns\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeFileMetadata\",\n      \"desc\": \"Analyzes a single code file and extracts enhanced metadata for all functions in it\",\n      \"inputs\": \"filePath: string, content: string, language: string, functions: FunctionInfo[]\",\n      \"outputs\": \"Map<string, FunctionMetadata> containing detailed function analysis\"\n    },\n    {\n      \"name\": \"analyzeTypeScriptFunction\",\n      \"desc\": \"Uses TypeScript AST parser to deeply analyze a function's structure, branches, dependencies, and behavior\",\n      \"inputs\": \"filePath: string, content: string, func: FunctionInfo, functionContent: string\",\n      \"outputs\": \"FunctionMetadata with AST-derived insights\"\n    },\n    {\n      \"name\": \"analyzeFunctionWithRegex\",\n      \"desc\": \"Provides basic function analysis using pattern matching for languages without AST support\",\n      \"inputs\": \"filePath: string, func: FunctionInfo, functionContent: string, language: string\",\n      \"outputs\": \"FunctionMetadata with regex-based analysis\"\n    },\n    {\n      \"name\": \"extractFunctionContent\",\n      \"desc\": \"Extracts the source code content of a function between specified line numbers\",\n      \"inputs\": \"content: string, startLine: number, endLine: number\",\n      \"outputs\": \"string containing the function's source code\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"typescript\",\n    \"../analyzer\"\n  ],\n  \"intent\": \"This file exists to provide advanced code analysis capabilities beyond basic syntax parsing. It solves the problem of understanding code behavior, complexity, and relationships by parsing the AST structure, enabling features like intelligent test generation, code documentation, and dependency mapping. It bridges the gap between simple text analysis and deep semantic understanding of code.\"\n}\n```"
        },
        {
          "file": "src/analysis/functionAnalyzer.ts",
          "role": "Core Logic",
          "purpose": "Analyzes functions in large code files to extract detailed information for generating refactoring reports",
          "userVisibleActions": [
            "Generates detailed analysis reports for functions in large files",
            "Identifies functions that exceed size thresholds and may need refactoring",
            "Provides function signatures, dependencies, and responsibilities in refactoring reports",
            "Shows which functions call or are called by other functions"
          ],
          "developerVisibleActions": [
            "Analyzes all functions in files exceeding a specified line threshold (default 500 lines)",
            "Extracts function metadata including signatures, parameters, return types",
            "Identifies function dependencies (what the function calls)",
            "Identifies function dependents (what calls this function)",
            "Determines function responsibilities by analyzing code behavior",
            "Resolves file paths from the code analysis results",
            "Handles analysis errors gracefully with warnings",
            "Returns structured FunctionAnalysis objects for report generation"
          ],
          "keyFunctions": [
            {
              "name": "analyzeFunctions",
              "desc": "Analyzes all functions in large files and extracts detailed information for refactoring",
              "inputs": "codeAnalysis (full code analysis results), largeFileThreshold (line count threshold, default 500)",
              "outputs": "Array of FunctionAnalysis objects containing detailed function information"
            },
            {
              "name": "analyzeFunction",
              "desc": "Performs detailed analysis of a single function including dependencies and responsibilities",
              "inputs": "filePath (file location), func (function info object), codeAnalysis (full analysis context)",
              "outputs": "FunctionAnalysis object with complete function details, or null if analysis fails"
            },
            {
              "name": "resolveFilePath",
              "desc": "Resolves relative or absolute file paths to full file system paths",
              "inputs": "filePath (path to resolve), codeAnalysis (context for resolution)",
              "outputs": "Full resolved file path"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "typescript",
            "../analyzer",
            "../domain/prompts/refactoringPromptBuilder"
          ],
          "intent": "This file exists to provide detailed function-level analysis for code refactoring recommendations. It extracts comprehensive information about functions in large files (signatures, dependencies, relationships) that can be used to generate intelligent refactoring suggestions and reports, helping developers identify functions that may benefit from restructuring or breaking into smaller components.",
          "rawContent": "```json\n{\n  \"purpose\": \"Analyzes functions in large code files to extract detailed information for generating refactoring reports\",\n  \"userVisibleActions\": [\n    \"Generates detailed analysis reports for functions in large files\",\n    \"Identifies functions that exceed size thresholds and may need refactoring\",\n    \"Provides function signatures, dependencies, and responsibilities in refactoring reports\",\n    \"Shows which functions call or are called by other functions\"\n  ],\n  \"developerVisibleActions\": [\n    \"Analyzes all functions in files exceeding a specified line threshold (default 500 lines)\",\n    \"Extracts function metadata including signatures, parameters, return types\",\n    \"Identifies function dependencies (what the function calls)\",\n    \"Identifies function dependents (what calls this function)\",\n    \"Determines function responsibilities by analyzing code behavior\",\n    \"Resolves file paths from the code analysis results\",\n    \"Handles analysis errors gracefully with warnings\",\n    \"Returns structured FunctionAnalysis objects for report generation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeFunctions\",\n      \"desc\": \"Analyzes all functions in large files and extracts detailed information for refactoring\",\n      \"inputs\": \"codeAnalysis (full code analysis results), largeFileThreshold (line count threshold, default 500)\",\n      \"outputs\": \"Array of FunctionAnalysis objects containing detailed function information\"\n    },\n    {\n      \"name\": \"analyzeFunction\",\n      \"desc\": \"Performs detailed analysis of a single function including dependencies and responsibilities\",\n      \"inputs\": \"filePath (file location), func (function info object), codeAnalysis (full analysis context)\",\n      \"outputs\": \"FunctionAnalysis object with complete function details, or null if analysis fails\"\n    },\n    {\n      \"name\": \"resolveFilePath\",\n      \"desc\": \"Resolves relative or absolute file paths to full file system paths\",\n      \"inputs\": \"filePath (path to resolve), codeAnalysis (context for resolution)\",\n      \"outputs\": \"Full resolved file path\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"typescript\",\n    \"../analyzer\",\n    \"../domain/prompts/refactoringPromptBuilder\"\n  ],\n  \"intent\": \"This file exists to provide detailed function-level analysis for code refactoring recommendations. It extracts comprehensive information about functions in large files (signatures, dependencies, relationships) that can be used to generate intelligent refactoring suggestions and reports, helping developers identify functions that may benefit from restructuring or breaking into smaller components.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src",
      "moduleType": "other",
      "capabilities": [
        "Automated code analysis and insights generation for TypeScript/JavaScript codebases",
        "AI-powered documentation generation using LLM integration (OpenAI/Claude)",
        "Real-time diagnostic reporting in VS Code's Problems panel",
        "Multiple specialized tree views for browsing code structure, insights, and reports",
        "Product-centric navigation organizing code by features instead of file structure",
        "Static analysis issue detection and reporting",
        "Code complexity and quality metrics tracking",
        "Duplicate code detection across files",
        "Test coverage gap identification",
        "Cached analysis results with automatic expiration",
        "File system monitoring with auto-analysis on save",
        "LLM-ready context generation for AI assistants"
      ],
      "summary": "Shadow Watch is a comprehensive VS Code extension that provides intelligent code analysis and documentation capabilities for TypeScript/JavaScript projects. It analyzes your codebase to identify code quality issues, architectural patterns, complexity metrics, and potential problems like orphaned files, circular dependencies, and untested functions. The extension integrates with AI services (OpenAI/Claude) to generate human-readable documentation, architectural insights, and refactoring suggestions based on the analysis results.\n\nThe extension provides multiple specialized views within VS Code's sidebar, including an Analysis Viewer showing statistics and code structure, an Insights Viewer displaying AI-generated architectural analysis, a Product Navigator organizing code by functionality rather than file structure, a Static Analysis Viewer for browsing issues by severity, and a Reports tree for accessing generated documentation. All findings are also surfaced through VS Code's native Problems panel with clickable diagnostics that navigate directly to problem locations.\n\nShadow Watch supports both manual and automatic analysis workflows. Users can trigger analysis on-demand through commands, or enable automatic analysis on file save for continuous feedback. Analysis results are cached for 24 hours to provide instant access when reopening workspaces. The extension also provides specialized features for LLM agents, including file reading capabilities and grep search functionality, enabling AI assistants to iteratively explore and understand codebases.",
      "files": [
        {
          "file": "src/analysisViewer.ts",
          "role": "GUI View",
          "purpose": "Provides a tree view panel that displays code analysis results including statistics, files, functions, and entry points in a browsable hierarchical structure",
          "userVisibleActions": [
            "View a tree structure showing code analysis results in the sidebar",
            "Browse statistics about the analyzed codebase (file count, line count, function count)",
            "Navigate through files and directories in the analysis",
            "See file details including line count, function count, import/export count, and complexity",
            "Browse all functions with their metadata (lines of code, complexity, parameters)",
            "View entry points (main functions, exported items, test files)",
            "Click on items to jump to their location in the source code",
            "See grouped views of files by directory structure",
            "See message 'No analysis available' when no analysis has been run yet",
            "Refresh the tree view to see updated analysis results"
          ],
          "developerVisibleActions": [
            "Set analysis data by calling setAnalysis() to populate the tree view",
            "Manually refresh the tree view by calling refresh()",
            "Receive click events when users select items in the tree",
            "Display hierarchical analysis data organized by categories (statistics, files, functions, entry points)",
            "Show tooltips with additional information on hover",
            "Handle navigation to specific file locations when items are clicked",
            "Display icons for different item types (files, functions, directories, statistics)",
            "Organize files by directory structure for easier navigation"
          ],
          "keyFunctions": [
            {
              "name": "setAnalysis",
              "desc": "Sets the code analysis data to display in the tree view and triggers a refresh",
              "inputs": "analysis: CodeAnalysis | null",
              "outputs": "void"
            },
            {
              "name": "refresh",
              "desc": "Refreshes the tree view to update displayed data",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "getTreeItem",
              "desc": "Returns the tree item representation for display in VS Code",
              "inputs": "element: AnalysisItem",
              "outputs": "vscode.TreeItem"
            },
            {
              "name": "getChildren",
              "desc": "Returns child items for a given tree node to build the hierarchy",
              "inputs": "element?: AnalysisItem",
              "outputs": "Thenable<AnalysisItem[]>"
            },
            {
              "name": "getRootItems",
              "desc": "Returns top-level categories shown in the tree (statistics, files, functions, entry points)",
              "inputs": "none",
              "outputs": "AnalysisItem[]"
            },
            {
              "name": "getStatisticsItems",
              "desc": "Returns statistical summary items (total files, lines, functions, etc.)",
              "inputs": "none",
              "outputs": "AnalysisItem[]"
            },
            {
              "name": "getFilesItems",
              "desc": "Returns all analyzed files organized by directory structure",
              "inputs": "none",
              "outputs": "AnalysisItem[]"
            },
            {
              "name": "getFileDetails",
              "desc": "Returns detailed information about a specific file (line count, functions, imports, exports)",
              "inputs": "element: AnalysisItem",
              "outputs": "AnalysisItem[]"
            },
            {
              "name": "getDirectoryFiles",
              "desc": "Returns all files within a specific directory",
              "inputs": "element: AnalysisItem",
              "outputs": "AnalysisItem[]"
            }
          ],
          "dependencies": [
            "vscode",
            "path",
            "./analyzer (CodeAnalysis, FileInfo, FunctionInfo, EntryPoint types)"
          ],
          "intent": "This file exists to provide developers with an interactive, browsable view of their codebase analysis results directly in VS Code's sidebar, making it easy to explore code metrics, navigate to specific functions or files, and understand the structure and complexity of their project at a glance",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view panel that displays code analysis results including statistics, files, functions, and entry points in a browsable hierarchical structure\",\n  \"userVisibleActions\": [\n    \"View a tree structure showing code analysis results in the sidebar\",\n    \"Browse statistics about the analyzed codebase (file count, line count, function count)\",\n    \"Navigate through files and directories in the analysis\",\n    \"See file details including line count, function count, import/export count, and complexity\",\n    \"Browse all functions with their metadata (lines of code, complexity, parameters)\",\n    \"View entry points (main functions, exported items, test files)\",\n    \"Click on items to jump to their location in the source code\",\n    \"See grouped views of files by directory structure\",\n    \"See message 'No analysis available' when no analysis has been run yet\",\n    \"Refresh the tree view to see updated analysis results\"\n  ],\n  \"developerVisibleActions\": [\n    \"Set analysis data by calling setAnalysis() to populate the tree view\",\n    \"Manually refresh the tree view by calling refresh()\",\n    \"Receive click events when users select items in the tree\",\n    \"Display hierarchical analysis data organized by categories (statistics, files, functions, entry points)\",\n    \"Show tooltips with additional information on hover\",\n    \"Handle navigation to specific file locations when items are clicked\",\n    \"Display icons for different item types (files, functions, directories, statistics)\",\n    \"Organize files by directory structure for easier navigation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setAnalysis\",\n      \"desc\": \"Sets the code analysis data to display in the tree view and triggers a refresh\",\n      \"inputs\": \"analysis: CodeAnalysis | null\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Refreshes the tree view to update displayed data\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the tree item representation for display in VS Code\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for a given tree node to build the hierarchy\",\n      \"inputs\": \"element?: AnalysisItem\",\n      \"outputs\": \"Thenable<AnalysisItem[]>\"\n    },\n    {\n      \"name\": \"getRootItems\",\n      \"desc\": \"Returns top-level categories shown in the tree (statistics, files, functions, entry points)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getStatisticsItems\",\n      \"desc\": \"Returns statistical summary items (total files, lines, functions, etc.)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getFilesItems\",\n      \"desc\": \"Returns all analyzed files organized by directory structure\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getFileDetails\",\n      \"desc\": \"Returns detailed information about a specific file (line count, functions, imports, exports)\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getDirectoryFiles\",\n      \"desc\": \"Returns all files within a specific directory\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"AnalysisItem[]\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./analyzer (CodeAnalysis, FileInfo, FunctionInfo, EntryPoint types)\"\n  ],\n  \"intent\": \"This file exists to provide developers with an interactive, browsable view of their codebase analysis results directly in VS Code's sidebar, making it easy to explore code metrics, navigate to specific functions or files, and understand the structure and complexity of their project at a glance\"\n}\n```"
        },
        {
          "file": "src/analyzer.ts",
          "role": "Core Logic",
          "purpose": "Defines the core data structures and interfaces for code analysis results, including file metadata, function signatures, dependencies, test mappings, and code duplication detection.",
          "userVisibleActions": [
            "See analysis results showing total files, lines, and functions in their codebase",
            "View list of large files that may need refactoring",
            "Identify orphaned files that are not imported anywhere",
            "Discover entry points (main functions) in the codebase",
            "Find duplicate code blocks across files",
            "See which functions are not covered by tests",
            "View function complexity and risk levels (high/medium/low)",
            "Understand function dependencies on databases, HTTP, filesystem, and other external resources"
          ],
          "developerVisibleActions": [
            "Import and use CodeAnalysis interface to structure analysis results",
            "Access file information including path, lines of code, complexity metrics, and roles",
            "Query function metadata including parameters, return types, visibility, and documentation",
            "Retrieve import relationships between files to understand module dependencies",
            "Access test mapping data to see which tests cover which source files and functions",
            "Use FunctionMetadata to get detailed function signatures, branches, and state mutations",
            "Access duplicate code detection results grouped by similarity hash",
            "Query dependency information to identify external service integrations",
            "Use AnalysisCache for caching and retrieving analysis results"
          ],
          "keyFunctions": [
            {
              "name": "CodeAnalysis",
              "desc": "Primary interface containing complete codebase analysis results",
              "inputs": "None (interface definition)",
              "outputs": "Structured data with file counts, function lists, imports, orphaned files, entry points, duplicates, and optional enhanced metadata"
            },
            {
              "name": "FunctionMetadata",
              "desc": "Detailed metadata for a single function including signature, documentation, control flow, and dependencies",
              "inputs": "None (interface definition)",
              "outputs": "Function name, parameters, return type, visibility, branches, dependencies, state mutations, risk level, and line numbers"
            },
            {
              "name": "TestMapping",
              "desc": "Maps source files and functions to their corresponding test coverage",
              "inputs": "None (interface definition)",
              "outputs": "Source-to-test file mappings, function-to-test mappings, and list of uncovered functions"
            },
            {
              "name": "DependencyInfo",
              "desc": "Describes external and internal dependencies used by functions",
              "inputs": "None (interface definition)",
              "outputs": "Dependency name, type (db/http/filesystem/etc), whether it's internal, and line number"
            },
            {
              "name": "BranchInfo",
              "desc": "Represents control flow branches in code (if/else/loop/try/catch)",
              "inputs": "None (interface definition)",
              "outputs": "Branch type, human-readable condition description, and line number"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "./cache"
          ],
          "intent": "This file exists to establish a standardized schema for code analysis results across the entire application. It solves the problem of consistently representing complex code structure information (functions, dependencies, tests, duplicates) in a way that different parts of the system can understand and use, enabling features like test coverage visualization, dependency tracking, code quality assessment, and duplicate detection.",
          "rawContent": "```json\n{\n  \"purpose\": \"Defines the core data structures and interfaces for code analysis results, including file metadata, function signatures, dependencies, test mappings, and code duplication detection.\",\n  \"userVisibleActions\": [\n    \"See analysis results showing total files, lines, and functions in their codebase\",\n    \"View list of large files that may need refactoring\",\n    \"Identify orphaned files that are not imported anywhere\",\n    \"Discover entry points (main functions) in the codebase\",\n    \"Find duplicate code blocks across files\",\n    \"See which functions are not covered by tests\",\n    \"View function complexity and risk levels (high/medium/low)\",\n    \"Understand function dependencies on databases, HTTP, filesystem, and other external resources\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import and use CodeAnalysis interface to structure analysis results\",\n    \"Access file information including path, lines of code, complexity metrics, and roles\",\n    \"Query function metadata including parameters, return types, visibility, and documentation\",\n    \"Retrieve import relationships between files to understand module dependencies\",\n    \"Access test mapping data to see which tests cover which source files and functions\",\n    \"Use FunctionMetadata to get detailed function signatures, branches, and state mutations\",\n    \"Access duplicate code detection results grouped by similarity hash\",\n    \"Query dependency information to identify external service integrations\",\n    \"Use AnalysisCache for caching and retrieving analysis results\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"CodeAnalysis\",\n      \"desc\": \"Primary interface containing complete codebase analysis results\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Structured data with file counts, function lists, imports, orphaned files, entry points, duplicates, and optional enhanced metadata\"\n    },\n    {\n      \"name\": \"FunctionMetadata\",\n      \"desc\": \"Detailed metadata for a single function including signature, documentation, control flow, and dependencies\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Function name, parameters, return type, visibility, branches, dependencies, state mutations, risk level, and line numbers\"\n    },\n    {\n      \"name\": \"TestMapping\",\n      \"desc\": \"Maps source files and functions to their corresponding test coverage\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Source-to-test file mappings, function-to-test mappings, and list of uncovered functions\"\n    },\n    {\n      \"name\": \"DependencyInfo\",\n      \"desc\": \"Describes external and internal dependencies used by functions\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Dependency name, type (db/http/filesystem/etc), whether it's internal, and line number\"\n    },\n    {\n      \"name\": \"BranchInfo\",\n      \"desc\": \"Represents control flow branches in code (if/else/loop/try/catch)\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Branch type, human-readable condition description, and line number\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./cache\"\n  ],\n  \"intent\": \"This file exists to establish a standardized schema for code analysis results across the entire application. It solves the problem of consistently representing complex code structure information (functions, dependencies, tests, duplicates) in a way that different parts of the system can understand and use, enabling features like test coverage visualization, dependency tracking, code quality assessment, and duplicate detection.\"\n}\n```"
        },
        {
          "file": "src/cache.ts",
          "role": "Core Logic",
          "purpose": "Manages persistent storage and retrieval of code analysis results with automatic expiration",
          "userVisibleActions": [
            "Analysis results load instantly when reopening a workspace (if cached within 24 hours)",
            "Analysis cache automatically expires after 24 hours, triggering fresh analysis",
            "Cache can be manually cleared to force fresh analysis"
          ],
          "developerVisibleActions": [
            "Cache directory (.shadowwatch-cache) is created in the specified storage path",
            "Analysis results are automatically saved after each analysis completes",
            "Cache files are named using base64-encoded workspace paths",
            "Stale cache entries (older than 24 hours) are automatically ignored",
            "Cache read/write errors are logged to console but don't block operations"
          ],
          "keyFunctions": [
            {
              "name": "constructor",
              "desc": "Initializes cache with storage location and creates cache directory",
              "inputs": "storagePath: string",
              "outputs": "AnalysisCache instance"
            },
            {
              "name": "getCacheKey",
              "desc": "Generates safe filename from workspace path for cache storage",
              "inputs": "workspaceRoot: string",
              "outputs": "base64-encoded string suitable for filename"
            },
            {
              "name": "get",
              "desc": "Retrieves cached analysis for workspace if exists and not expired",
              "inputs": "workspaceRoot: string",
              "outputs": "Promise<CodeAnalysis | null> - cached data or null if missing/expired"
            },
            {
              "name": "set",
              "desc": "Saves analysis results to cache with current timestamp",
              "inputs": "workspaceRoot: string, data: CodeAnalysis",
              "outputs": "Promise<void>"
            },
            {
              "name": "clear",
              "desc": "Removes all cached analysis files from cache directory",
              "inputs": "none",
              "outputs": "Promise<void>"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "./analyzer (CodeAnalysis type)"
          ],
          "intent": "Improves extension performance by caching expensive code analysis results, avoiding redundant analysis when reopening workspaces while ensuring cached data doesn't become stale through time-based expiration",
          "rawContent": "```json\n{\n  \"purpose\": \"Manages persistent storage and retrieval of code analysis results with automatic expiration\",\n  \"userVisibleActions\": [\n    \"Analysis results load instantly when reopening a workspace (if cached within 24 hours)\",\n    \"Analysis cache automatically expires after 24 hours, triggering fresh analysis\",\n    \"Cache can be manually cleared to force fresh analysis\"\n  ],\n  \"developerVisibleActions\": [\n    \"Cache directory (.shadowwatch-cache) is created in the specified storage path\",\n    \"Analysis results are automatically saved after each analysis completes\",\n    \"Cache files are named using base64-encoded workspace paths\",\n    \"Stale cache entries (older than 24 hours) are automatically ignored\",\n    \"Cache read/write errors are logged to console but don't block operations\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes cache with storage location and creates cache directory\",\n      \"inputs\": \"storagePath: string\",\n      \"outputs\": \"AnalysisCache instance\"\n    },\n    {\n      \"name\": \"getCacheKey\",\n      \"desc\": \"Generates safe filename from workspace path for cache storage\",\n      \"inputs\": \"workspaceRoot: string\",\n      \"outputs\": \"base64-encoded string suitable for filename\"\n    },\n    {\n      \"name\": \"get\",\n      \"desc\": \"Retrieves cached analysis for workspace if exists and not expired\",\n      \"inputs\": \"workspaceRoot: string\",\n      \"outputs\": \"Promise<CodeAnalysis | null> - cached data or null if missing/expired\"\n    },\n    {\n      \"name\": \"set\",\n      \"desc\": \"Saves analysis results to cache with current timestamp\",\n      \"inputs\": \"workspaceRoot: string, data: CodeAnalysis\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all cached analysis files from cache directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer (CodeAnalysis type)\"\n  ],\n  \"intent\": \"Improves extension performance by caching expensive code analysis results, avoiding redundant analysis when reopening workspaces while ensuring cached data doesn't become stale through time-based expiration\"\n}\n```"
        },
        {
          "file": "src/diagnosticsProvider.ts",
          "role": "Core Logic",
          "purpose": "Manages and displays code diagnostics (warnings, errors, info messages) in the VS Code Problems panel based on insights generated from code analysis",
          "userVisibleActions": [
            "Shows diagnostic messages (warnings, errors, info) in the Problems panel for issues found in code files",
            "Displays colored underlines or squiggles in code editor at specific line numbers where issues are detected",
            "Groups diagnostic messages by file in the Problems panel",
            "Shows 'Shadow Watch' as the source of diagnostic messages",
            "Clears all diagnostic messages when requested",
            "Updates diagnostics in real-time as insights are generated"
          ],
          "developerVisibleActions": [
            "Creates a diagnostic collection named 'shadowWatch' that appears in the Problems panel",
            "Converts Insight objects into VS Code Diagnostic objects that integrate with the editor",
            "Updates diagnostics for all files or for a specific file based on insight data",
            "Maps insight severity levels to VS Code diagnostic severity (Error, Warning, Information, Hint)",
            "Positions diagnostics at specific line numbers extracted from insights",
            "Clears diagnostics when analysis is reset or updated",
            "Provides cleanup through dispose method for proper resource management"
          ],
          "keyFunctions": [
            {
              "name": "updateDiagnostics",
              "desc": "Updates diagnostics for all files based on an array of insights",
              "inputs": "insights: Insight[] - Array of insight objects containing file paths, line numbers, descriptions, and severity",
              "outputs": "void - Displays diagnostics in Problems panel"
            },
            {
              "name": "updateDiagnosticsForFile",
              "desc": "Updates diagnostics for a specific file only",
              "inputs": "uri: vscode.Uri - File URI, insights: Insight[] - Insights for that file",
              "outputs": "void - Displays diagnostics for the specified file"
            },
            {
              "name": "clear",
              "desc": "Removes all diagnostics from the Problems panel",
              "inputs": "None",
              "outputs": "void"
            },
            {
              "name": "createDiagnostic",
              "desc": "Converts an Insight object into a VS Code Diagnostic object",
              "inputs": "insight: Insight - Contains description, severity, line number, file path, and ID",
              "outputs": "vscode.Diagnostic - VS Code diagnostic that appears in Problems panel and editor"
            },
            {
              "name": "getSeverity",
              "desc": "Maps insight severity string to VS Code DiagnosticSeverity enum",
              "inputs": "severity: string - Severity level from insight",
              "outputs": "vscode.DiagnosticSeverity - VS Code severity enum value"
            },
            {
              "name": "dispose",
              "desc": "Cleans up and disposes the diagnostic collection",
              "inputs": "None",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "vscode",
            "./insightGenerator"
          ],
          "intent": "This file exists to bridge the gap between code analysis insights and VS Code's built-in diagnostics system, allowing code issues to be displayed natively in the Problems panel and editor with proper formatting, severity levels, and file grouping - giving users a familiar interface for viewing and navigating code issues discovered by Shadow Watch",
          "rawContent": "```json\n{\n  \"purpose\": \"Manages and displays code diagnostics (warnings, errors, info messages) in the VS Code Problems panel based on insights generated from code analysis\",\n  \"userVisibleActions\": [\n    \"Shows diagnostic messages (warnings, errors, info) in the Problems panel for issues found in code files\",\n    \"Displays colored underlines or squiggles in code editor at specific line numbers where issues are detected\",\n    \"Groups diagnostic messages by file in the Problems panel\",\n    \"Shows 'Shadow Watch' as the source of diagnostic messages\",\n    \"Clears all diagnostic messages when requested\",\n    \"Updates diagnostics in real-time as insights are generated\"\n  ],\n  \"developerVisibleActions\": [\n    \"Creates a diagnostic collection named 'shadowWatch' that appears in the Problems panel\",\n    \"Converts Insight objects into VS Code Diagnostic objects that integrate with the editor\",\n    \"Updates diagnostics for all files or for a specific file based on insight data\",\n    \"Maps insight severity levels to VS Code diagnostic severity (Error, Warning, Information, Hint)\",\n    \"Positions diagnostics at specific line numbers extracted from insights\",\n    \"Clears diagnostics when analysis is reset or updated\",\n    \"Provides cleanup through dispose method for proper resource management\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"updateDiagnostics\",\n      \"desc\": \"Updates diagnostics for all files based on an array of insights\",\n      \"inputs\": \"insights: Insight[] - Array of insight objects containing file paths, line numbers, descriptions, and severity\",\n      \"outputs\": \"void - Displays diagnostics in Problems panel\"\n    },\n    {\n      \"name\": \"updateDiagnosticsForFile\",\n      \"desc\": \"Updates diagnostics for a specific file only\",\n      \"inputs\": \"uri: vscode.Uri - File URI, insights: Insight[] - Insights for that file\",\n      \"outputs\": \"void - Displays diagnostics for the specified file\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all diagnostics from the Problems panel\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"createDiagnostic\",\n      \"desc\": \"Converts an Insight object into a VS Code Diagnostic object\",\n      \"inputs\": \"insight: Insight - Contains description, severity, line number, file path, and ID\",\n      \"outputs\": \"vscode.Diagnostic - VS Code diagnostic that appears in Problems panel and editor\"\n    },\n    {\n      \"name\": \"getSeverity\",\n      \"desc\": \"Maps insight severity string to VS Code DiagnosticSeverity enum\",\n      \"inputs\": \"severity: string - Severity level from insight\",\n      \"outputs\": \"vscode.DiagnosticSeverity - VS Code severity enum value\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up and disposes the diagnostic collection\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between code analysis insights and VS Code's built-in diagnostics system, allowing code issues to be displayed natively in the Problems panel and editor with proper formatting, severity levels, and file grouping - giving users a familiar interface for viewing and navigating code issues discovered by Shadow Watch\"\n}\n```"
        },
        {
          "file": "src/extension.ts",
          "role": "Core Logic",
          "purpose": "Main entry point that initializes and coordinates the code analysis extension, registering all commands and UI components.",
          "userVisibleActions": [
            "Click 'Analyze Code' command to scan current workspace and show insights",
            "View code analysis results in a tree view panel",
            "See diagnostic warnings/errors in the Problems panel",
            "Navigate through product features via Product Navigator tree view",
            "Browse analysis results in Analysis Viewer webview",
            "View AI-generated insights in Insights Viewer webview",
            "Explore static analysis findings in Static Analysis Viewer",
            "Access unit test information via Unit Tests Navigator",
            "See analysis status in status bar with loading indicator",
            "Open specific files by clicking items in tree views",
            "Auto-refresh analysis when files change in workspace",
            "Generate LLM-ready context from code analysis",
            "Copy formatted analysis to clipboard for AI assistants"
          ],
          "developerVisibleActions": [
            "Extension activates when VS Code starts or workspace opens",
            "Registers multiple tree view providers for different perspectives",
            "Initializes code analyzer to parse TypeScript/JavaScript files",
            "Sets up file watcher to detect code changes automatically",
            "Creates diagnostics provider to surface code issues",
            "Establishes cache layer for performance optimization",
            "Bootstraps all extension components and dependencies",
            "Registers command palette commands for analysis actions",
            "Manages configuration through VS Code settings",
            "Handles errors and logs them appropriately",
            "Disposes resources on extension deactivation"
          ],
          "keyFunctions": [
            {
              "name": "activate",
              "desc": "Entry point that initializes extension, creates all components, and registers commands",
              "inputs": "vscode.ExtensionContext",
              "outputs": "void"
            },
            {
              "name": "deactivate",
              "desc": "Cleanup function that disposes resources when extension shuts down",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "runAnalysis",
              "desc": "Executes code analysis on workspace and updates all views with results",
              "inputs": "workspace folder path",
              "outputs": "analysis results object"
            }
          ],
          "dependencies": [
            "vscode",
            "path",
            "./analyzer",
            "./insightGenerator",
            "./llmFormatter",
            "./fileWatcher",
            "./insightsTreeView",
            "./diagnosticsProvider",
            "./cache",
            "./llmIntegration",
            "./productNavigator",
            "./analysisViewer",
            "./insightsViewer",
            "./staticAnalysisViewer",
            "./unitTestsNavigator",
            "./config/configurationManager",
            "./utils/errorHandler",
            "./ui/webview/webviewTemplateEngine",
            "./domain/bootstrap/extensionBootstrapper",
            "./domain/bootstrap/commandRegistry",
            "./domain/handlers/navigationHandler"
          ],
          "intent": "This file exists to orchestrate the entire code analysis extension by wiring together all components (analyzers, viewers, generators) and exposing them through VS Code's command palette and UI panels. It solves the problem of coordinating complex analysis workflows and presenting results through multiple specialized views.",
          "rawContent": "```json\n{\n  \"purpose\": \"Main entry point that initializes and coordinates the code analysis extension, registering all commands and UI components.\",\n  \"userVisibleActions\": [\n    \"Click 'Analyze Code' command to scan current workspace and show insights\",\n    \"View code analysis results in a tree view panel\",\n    \"See diagnostic warnings/errors in the Problems panel\",\n    \"Navigate through product features via Product Navigator tree view\",\n    \"Browse analysis results in Analysis Viewer webview\",\n    \"View AI-generated insights in Insights Viewer webview\",\n    \"Explore static analysis findings in Static Analysis Viewer\",\n    \"Access unit test information via Unit Tests Navigator\",\n    \"See analysis status in status bar with loading indicator\",\n    \"Open specific files by clicking items in tree views\",\n    \"Auto-refresh analysis when files change in workspace\",\n    \"Generate LLM-ready context from code analysis\",\n    \"Copy formatted analysis to clipboard for AI assistants\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extension activates when VS Code starts or workspace opens\",\n    \"Registers multiple tree view providers for different perspectives\",\n    \"Initializes code analyzer to parse TypeScript/JavaScript files\",\n    \"Sets up file watcher to detect code changes automatically\",\n    \"Creates diagnostics provider to surface code issues\",\n    \"Establishes cache layer for performance optimization\",\n    \"Bootstraps all extension components and dependencies\",\n    \"Registers command palette commands for analysis actions\",\n    \"Manages configuration through VS Code settings\",\n    \"Handles errors and logs them appropriately\",\n    \"Disposes resources on extension deactivation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"activate\",\n      \"desc\": \"Entry point that initializes extension, creates all components, and registers commands\",\n      \"inputs\": \"vscode.ExtensionContext\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"deactivate\",\n      \"desc\": \"Cleanup function that disposes resources when extension shuts down\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"runAnalysis\",\n      \"desc\": \"Executes code analysis on workspace and updates all views with results\",\n      \"inputs\": \"workspace folder path\",\n      \"outputs\": \"analysis results object\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./analyzer\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./fileWatcher\",\n    \"./insightsTreeView\",\n    \"./diagnosticsProvider\",\n    \"./cache\",\n    \"./llmIntegration\",\n    \"./productNavigator\",\n    \"./analysisViewer\",\n    \"./insightsViewer\",\n    \"./staticAnalysisViewer\",\n    \"./unitTestsNavigator\",\n    \"./config/configurationManager\",\n    \"./utils/errorHandler\",\n    \"./ui/webview/webviewTemplateEngine\",\n    \"./domain/bootstrap/extensionBootstrapper\",\n    \"./domain/bootstrap/commandRegistry\",\n    \"./domain/handlers/navigationHandler\"\n  ],\n  \"intent\": \"This file exists to orchestrate the entire code analysis extension by wiring together all components (analyzers, viewers, generators) and exposing them through VS Code's command palette and UI panels. It solves the problem of coordinating complex analysis workflows and presenting results through multiple specialized views.\"\n}\n```"
        },
        {
          "file": "src/fileAccessHelper.ts",
          "role": "Core Logic",
          "purpose": "Provides file reading and grep search functionality to enable iterative analysis of codebases by LLM agents",
          "userVisibleActions": [
            "LLM can request to read specific files from the workspace",
            "LLM can search for code patterns across multiple files using grep",
            "LLM receives file contents with line counts and existence status",
            "LLM receives search results with matching lines and context",
            "Search results are limited to prevent overwhelming the LLM with too many matches"
          ],
          "developerVisibleActions": [
            "Developer provides workspace root path to initialize file access",
            "Developer can request file contents by specifying file paths",
            "Developer can search codebase using regex patterns with optional file filters",
            "Developer receives structured responses with file metadata (lines, existence)",
            "Developer receives grep results with line numbers and surrounding context",
            "Developer can limit number of search results returned",
            "Developer can filter searches by file patterns (glob patterns like '*.ts')",
            "Developer receives organized file listings grouped by folder"
          ],
          "keyFunctions": [
            {
              "name": "getFileListing",
              "desc": "Organizes and formats a list of files grouped by their containing folders",
              "inputs": "Array of file objects with path, lines, and language",
              "outputs": "Formatted string with files organized by folder hierarchy"
            },
            {
              "name": "readFile",
              "desc": "Reads a file from the workspace and returns its content with metadata",
              "inputs": "File path relative to workspace root",
              "outputs": "FileResponse with content, line count, and existence status"
            },
            {
              "name": "grep",
              "desc": "Searches for a pattern across workspace files with optional filtering",
              "inputs": "Search pattern, optional file pattern filter, optional max results limit",
              "outputs": "GrepResponse with matches, line numbers, context, and limitation status"
            },
            {
              "name": "processRequest",
              "desc": "Routes and processes either file read or grep requests from LLM",
              "inputs": "LLMRequest (either FileRequest or GrepRequest)",
              "outputs": "Either FileResponse or GrepResponse depending on request type"
            }
          ],
          "dependencies": [
            "fs",
            "path"
          ],
          "intent": "This file exists to give LLM agents the ability to iteratively explore and analyze codebases by reading specific files and searching for patterns, enabling more thorough and targeted code understanding without loading entire codebases upfront",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides file reading and grep search functionality to enable iterative analysis of codebases by LLM agents\",\n  \"userVisibleActions\": [\n    \"LLM can request to read specific files from the workspace\",\n    \"LLM can search for code patterns across multiple files using grep\",\n    \"LLM receives file contents with line counts and existence status\",\n    \"LLM receives search results with matching lines and context\",\n    \"Search results are limited to prevent overwhelming the LLM with too many matches\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer provides workspace root path to initialize file access\",\n    \"Developer can request file contents by specifying file paths\",\n    \"Developer can search codebase using regex patterns with optional file filters\",\n    \"Developer receives structured responses with file metadata (lines, existence)\",\n    \"Developer receives grep results with line numbers and surrounding context\",\n    \"Developer can limit number of search results returned\",\n    \"Developer can filter searches by file patterns (glob patterns like '*.ts')\",\n    \"Developer receives organized file listings grouped by folder\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getFileListing\",\n      \"desc\": \"Organizes and formats a list of files grouped by their containing folders\",\n      \"inputs\": \"Array of file objects with path, lines, and language\",\n      \"outputs\": \"Formatted string with files organized by folder hierarchy\"\n    },\n    {\n      \"name\": \"readFile\",\n      \"desc\": \"Reads a file from the workspace and returns its content with metadata\",\n      \"inputs\": \"File path relative to workspace root\",\n      \"outputs\": \"FileResponse with content, line count, and existence status\"\n    },\n    {\n      \"name\": \"grep\",\n      \"desc\": \"Searches for a pattern across workspace files with optional filtering\",\n      \"inputs\": \"Search pattern, optional file pattern filter, optional max results limit\",\n      \"outputs\": \"GrepResponse with matches, line numbers, context, and limitation status\"\n    },\n    {\n      \"name\": \"processRequest\",\n      \"desc\": \"Routes and processes either file read or grep requests from LLM\",\n      \"inputs\": \"LLMRequest (either FileRequest or GrepRequest)\",\n      \"outputs\": \"Either FileResponse or GrepResponse depending on request type\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\"\n  ],\n  \"intent\": \"This file exists to give LLM agents the ability to iteratively explore and analyze codebases by reading specific files and searching for patterns, enabling more thorough and targeted code understanding without loading entire codebases upfront\"\n}\n```"
        },
        {
          "file": "src/fileDocumentation.ts",
          "role": "Core Logic",
          "purpose": "Defines the type system and data structures for organizing code documentation at file, module, and product levels.",
          "userVisibleActions": [
            "No direct user-visible actions - this file defines data structures used internally"
          ],
          "developerVisibleActions": [
            "Import and use TypeScript interfaces to structure documentation data",
            "Create FileSummary objects to document individual code files with role, purpose, and key functions",
            "Build ModuleSummary objects to organize files into logical modules with capabilities",
            "Generate EnhancedProductDocumentation with product overview, user perspectives, and architecture",
            "Access structured documentation data through well-defined TypeScript types",
            "Use these interfaces to ensure consistent documentation format across the codebase"
          ],
          "keyFunctions": [
            {
              "name": "FileSummary",
              "desc": "Interface defining how individual file documentation is structured",
              "inputs": "file path, role, purpose, actions, functions, dependencies",
              "outputs": "Structured file-level documentation object"
            },
            {
              "name": "ModuleSummary",
              "desc": "Interface defining how module-level documentation is structured",
              "inputs": "module path, type, capabilities, files, endpoints/commands/workers",
              "outputs": "Structured module-level documentation object"
            },
            {
              "name": "EnhancedProductDocumentation",
              "desc": "Interface defining complete product documentation structure",
              "inputs": "overview, user perspectives (GUI/CLI/API/CICD), architecture, workflows, problems solved",
              "outputs": "Comprehensive product documentation object"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "./analyzer"
          ],
          "intent": "This file exists to establish a consistent, hierarchical documentation structure that organizes code documentation from individual files up to product-level summaries. It provides TypeScript type definitions that ensure all documentation follows the same format, making it easier to generate, aggregate, and consume documentation programmatically across the codebase.",
          "rawContent": "```json\n{\n  \"purpose\": \"Defines the type system and data structures for organizing code documentation at file, module, and product levels.\",\n  \"userVisibleActions\": [\n    \"No direct user-visible actions - this file defines data structures used internally\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import and use TypeScript interfaces to structure documentation data\",\n    \"Create FileSummary objects to document individual code files with role, purpose, and key functions\",\n    \"Build ModuleSummary objects to organize files into logical modules with capabilities\",\n    \"Generate EnhancedProductDocumentation with product overview, user perspectives, and architecture\",\n    \"Access structured documentation data through well-defined TypeScript types\",\n    \"Use these interfaces to ensure consistent documentation format across the codebase\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"FileSummary\",\n      \"desc\": \"Interface defining how individual file documentation is structured\",\n      \"inputs\": \"file path, role, purpose, actions, functions, dependencies\",\n      \"outputs\": \"Structured file-level documentation object\"\n    },\n    {\n      \"name\": \"ModuleSummary\",\n      \"desc\": \"Interface defining how module-level documentation is structured\",\n      \"inputs\": \"module path, type, capabilities, files, endpoints/commands/workers\",\n      \"outputs\": \"Structured module-level documentation object\"\n    },\n    {\n      \"name\": \"EnhancedProductDocumentation\",\n      \"desc\": \"Interface defining complete product documentation structure\",\n      \"inputs\": \"overview, user perspectives (GUI/CLI/API/CICD), architecture, workflows, problems solved\",\n      \"outputs\": \"Comprehensive product documentation object\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to establish a consistent, hierarchical documentation structure that organizes code documentation from individual files up to product-level summaries. It provides TypeScript type definitions that ensure all documentation follows the same format, making it easier to generate, aggregate, and consume documentation programmatically across the codebase.\"\n}\n```"
        },
        {
          "file": "src/fileWatcher.ts",
          "role": "Core Logic",
          "purpose": "Monitors file saves and automatically triggers code analysis when TypeScript files are saved",
          "userVisibleActions": [
            "Code is automatically analyzed when you save a TypeScript file",
            "Analysis results appear in diagnostics and insights tree after file save",
            "Duplicate analyses are prevented when saving files rapidly",
            "Analysis can be throttled based on configuration settings"
          ],
          "developerVisibleActions": [
            "File watcher automatically starts when extension activates if 'analyzeOnSave' is enabled",
            "Debouncing mechanism prevents multiple analyses from running simultaneously",
            "File saves trigger analysis pipeline: analyzer → insight generator → diagnostics → tree view",
            "Analysis is skipped if already in progress or too soon after last analysis",
            "Watcher can be started and stopped programmatically",
            "Errors during analysis are handled and logged without crashing the extension"
          ],
          "keyFunctions": [
            {
              "name": "start",
              "desc": "Starts watching for file saves and sets up automatic analysis",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "stop",
              "desc": "Stops watching for file saves and cleans up resources",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "onFileSaved",
              "desc": "Handles file save events and triggers analysis after debounce delay",
              "inputs": "document: vscode.TextDocument",
              "outputs": "void"
            },
            {
              "name": "triggerAnalysis",
              "desc": "Executes the analysis pipeline when conditions are met",
              "inputs": "document: vscode.TextDocument",
              "outputs": "Promise<void>"
            },
            {
              "name": "dispose",
              "desc": "Cleans up all resources and stops the file watcher",
              "inputs": "none",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "vscode",
            "path",
            "CodeAnalyzer",
            "InsightGenerator",
            "DiagnosticsProvider",
            "InsightsTreeProvider",
            "ConfigurationManager",
            "ErrorHandler",
            "FileWatcherService"
          ],
          "intent": "This file exists to provide automatic code analysis triggered by file saves, giving users immediate feedback on their code without manual intervention. It solves the problem of having to manually trigger analysis after every code change by implementing intelligent debouncing and state management to ensure efficient, non-blocking analysis workflow.",
          "rawContent": "```json\n{\n  \"purpose\": \"Monitors file saves and automatically triggers code analysis when TypeScript files are saved\",\n  \"userVisibleActions\": [\n    \"Code is automatically analyzed when you save a TypeScript file\",\n    \"Analysis results appear in diagnostics and insights tree after file save\",\n    \"Duplicate analyses are prevented when saving files rapidly\",\n    \"Analysis can be throttled based on configuration settings\"\n  ],\n  \"developerVisibleActions\": [\n    \"File watcher automatically starts when extension activates if 'analyzeOnSave' is enabled\",\n    \"Debouncing mechanism prevents multiple analyses from running simultaneously\",\n    \"File saves trigger analysis pipeline: analyzer → insight generator → diagnostics → tree view\",\n    \"Analysis is skipped if already in progress or too soon after last analysis\",\n    \"Watcher can be started and stopped programmatically\",\n    \"Errors during analysis are handled and logged without crashing the extension\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"start\",\n      \"desc\": \"Starts watching for file saves and sets up automatic analysis\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"stop\",\n      \"desc\": \"Stops watching for file saves and cleans up resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"onFileSaved\",\n      \"desc\": \"Handles file save events and triggers analysis after debounce delay\",\n      \"inputs\": \"document: vscode.TextDocument\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"triggerAnalysis\",\n      \"desc\": \"Executes the analysis pipeline when conditions are met\",\n      \"inputs\": \"document: vscode.TextDocument\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all resources and stops the file watcher\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"CodeAnalyzer\",\n    \"InsightGenerator\",\n    \"DiagnosticsProvider\",\n    \"InsightsTreeProvider\",\n    \"ConfigurationManager\",\n    \"ErrorHandler\",\n    \"FileWatcherService\"\n  ],\n  \"intent\": \"This file exists to provide automatic code analysis triggered by file saves, giving users immediate feedback on their code without manual intervention. It solves the problem of having to manually trigger analysis after every code change by implementing intelligent debouncing and state management to ensure efficient, non-blocking analysis workflow.\"\n}\n```"
        },
        {
          "file": "src/insightGenerator.ts",
          "role": "Core Logic",
          "purpose": "Analyzes code structure and generates actionable insights about code quality, organization, and potential issues.",
          "userVisibleActions": [
            "Receives warnings about large files exceeding 500 lines of code",
            "Gets notified about orphaned files that aren't imported by other files",
            "Sees alerts for missing entry points in the codebase",
            "Receives warnings about potential circular dependencies between files",
            "Gets notified about 'god objects' (files with too many exports or responsibilities)",
            "Sees warnings about potential dead code that may not be used",
            "Receives suggestions about file organization issues",
            "Gets alerts about functions with high complexity",
            "Views severity levels (error, warning, info) for each insight",
            "Sees suggested fixes for each identified issue",
            "Views code snippets related to specific issues",
            "Gets file path and line number references for each problem"
          ],
          "developerVisibleActions": [
            "Calls generateInsights() with CodeAnalysis object to get all insights for entire codebase",
            "Calls generateInsightsForFile() with specific file path to get insights for single file",
            "Receives array of Insight objects with structured information (id, title, description, severity, category, suggestion)",
            "Uses severity levels to prioritize which insights to address first",
            "Follows suggestions to refactor or reorganize code",
            "Filters insights by category to focus on specific types of issues",
            "Uses file and line number information to navigate directly to problem areas"
          ],
          "keyFunctions": [
            {
              "name": "generateInsights",
              "desc": "Analyzes entire codebase and generates comprehensive list of code quality insights",
              "inputs": "CodeAnalysis object containing files, functions, and dependency information",
              "outputs": "Array of Insight objects with identified issues, warnings, and suggestions"
            },
            {
              "name": "generateInsightsForFile",
              "desc": "Generates insights specific to a single file in the codebase",
              "inputs": "CodeAnalysis object and specific file path string",
              "outputs": "Array of Insight objects relevant only to that file"
            },
            {
              "name": "checkLargeFiles",
              "desc": "Identifies files exceeding recommended line count threshold",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about oversized files"
            },
            {
              "name": "checkOrphanedFiles",
              "desc": "Finds files that aren't imported or used by other files",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about isolated files"
            },
            {
              "name": "checkEntryPoints",
              "desc": "Verifies presence of main entry points in codebase",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about missing entry points"
            },
            {
              "name": "checkCircularDependencies",
              "desc": "Detects potential circular import patterns between files",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about circular dependencies"
            },
            {
              "name": "checkGodObjects",
              "desc": "Identifies files with too many exports or responsibilities",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about files violating single responsibility principle"
            },
            {
              "name": "checkDeadCode",
              "desc": "Finds code that may not be used anywhere in the project",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about potentially unused code"
            },
            {
              "name": "checkFileOrganization",
              "desc": "Evaluates how files are structured and organized in the project",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about organizational improvements"
            },
            {
              "name": "checkFunctionComplexity",
              "desc": "Analyzes functions for excessive complexity or size",
              "inputs": "CodeAnalysis object",
              "outputs": "Array of insights about overly complex functions"
            }
          ],
          "dependencies": [
            "./analyzer"
          ],
          "intent": "This file exists to transform raw code analysis data into actionable, human-readable insights that help developers improve code quality, maintainability, and organization. It solves the problem of making sense of complex codebase metrics by categorizing issues, prioritizing them by severity, and providing specific suggestions for improvement.",
          "rawContent": "```json\n{\n  \"purpose\": \"Analyzes code structure and generates actionable insights about code quality, organization, and potential issues.\",\n  \"userVisibleActions\": [\n    \"Receives warnings about large files exceeding 500 lines of code\",\n    \"Gets notified about orphaned files that aren't imported by other files\",\n    \"Sees alerts for missing entry points in the codebase\",\n    \"Receives warnings about potential circular dependencies between files\",\n    \"Gets notified about 'god objects' (files with too many exports or responsibilities)\",\n    \"Sees warnings about potential dead code that may not be used\",\n    \"Receives suggestions about file organization issues\",\n    \"Gets alerts about functions with high complexity\",\n    \"Views severity levels (error, warning, info) for each insight\",\n    \"Sees suggested fixes for each identified issue\",\n    \"Views code snippets related to specific issues\",\n    \"Gets file path and line number references for each problem\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls generateInsights() with CodeAnalysis object to get all insights for entire codebase\",\n    \"Calls generateInsightsForFile() with specific file path to get insights for single file\",\n    \"Receives array of Insight objects with structured information (id, title, description, severity, category, suggestion)\",\n    \"Uses severity levels to prioritize which insights to address first\",\n    \"Follows suggestions to refactor or reorganize code\",\n    \"Filters insights by category to focus on specific types of issues\",\n    \"Uses file and line number information to navigate directly to problem areas\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"generateInsights\",\n      \"desc\": \"Analyzes entire codebase and generates comprehensive list of code quality insights\",\n      \"inputs\": \"CodeAnalysis object containing files, functions, and dependency information\",\n      \"outputs\": \"Array of Insight objects with identified issues, warnings, and suggestions\"\n    },\n    {\n      \"name\": \"generateInsightsForFile\",\n      \"desc\": \"Generates insights specific to a single file in the codebase\",\n      \"inputs\": \"CodeAnalysis object and specific file path string\",\n      \"outputs\": \"Array of Insight objects relevant only to that file\"\n    },\n    {\n      \"name\": \"checkLargeFiles\",\n      \"desc\": \"Identifies files exceeding recommended line count threshold\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about oversized files\"\n    },\n    {\n      \"name\": \"checkOrphanedFiles\",\n      \"desc\": \"Finds files that aren't imported or used by other files\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about isolated files\"\n    },\n    {\n      \"name\": \"checkEntryPoints\",\n      \"desc\": \"Verifies presence of main entry points in codebase\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about missing entry points\"\n    },\n    {\n      \"name\": \"checkCircularDependencies\",\n      \"desc\": \"Detects potential circular import patterns between files\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about circular dependencies\"\n    },\n    {\n      \"name\": \"checkGodObjects\",\n      \"desc\": \"Identifies files with too many exports or responsibilities\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about files violating single responsibility principle\"\n    },\n    {\n      \"name\": \"checkDeadCode\",\n      \"desc\": \"Finds code that may not be used anywhere in the project\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about potentially unused code\"\n    },\n    {\n      \"name\": \"checkFileOrganization\",\n      \"desc\": \"Evaluates how files are structured and organized in the project\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about organizational improvements\"\n    },\n    {\n      \"name\": \"checkFunctionComplexity\",\n      \"desc\": \"Analyzes functions for excessive complexity or size\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about overly complex functions\"\n    }\n  ],\n  \"dependencies\": [\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to transform raw code analysis data into actionable, human-readable insights that help developers improve code quality, maintainability, and organization. It solves the problem of making sense of complex codebase metrics by categorizing issues, prioritizing them by severity, and providing specific suggestions for improvement.\"\n}\n```"
        },
        {
          "file": "src/insightsTreeView.ts",
          "role": "GUI View",
          "purpose": "Provides a tree view UI in VSCode that displays code analysis insights, documentation status, and generated reports with actions to regenerate or view content.",
          "userVisibleActions": [
            "View a tree hierarchy showing product documentation, insights, unit tests, and analysis reports",
            "See status indicators (idle, generating, complete) for different analysis types",
            "Click to regenerate product documentation for the codebase",
            "Click to regenerate insights about the code",
            "Click to regenerate unit tests",
            "Click to regenerate various types of reports (workspace, product, architecture, unit test)",
            "View timestamps showing when each analysis was last generated",
            "Open generated reports in the editor by clicking on them",
            "Copy insights text to clipboard",
            "See progress indicators while content is being generated",
            "Receive notifications when generation completes or fails",
            "Configure LLM settings through the tree view",
            "Search within insights using a search command"
          ],
          "developerVisibleActions": [
            "Maintains state of all analysis artifacts (documentation, insights, reports)",
            "Persists timestamps and file paths across VSCode sessions",
            "Coordinates with LLMService to generate AI-powered content",
            "Triggers tree view refresh when data changes",
            "Handles user clicks on tree items to execute appropriate commands",
            "Validates existence of generated files before displaying them",
            "Provides context menu actions for regenerating content",
            "Integrates with workspace state to remember generation history",
            "Emits events when tree data changes to update the UI",
            "Manages multiple report types (workspace, product, architecture, unit test)",
            "Handles asynchronous generation workflows with status tracking"
          ],
          "keyFunctions": [
            {
              "name": "getTreeItem",
              "desc": "Converts a TreeItem into a vscode.TreeItem for display in the tree view",
              "inputs": "element: TreeItem",
              "outputs": "vscode.TreeItem"
            },
            {
              "name": "getChildren",
              "desc": "Returns child nodes for the tree structure, creating the hierarchy of insights, docs, and reports",
              "inputs": "element?: TreeItem",
              "outputs": "TreeItem[] or Promise<TreeItem[]>"
            },
            {
              "name": "setInsights",
              "desc": "Updates the insights data and refreshes the tree view",
              "inputs": "insights: Insight[]",
              "outputs": "void"
            },
            {
              "name": "setProductDocsStatus",
              "desc": "Updates the status of product documentation generation and refreshes the view",
              "inputs": "status: 'idle' | 'generating' | 'complete', timestamp?: number",
              "outputs": "void"
            },
            {
              "name": "setLLMInsights",
              "desc": "Stores LLM-generated insights and updates the view",
              "inputs": "insights: LLMInsights",
              "outputs": "void"
            },
            {
              "name": "setReportPath",
              "desc": "Sets the path to a generated report file and updates the view",
              "inputs": "path: string, timestamp: number",
              "outputs": "void"
            },
            {
              "name": "refresh",
              "desc": "Triggers a refresh of the entire tree view UI",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "loadPersistedState",
              "desc": "Loads previously saved timestamps and file paths from workspace storage",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "cleanupMissingFiles",
              "desc": "Verifies that stored file paths still exist and clears invalid entries",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "getUnitTestStatus",
              "desc": "Returns the current status of unit test generation",
              "inputs": "none",
              "outputs": "'idle' | 'generating' | 'complete'"
            }
          ],
          "dependencies": [
            "vscode",
            "./insightGenerator",
            "./llmFormatter",
            "./llmService"
          ],
          "intent": "This file exists to create an interactive sidebar panel in VSCode where users can view, manage, and regenerate AI-generated code analysis artifacts including documentation, insights, unit tests, and various reports, while maintaining state persistence across sessions.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view UI in VSCode that displays code analysis insights, documentation status, and generated reports with actions to regenerate or view content.\",\n  \"userVisibleActions\": [\n    \"View a tree hierarchy showing product documentation, insights, unit tests, and analysis reports\",\n    \"See status indicators (idle, generating, complete) for different analysis types\",\n    \"Click to regenerate product documentation for the codebase\",\n    \"Click to regenerate insights about the code\",\n    \"Click to regenerate unit tests\",\n    \"Click to regenerate various types of reports (workspace, product, architecture, unit test)\",\n    \"View timestamps showing when each analysis was last generated\",\n    \"Open generated reports in the editor by clicking on them\",\n    \"Copy insights text to clipboard\",\n    \"See progress indicators while content is being generated\",\n    \"Receive notifications when generation completes or fails\",\n    \"Configure LLM settings through the tree view\",\n    \"Search within insights using a search command\"\n  ],\n  \"developerVisibleActions\": [\n    \"Maintains state of all analysis artifacts (documentation, insights, reports)\",\n    \"Persists timestamps and file paths across VSCode sessions\",\n    \"Coordinates with LLMService to generate AI-powered content\",\n    \"Triggers tree view refresh when data changes\",\n    \"Handles user clicks on tree items to execute appropriate commands\",\n    \"Validates existence of generated files before displaying them\",\n    \"Provides context menu actions for regenerating content\",\n    \"Integrates with workspace state to remember generation history\",\n    \"Emits events when tree data changes to update the UI\",\n    \"Manages multiple report types (workspace, product, architecture, unit test)\",\n    \"Handles asynchronous generation workflows with status tracking\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts a TreeItem into a vscode.TreeItem for display in the tree view\",\n      \"inputs\": \"element: TreeItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child nodes for the tree structure, creating the hierarchy of insights, docs, and reports\",\n      \"inputs\": \"element?: TreeItem\",\n      \"outputs\": \"TreeItem[] or Promise<TreeItem[]>\"\n    },\n    {\n      \"name\": \"setInsights\",\n      \"desc\": \"Updates the insights data and refreshes the tree view\",\n      \"inputs\": \"insights: Insight[]\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setProductDocsStatus\",\n      \"desc\": \"Updates the status of product documentation generation and refreshes the view\",\n      \"inputs\": \"status: 'idle' | 'generating' | 'complete', timestamp?: number\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setLLMInsights\",\n      \"desc\": \"Stores LLM-generated insights and updates the view\",\n      \"inputs\": \"insights: LLMInsights\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setReportPath\",\n      \"desc\": \"Sets the path to a generated report file and updates the view\",\n      \"inputs\": \"path: string, timestamp: number\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Triggers a refresh of the entire tree view UI\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"loadPersistedState\",\n      \"desc\": \"Loads previously saved timestamps and file paths from workspace storage\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"cleanupMissingFiles\",\n      \"desc\": \"Verifies that stored file paths still exist and clears invalid entries\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"getUnitTestStatus\",\n      \"desc\": \"Returns the current status of unit test generation\",\n      \"inputs\": \"none\",\n      \"outputs\": \"'idle' | 'generating' | 'complete'\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./llmService\"\n  ],\n  \"intent\": \"This file exists to create an interactive sidebar panel in VSCode where users can view, manage, and regenerate AI-generated code analysis artifacts including documentation, insights, unit tests, and various reports, while maintaining state persistence across sessions.\"\n}\n```"
        },
        {
          "file": "src/insightsViewer.ts",
          "role": "GUI View",
          "purpose": "Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, automatically updating when insight files change.",
          "userVisibleActions": [
            "View architecture insights in a tree structure in the sidebar",
            "Browse different categories of insights (Components, Data Flow, Architecture Patterns, etc.)",
            "Click on insight items to see detailed descriptions",
            "Open related source code files by clicking on file references",
            "See real-time updates when AI generates new insights",
            "Refresh the insights view manually",
            "Navigate to specific code locations from insight items",
            "View purpose statements for individual files",
            "See grouped insights by category and type"
          ],
          "developerVisibleActions": [
            "Tree view automatically refreshes when .shadow/docs/ai-architecture-insights.json file changes",
            "Tree view updates when .shadow/docs/purpose.json file changes",
            "Clicking on file paths opens the corresponding source file in the editor",
            "Tree provides hierarchical navigation of AI-generated insights",
            "Insights are loaded from JSON files in the .shadow/docs directory",
            "File watchers monitor for changes and trigger automatic updates",
            "Purpose statements are displayed as additional insight items"
          ],
          "keyFunctions": [
            {
              "name": "refresh",
              "desc": "Reloads insights from disk and updates the tree view display",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "getTreeItem",
              "desc": "Converts an insight item into a VS Code tree item for display",
              "inputs": "InsightItem",
              "outputs": "vscode.TreeItem"
            },
            {
              "name": "getChildren",
              "desc": "Returns child items for the tree hierarchy (categories, subcategories, and individual insights)",
              "inputs": "optional parent InsightItem",
              "outputs": "Promise<InsightItem[]>"
            },
            {
              "name": "loadInsights",
              "desc": "Reads AI insights from the JSON file in .shadow/docs directory",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "loadPurposeStatements",
              "desc": "Reads file purpose statements from purpose.json file",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "setupFileWatcher",
              "desc": "Creates file system watchers to detect changes in insight files",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "openFile",
              "desc": "Opens a source code file in the editor at a specific location",
              "inputs": "file path and optional line number",
              "outputs": "Promise<void>"
            }
          ],
          "dependencies": [
            "vscode",
            "llmService",
            "path",
            "fs",
            "fileWatcherService"
          ],
          "intent": "This file exists to provide developers with an interactive, always-updated view of AI-generated architecture insights about their codebase. It solves the problem of making AI analysis results easily accessible and navigable within the VS Code interface, with automatic updates as the AI discovers new patterns or the code changes. It bridges the gap between AI analysis (stored in JSON files) and developer interaction (tree view UI).",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, automatically updating when insight files change.\",\n  \"userVisibleActions\": [\n    \"View architecture insights in a tree structure in the sidebar\",\n    \"Browse different categories of insights (Components, Data Flow, Architecture Patterns, etc.)\",\n    \"Click on insight items to see detailed descriptions\",\n    \"Open related source code files by clicking on file references\",\n    \"See real-time updates when AI generates new insights\",\n    \"Refresh the insights view manually\",\n    \"Navigate to specific code locations from insight items\",\n    \"View purpose statements for individual files\",\n    \"See grouped insights by category and type\"\n  ],\n  \"developerVisibleActions\": [\n    \"Tree view automatically refreshes when .shadow/docs/ai-architecture-insights.json file changes\",\n    \"Tree view updates when .shadow/docs/purpose.json file changes\",\n    \"Clicking on file paths opens the corresponding source file in the editor\",\n    \"Tree provides hierarchical navigation of AI-generated insights\",\n    \"Insights are loaded from JSON files in the .shadow/docs directory\",\n    \"File watchers monitor for changes and trigger automatic updates\",\n    \"Purpose statements are displayed as additional insight items\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Reloads insights from disk and updates the tree view display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts an insight item into a VS Code tree item for display\",\n      \"inputs\": \"InsightItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for the tree hierarchy (categories, subcategories, and individual insights)\",\n      \"inputs\": \"optional parent InsightItem\",\n      \"outputs\": \"Promise<InsightItem[]>\"\n    },\n    {\n      \"name\": \"loadInsights\",\n      \"desc\": \"Reads AI insights from the JSON file in .shadow/docs directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"loadPurposeStatements\",\n      \"desc\": \"Reads file purpose statements from purpose.json file\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setupFileWatcher\",\n      \"desc\": \"Creates file system watchers to detect changes in insight files\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"openFile\",\n      \"desc\": \"Opens a source code file in the editor at a specific location\",\n      \"inputs\": \"file path and optional line number\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"llmService\",\n    \"path\",\n    \"fs\",\n    \"fileWatcherService\"\n  ],\n  \"intent\": \"This file exists to provide developers with an interactive, always-updated view of AI-generated architecture insights about their codebase. It solves the problem of making AI analysis results easily accessible and navigable within the VS Code interface, with automatic updates as the AI discovers new patterns or the code changes. It bridges the gap between AI analysis (stored in JSON files) and developer interaction (tree view UI).\"\n}\n```"
        },
        {
          "file": "src/llmFormatter.ts",
          "role": "Core Logic",
          "purpose": "Formats code architecture insights into different LLM-friendly output formats for use with various AI assistants",
          "userVisibleActions": [
            "Receives formatted architecture issues grouped by severity (errors, warnings, info)",
            "Gets structured prompts asking for help prioritizing and addressing issues",
            "Sees architecture insights in different styles optimized for Cursor, ChatGPT, or generic LLMs",
            "Views compact summaries showing issue counts by type and severity"
          ],
          "developerVisibleActions": [
            "Calls formatInsights() with insights array and format type to get formatted output",
            "Chooses between 'cursor', 'chatgpt', 'compact', or 'generic' format styles",
            "Receives markdown-formatted text ready to paste into AI assistants",
            "Gets insights automatically grouped and sorted by severity level",
            "Receives actionable prompts requesting specific refactoring guidance from LLMs"
          ],
          "keyFunctions": [
            {
              "name": "formatInsights",
              "desc": "Main entry point that routes to appropriate formatter based on specified format",
              "inputs": "insights array and format string ('cursor', 'chatgpt', 'compact', 'generic')",
              "outputs": "Formatted markdown string ready for LLM consumption"
            },
            {
              "name": "formatForCursor",
              "desc": "Formats insights specifically for Cursor AI with severity groups and actionable prompts",
              "inputs": "Array of Insight objects",
              "outputs": "Markdown text with emoji-decorated sections and specific requests for help"
            },
            {
              "name": "formatForChatGPT",
              "desc": "Formats insights for ChatGPT with conversational tone and context",
              "inputs": "Array of Insight objects",
              "outputs": "Markdown text optimized for ChatGPT's interaction style"
            },
            {
              "name": "formatCompact",
              "desc": "Creates brief summary format showing counts and key statistics",
              "inputs": "Array of Insight objects",
              "outputs": "Condensed markdown summary of issues"
            },
            {
              "name": "formatGeneric",
              "desc": "Produces neutral format suitable for any LLM without specific optimizations",
              "inputs": "Array of Insight objects",
              "outputs": "Standard markdown listing of insights"
            }
          ],
          "dependencies": [
            "./insightGenerator"
          ],
          "intent": "Bridges the gap between raw code analysis insights and AI assistant prompts by transforming technical findings into well-structured, actionable requests that guide LLMs to provide specific refactoring advice and architectural guidance",
          "rawContent": "```json\n{\n  \"purpose\": \"Formats code architecture insights into different LLM-friendly output formats for use with various AI assistants\",\n  \"userVisibleActions\": [\n    \"Receives formatted architecture issues grouped by severity (errors, warnings, info)\",\n    \"Gets structured prompts asking for help prioritizing and addressing issues\",\n    \"Sees architecture insights in different styles optimized for Cursor, ChatGPT, or generic LLMs\",\n    \"Views compact summaries showing issue counts by type and severity\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls formatInsights() with insights array and format type to get formatted output\",\n    \"Chooses between 'cursor', 'chatgpt', 'compact', or 'generic' format styles\",\n    \"Receives markdown-formatted text ready to paste into AI assistants\",\n    \"Gets insights automatically grouped and sorted by severity level\",\n    \"Receives actionable prompts requesting specific refactoring guidance from LLMs\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"formatInsights\",\n      \"desc\": \"Main entry point that routes to appropriate formatter based on specified format\",\n      \"inputs\": \"insights array and format string ('cursor', 'chatgpt', 'compact', 'generic')\",\n      \"outputs\": \"Formatted markdown string ready for LLM consumption\"\n    },\n    {\n      \"name\": \"formatForCursor\",\n      \"desc\": \"Formats insights specifically for Cursor AI with severity groups and actionable prompts\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Markdown text with emoji-decorated sections and specific requests for help\"\n    },\n    {\n      \"name\": \"formatForChatGPT\",\n      \"desc\": \"Formats insights for ChatGPT with conversational tone and context\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Markdown text optimized for ChatGPT's interaction style\"\n    },\n    {\n      \"name\": \"formatCompact\",\n      \"desc\": \"Creates brief summary format showing counts and key statistics\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Condensed markdown summary of issues\"\n    },\n    {\n      \"name\": \"formatGeneric\",\n      \"desc\": \"Produces neutral format suitable for any LLM without specific optimizations\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Standard markdown listing of insights\"\n    }\n  ],\n  \"dependencies\": [\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"Bridges the gap between raw code analysis insights and AI assistant prompts by transforming technical findings into well-structured, actionable requests that guide LLMs to provide specific refactoring advice and architectural guidance\"\n}\n```"
        },
        {
          "file": "src/llmIntegration.ts",
          "role": "Core Logic",
          "purpose": "Manages LLM-powered code analysis features including insights generation, documentation, and navigation tree views in VS Code.",
          "userVisibleActions": [
            "View AI-generated code insights in a tree view panel",
            "See analysis results for entry points, unit tests, and product documentation",
            "Get real-time updates when API key configuration changes",
            "View formatted documentation in an output channel",
            "Navigate through analyzed code structure via tree providers",
            "Access saved analysis results that persist across sessions",
            "Receive notifications about analysis progress and completion",
            "See error messages when LLM operations fail"
          ],
          "developerVisibleActions": [
            "Initialize LLM service with API configuration",
            "Trigger code analysis on workspace files",
            "Generate insights from code analysis results",
            "Save and load analysis contexts for reuse",
            "Refresh tree views when analysis updates",
            "Execute shell commands for analysis operations",
            "Access state management for LLM operations",
            "Convert code analysis to LLM context format",
            "Persist analysis results to storage",
            "Format documentation for display"
          ],
          "keyFunctions": [
            {
              "name": "initializeLLMService",
              "desc": "Sets up the LLM service, output channels, and tree view refresh handlers",
              "inputs": "none",
              "outputs": "void - initializes global state"
            },
            {
              "name": "convertCodeAnalysisToContext",
              "desc": "Transforms code analysis data into format suitable for LLM processing",
              "inputs": "CodeAnalysis object",
              "outputs": "AnalysisContext object"
            },
            {
              "name": "saveCodeAnalysis",
              "desc": "Persists code analysis results to storage",
              "inputs": "CodeAnalysis data",
              "outputs": "Promise indicating save completion"
            },
            {
              "name": "loadSavedCodeAnalysisFromFile",
              "desc": "Retrieves previously saved code analysis from storage",
              "inputs": "file path or identifier",
              "outputs": "Promise<CodeAnalysis>"
            }
          ],
          "dependencies": [
            "vscode",
            "fs",
            "path",
            "child_process",
            "util",
            "./llmService",
            "./insightsTreeView",
            "./fileDocumentation",
            "./analyzer",
            "./productNavigator",
            "./analysisViewer",
            "./insightsViewer",
            "./unitTestsNavigator",
            "./logger",
            "./state/llmStateManager",
            "./context/analysisContextBuilder",
            "./domain/formatters/documentationFormatter",
            "./infrastructure/persistence/analysisResultRepository"
          ],
          "intent": "This file exists to orchestrate LLM-powered code understanding features in VS Code. It solves the problem of making large codebases understandable by connecting AI analysis with VS Code's UI components (tree views, output channels, navigation). It manages the lifecycle of analysis operations, state persistence, and user-facing visualization of AI-generated insights.",
          "rawContent": "```json\n{\n  \"purpose\": \"Manages LLM-powered code analysis features including insights generation, documentation, and navigation tree views in VS Code.\",\n  \"userVisibleActions\": [\n    \"View AI-generated code insights in a tree view panel\",\n    \"See analysis results for entry points, unit tests, and product documentation\",\n    \"Get real-time updates when API key configuration changes\",\n    \"View formatted documentation in an output channel\",\n    \"Navigate through analyzed code structure via tree providers\",\n    \"Access saved analysis results that persist across sessions\",\n    \"Receive notifications about analysis progress and completion\",\n    \"See error messages when LLM operations fail\"\n  ],\n  \"developerVisibleActions\": [\n    \"Initialize LLM service with API configuration\",\n    \"Trigger code analysis on workspace files\",\n    \"Generate insights from code analysis results\",\n    \"Save and load analysis contexts for reuse\",\n    \"Refresh tree views when analysis updates\",\n    \"Execute shell commands for analysis operations\",\n    \"Access state management for LLM operations\",\n    \"Convert code analysis to LLM context format\",\n    \"Persist analysis results to storage\",\n    \"Format documentation for display\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initializeLLMService\",\n      \"desc\": \"Sets up the LLM service, output channels, and tree view refresh handlers\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void - initializes global state\"\n    },\n    {\n      \"name\": \"convertCodeAnalysisToContext\",\n      \"desc\": \"Transforms code analysis data into format suitable for LLM processing\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"AnalysisContext object\"\n    },\n    {\n      \"name\": \"saveCodeAnalysis\",\n      \"desc\": \"Persists code analysis results to storage\",\n      \"inputs\": \"CodeAnalysis data\",\n      \"outputs\": \"Promise indicating save completion\"\n    },\n    {\n      \"name\": \"loadSavedCodeAnalysisFromFile\",\n      \"desc\": \"Retrieves previously saved code analysis from storage\",\n      \"inputs\": \"file path or identifier\",\n      \"outputs\": \"Promise<CodeAnalysis>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"child_process\",\n    \"util\",\n    \"./llmService\",\n    \"./insightsTreeView\",\n    \"./fileDocumentation\",\n    \"./analyzer\",\n    \"./productNavigator\",\n    \"./analysisViewer\",\n    \"./insightsViewer\",\n    \"./unitTestsNavigator\",\n    \"./logger\",\n    \"./state/llmStateManager\",\n    \"./context/analysisContextBuilder\",\n    \"./domain/formatters/documentationFormatter\",\n    \"./infrastructure/persistence/analysisResultRepository\"\n  ],\n  \"intent\": \"This file exists to orchestrate LLM-powered code understanding features in VS Code. It solves the problem of making large codebases understandable by connecting AI analysis with VS Code's UI components (tree views, output channels, navigation). It manages the lifecycle of analysis operations, state persistence, and user-facing visualization of AI-generated insights.\"\n}\n```"
        },
        {
          "file": "src/llmSchemas.ts",
          "role": "Core Logic",
          "purpose": "Defines JSON schemas for Claude AI to generate structured, type-safe responses for code analysis tasks",
          "userVisibleActions": [
            "Product purpose analysis results appear in structured format",
            "Code issues are categorized and prioritized automatically",
            "Architectural explanations follow consistent structure",
            "Code behavior summaries use standardized format",
            "File relationships are visualized with clear connections"
          ],
          "developerVisibleActions": [
            "Import schema definitions to ensure Claude returns parseable JSON responses",
            "Use productPurposeAnalysisSchema to get structured product insights",
            "Use issueItemSchema to receive categorized code issues with severity levels",
            "Use fileBehaviorSchema to extract user-facing and developer-facing actions from code",
            "Use relationshipSchema to understand file dependencies and connections",
            "Schemas guarantee valid JSON output without manual parsing or error handling",
            "All schemas include required fields validation and type enforcement"
          ],
          "keyFunctions": [],
          "dependencies": [],
          "intent": "Ensures Claude AI returns consistent, structured responses that can be programmatically processed without parsing errors. Eliminates the need for manual JSON extraction, regex parsing, or error handling when analyzing code. Each schema defines the exact shape of data needed for different analysis types (product purpose, code issues, file behavior, relationships).",
          "rawContent": "```json\n{\n  \"purpose\": \"Defines JSON schemas for Claude AI to generate structured, type-safe responses for code analysis tasks\",\n  \"userVisibleActions\": [\n    \"Product purpose analysis results appear in structured format\",\n    \"Code issues are categorized and prioritized automatically\",\n    \"Architectural explanations follow consistent structure\",\n    \"Code behavior summaries use standardized format\",\n    \"File relationships are visualized with clear connections\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import schema definitions to ensure Claude returns parseable JSON responses\",\n    \"Use productPurposeAnalysisSchema to get structured product insights\",\n    \"Use issueItemSchema to receive categorized code issues with severity levels\",\n    \"Use fileBehaviorSchema to extract user-facing and developer-facing actions from code\",\n    \"Use relationshipSchema to understand file dependencies and connections\",\n    \"Schemas guarantee valid JSON output without manual parsing or error handling\",\n    \"All schemas include required fields validation and type enforcement\"\n  ],\n  \"keyFunctions\": [],\n  \"dependencies\": [],\n  \"intent\": \"Ensures Claude AI returns consistent, structured responses that can be programmatically processed without parsing errors. Eliminates the need for manual JSON extraction, regex parsing, or error handling when analyzing code. Each schema defines the exact shape of data needed for different analysis types (product purpose, code issues, file behavior, relationships).\"\n}\n```"
        },
        {
          "file": "src/llmService.ts",
          "role": "Core Logic",
          "purpose": "Orchestrates AI-powered code analysis by connecting to LLM providers (OpenAI/Claude) to generate intelligent insights, documentation, and test plans from codebase analysis.",
          "userVisibleActions": [
            "Receives AI-generated explanations of what the codebase does and why it exists",
            "Gets intelligent insights about code architecture, patterns, and technical decisions",
            "Views automatically generated product documentation describing the software's purpose",
            "Sees AI-created unit test plans for code coverage",
            "Receives refactoring suggestions with code improvements",
            "Gets analysis of product purpose and architecture rationale"
          ],
          "developerVisibleActions": [
            "Calls analyzeProductPurpose() to get AI analysis of what the product does and its architecture decisions",
            "Invokes generateLLMInsights() to receive intelligent observations about code quality, patterns, and concerns",
            "Uses generateProductDocumentation() to create comprehensive product documentation from file summaries",
            "Triggers generateUnitTestPlan() to get AI-generated test strategies for specific files",
            "Calls generateRefactoringSuggestions() to receive code improvement recommendations",
            "Configures LLM provider settings (OpenAI, Claude, Ollama, OpenRouter) through configuration manager",
            "Handles rate limiting, retries, and error recovery automatically during LLM interactions",
            "Receives structured JSON responses parsed from LLM outputs",
            "Triggers incremental analysis to update insights as code changes"
          ],
          "keyFunctions": [
            {
              "name": "analyzeProductPurpose",
              "desc": "Analyzes the entire codebase to determine what the product does, its architecture rationale, user problems it solves, and technical approach",
              "inputs": "analysisContext (file metadata, imports, entry points)",
              "outputs": "ProductPurposeAnalysis with purpose, rationale, user problems, and technical approach"
            },
            {
              "name": "generateLLMInsights",
              "desc": "Generates intelligent insights about code patterns, architecture decisions, potential issues, and recommendations",
              "inputs": "analysisContext, optional productPurpose",
              "outputs": "Array of categorized insights (architecture, patterns, performance, maintenance, concerns)"
            },
            {
              "name": "generateProductDocumentation",
              "desc": "Creates comprehensive product documentation by analyzing file summaries and module organization",
              "inputs": "fileSummaries array, moduleSummaries array",
              "outputs": "EnhancedProductDocumentation with overview, features, architecture, and module details"
            },
            {
              "name": "generateUnitTestPlan",
              "desc": "Creates a detailed test plan for a specific file including test cases, edge cases, and mocking strategies",
              "inputs": "filePath, fileContent, codeAnalysis",
              "outputs": "UnitTestPlan with test cases, coverage areas, dependencies, and recommendations"
            },
            {
              "name": "generateRefactoringSuggestions",
              "desc": "Analyzes functions and provides AI-powered refactoring recommendations with code examples",
              "inputs": "filePath, fileContent, functions metadata, optional context",
              "outputs": "Array of refactoring suggestions with priority, rationale, and code snippets"
            },
            {
              "name": "callLLM",
              "desc": "Central method that sends requests to configured LLM provider with rate limiting and retry logic",
              "inputs": "prompt, systemMessage, schema, optional config",
              "outputs": "Parsed JSON response from LLM"
            },
            {
              "name": "getProviderInstance",
              "desc": "Creates and configures the appropriate LLM provider based on user settings",
              "inputs": "none (reads from configuration)",
              "outputs": "Configured LLMProvider instance (OpenAI, Claude, Ollama, or OpenRouter)"
            }
          ],
          "dependencies": [
            "vscode",
            "./fileDocumentation",
            "./analyzer",
            "./analysis/enhancedAnalyzer",
            "./llmSchemas",
            "./fileAccessHelper",
            "./logger",
            "./config/configurationManager",
            "./ai/providers/providerFactory",
            "./ai/llmResponseParser",
            "./ai/llmRateLimiter",
            "./ai/llmRetryHandler",
            "./domain/prompts/promptBuilder",
            "./domain/services/incrementalAnalysisService",
            "./domain/prompts/refactoringPromptBuilder",
            "./analysis/functionAnalyzer"
          ],
          "intent": "This file exists to bridge the gap between raw code analysis and human-understandable insights by leveraging Large Language Models. It solves the problem of developers needing to manually understand complex codebases by automatically generating intelligent documentation, architectural insights, test plans, and refactoring suggestions. It abstracts away the complexity of working with multiple LLM providers and handles the orchestration of prompts, responses, rate limiting, and error handling.",
          "rawContent": "```json\n{\n  \"purpose\": \"Orchestrates AI-powered code analysis by connecting to LLM providers (OpenAI/Claude) to generate intelligent insights, documentation, and test plans from codebase analysis.\",\n  \"userVisibleActions\": [\n    \"Receives AI-generated explanations of what the codebase does and why it exists\",\n    \"Gets intelligent insights about code architecture, patterns, and technical decisions\",\n    \"Views automatically generated product documentation describing the software's purpose\",\n    \"Sees AI-created unit test plans for code coverage\",\n    \"Receives refactoring suggestions with code improvements\",\n    \"Gets analysis of product purpose and architecture rationale\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls analyzeProductPurpose() to get AI analysis of what the product does and its architecture decisions\",\n    \"Invokes generateLLMInsights() to receive intelligent observations about code quality, patterns, and concerns\",\n    \"Uses generateProductDocumentation() to create comprehensive product documentation from file summaries\",\n    \"Triggers generateUnitTestPlan() to get AI-generated test strategies for specific files\",\n    \"Calls generateRefactoringSuggestions() to receive code improvement recommendations\",\n    \"Configures LLM provider settings (OpenAI, Claude, Ollama, OpenRouter) through configuration manager\",\n    \"Handles rate limiting, retries, and error recovery automatically during LLM interactions\",\n    \"Receives structured JSON responses parsed from LLM outputs\",\n    \"Triggers incremental analysis to update insights as code changes\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeProductPurpose\",\n      \"desc\": \"Analyzes the entire codebase to determine what the product does, its architecture rationale, user problems it solves, and technical approach\",\n      \"inputs\": \"analysisContext (file metadata, imports, entry points)\",\n      \"outputs\": \"ProductPurposeAnalysis with purpose, rationale, user problems, and technical approach\"\n    },\n    {\n      \"name\": \"generateLLMInsights\",\n      \"desc\": \"Generates intelligent insights about code patterns, architecture decisions, potential issues, and recommendations\",\n      \"inputs\": \"analysisContext, optional productPurpose\",\n      \"outputs\": \"Array of categorized insights (architecture, patterns, performance, maintenance, concerns)\"\n    },\n    {\n      \"name\": \"generateProductDocumentation\",\n      \"desc\": \"Creates comprehensive product documentation by analyzing file summaries and module organization\",\n      \"inputs\": \"fileSummaries array, moduleSummaries array\",\n      \"outputs\": \"EnhancedProductDocumentation with overview, features, architecture, and module details\"\n    },\n    {\n      \"name\": \"generateUnitTestPlan\",\n      \"desc\": \"Creates a detailed test plan for a specific file including test cases, edge cases, and mocking strategies\",\n      \"inputs\": \"filePath, fileContent, codeAnalysis\",\n      \"outputs\": \"UnitTestPlan with test cases, coverage areas, dependencies, and recommendations\"\n    },\n    {\n      \"name\": \"generateRefactoringSuggestions\",\n      \"desc\": \"Analyzes functions and provides AI-powered refactoring recommendations with code examples\",\n      \"inputs\": \"filePath, fileContent, functions metadata, optional context\",\n      \"outputs\": \"Array of refactoring suggestions with priority, rationale, and code snippets\"\n    },\n    {\n      \"name\": \"callLLM\",\n      \"desc\": \"Central method that sends requests to configured LLM provider with rate limiting and retry logic\",\n      \"inputs\": \"prompt, systemMessage, schema, optional config\",\n      \"outputs\": \"Parsed JSON response from LLM\"\n    },\n    {\n      \"name\": \"getProviderInstance\",\n      \"desc\": \"Creates and configures the appropriate LLM provider based on user settings\",\n      \"inputs\": \"none (reads from configuration)\",\n      \"outputs\": \"Configured LLMProvider instance (OpenAI, Claude, Ollama, or OpenRouter)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./fileDocumentation\",\n    \"./analyzer\",\n    \"./analysis/enhancedAnalyzer\",\n    \"./llmSchemas\",\n    \"./fileAccessHelper\",\n    \"./logger\",\n    \"./config/configurationManager\",\n    \"./ai/providers/providerFactory\",\n    \"./ai/llmResponseParser\",\n    \"./ai/llmRateLimiter\",\n    \"./ai/llmRetryHandler\",\n    \"./domain/prompts/promptBuilder\",\n    \"./domain/services/incrementalAnalysisService\",\n    \"./domain/prompts/refactoringPromptBuilder\",\n    \"./analysis/functionAnalyzer\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between raw code analysis and human-understandable insights by leveraging Large Language Models. It solves the problem of developers needing to manually understand complex codebases by automatically generating intelligent documentation, architectural insights, test plans, and refactoring suggestions. It abstracts away the complexity of working with multiple LLM providers and handles the orchestration of prompts, responses, rate limiting, and error handling.\"\n}\n```"
        },
        {
          "file": "src/logger.ts",
          "role": "Core Logic",
          "purpose": "Provides a logging utility that writes timestamped messages to a log file in the workspace's .shadow/logs directory",
          "userVisibleActions": [
            "Log files are created in the .shadow/logs folder at the workspace root",
            "Log entries appear with timestamps in shadow-watch.log file",
            "Section headers with visual separators appear in log file for organizing log output"
          ],
          "developerVisibleActions": [
            "Developer calls SWLogger.log() to write timestamped messages to the log file",
            "Developer calls SWLogger.section() to create visually separated sections in logs",
            "Logging silently fails if workspace is not available or errors occur, preventing crashes",
            "Log directory .shadow/logs is automatically created if it doesn't exist"
          ],
          "keyFunctions": [
            {
              "name": "log",
              "desc": "Writes a timestamped message to the log file",
              "inputs": "message: string - the text to log",
              "outputs": "void - writes to file system"
            },
            {
              "name": "section",
              "desc": "Creates a visually separated section header in the log file",
              "inputs": "title: string - the section title",
              "outputs": "void - writes formatted section header to file"
            },
            {
              "name": "getLogPath",
              "desc": "Determines the file path for the log file in the workspace",
              "inputs": "none",
              "outputs": "string | null - path to log file or null if no workspace"
            },
            {
              "name": "ensureDir",
              "desc": "Creates a directory and parent directories if they don't exist",
              "inputs": "dir: string - directory path to create",
              "outputs": "void - creates directories on file system"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "vscode"
          ],
          "intent": "Provides centralized logging functionality for the extension to track operations and debugging information in a persistent file within the workspace, making it easier to troubleshoot issues and understand extension behavior over time",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a logging utility that writes timestamped messages to a log file in the workspace's .shadow/logs directory\",\n  \"userVisibleActions\": [\n    \"Log files are created in the .shadow/logs folder at the workspace root\",\n    \"Log entries appear with timestamps in shadow-watch.log file\",\n    \"Section headers with visual separators appear in log file for organizing log output\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer calls SWLogger.log() to write timestamped messages to the log file\",\n    \"Developer calls SWLogger.section() to create visually separated sections in logs\",\n    \"Logging silently fails if workspace is not available or errors occur, preventing crashes\",\n    \"Log directory .shadow/logs is automatically created if it doesn't exist\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"log\",\n      \"desc\": \"Writes a timestamped message to the log file\",\n      \"inputs\": \"message: string - the text to log\",\n      \"outputs\": \"void - writes to file system\"\n    },\n    {\n      \"name\": \"section\",\n      \"desc\": \"Creates a visually separated section header in the log file\",\n      \"inputs\": \"title: string - the section title\",\n      \"outputs\": \"void - writes formatted section header to file\"\n    },\n    {\n      \"name\": \"getLogPath\",\n      \"desc\": \"Determines the file path for the log file in the workspace\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string | null - path to log file or null if no workspace\"\n    },\n    {\n      \"name\": \"ensureDir\",\n      \"desc\": \"Creates a directory and parent directories if they don't exist\",\n      \"inputs\": \"dir: string - directory path to create\",\n      \"outputs\": \"void - creates directories on file system\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"vscode\"\n  ],\n  \"intent\": \"Provides centralized logging functionality for the extension to track operations and debugging information in a persistent file within the workspace, making it easier to troubleshoot issues and understand extension behavior over time\"\n}\n```"
        },
        {
          "file": "src/productNavigator.ts",
          "role": "Core Logic",
          "purpose": "Provides a product-centric navigation view that organizes code by functionality instead of file structure, allowing users to browse the codebase by features and capabilities.",
          "userVisibleActions": [
            "View codebase organized by product features and functionality instead of file structure",
            "Navigate to code files by clicking on feature categories and subcategories",
            "See real-time updates to the product navigation tree when code documentation changes",
            "Expand and collapse feature groups to explore different areas of the product",
            "Click on file items to open and view source code files",
            "See visual indicators (icons and labels) for different types of product features",
            "Browse features grouped by user-facing categories, developer tools, and architectural components"
          ],
          "developerVisibleActions": [
            "Registers a custom tree view provider that organizes code by product functionality",
            "Monitors file system for changes to product documentation and updates the navigation tree automatically",
            "Loads enhanced product documentation from .shadow/docs directory to build the navigation structure",
            "Provides tree data through VSCode's TreeDataProvider interface for rendering in the sidebar",
            "Handles file watchers for both aggregate documentation and incremental file updates",
            "Manages workspace state and product documentation lifecycle",
            "Triggers tree refresh when documentation files are created, changed, or deleted",
            "Integrates with FileWatcherService for centralized file monitoring"
          ],
          "keyFunctions": [
            {
              "name": "getTreeItem",
              "desc": "Returns the visual representation (label, icon, collapsible state) for a navigation item",
              "inputs": "ProductNavItem element",
              "outputs": "TreeItem with display properties"
            },
            {
              "name": "getChildren",
              "desc": "Returns child navigation items for a given parent, building the hierarchical product navigation structure",
              "inputs": "Optional parent ProductNavItem",
              "outputs": "Array of child ProductNavItem objects"
            },
            {
              "name": "refresh",
              "desc": "Reloads product documentation and updates the navigation tree view",
              "inputs": "None",
              "outputs": "Promise that resolves when refresh is complete"
            },
            {
              "name": "loadProductDocumentation",
              "desc": "Loads enhanced product documentation from the workspace's shadow directory",
              "inputs": "None",
              "outputs": "EnhancedProductDocumentation object or null"
            },
            {
              "name": "setupFileWatcher",
              "desc": "Configures file system watchers to detect changes to product documentation files",
              "inputs": "None",
              "outputs": "None (side effect: sets up file watchers)"
            },
            {
              "name": "openFile",
              "desc": "Opens a source code file in the editor when user clicks on a navigation item",
              "inputs": "ProductNavItem representing a file",
              "outputs": "Promise that resolves when file is opened"
            },
            {
              "name": "buildFeatureTree",
              "desc": "Constructs the hierarchical navigation tree from product documentation features",
              "inputs": "EnhancedProductDocumentation",
              "outputs": "Array of top-level ProductNavItem objects"
            }
          ],
          "dependencies": [
            "vscode",
            "fileDocumentation (EnhancedProductDocumentation, FileSummary, ModuleSummary)",
            "path",
            "fs",
            "domain/services/fileWatcherService"
          ],
          "intent": "This file exists to replace traditional file-based navigation with a product-centric approach that organizes code by what it does rather than where it lives. It solves the problem of developers and users struggling to understand a codebase's functionality when navigating through arbitrary file/folder structures. By presenting code through the lens of features and capabilities, it makes codebases more discoverable and understandable, especially for new team members or when working with unfamiliar code.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a product-centric navigation view that organizes code by functionality instead of file structure, allowing users to browse the codebase by features and capabilities.\",\n  \"userVisibleActions\": [\n    \"View codebase organized by product features and functionality instead of file structure\",\n    \"Navigate to code files by clicking on feature categories and subcategories\",\n    \"See real-time updates to the product navigation tree when code documentation changes\",\n    \"Expand and collapse feature groups to explore different areas of the product\",\n    \"Click on file items to open and view source code files\",\n    \"See visual indicators (icons and labels) for different types of product features\",\n    \"Browse features grouped by user-facing categories, developer tools, and architectural components\"\n  ],\n  \"developerVisibleActions\": [\n    \"Registers a custom tree view provider that organizes code by product functionality\",\n    \"Monitors file system for changes to product documentation and updates the navigation tree automatically\",\n    \"Loads enhanced product documentation from .shadow/docs directory to build the navigation structure\",\n    \"Provides tree data through VSCode's TreeDataProvider interface for rendering in the sidebar\",\n    \"Handles file watchers for both aggregate documentation and incremental file updates\",\n    \"Manages workspace state and product documentation lifecycle\",\n    \"Triggers tree refresh when documentation files are created, changed, or deleted\",\n    \"Integrates with FileWatcherService for centralized file monitoring\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the visual representation (label, icon, collapsible state) for a navigation item\",\n      \"inputs\": \"ProductNavItem element\",\n      \"outputs\": \"TreeItem with display properties\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child navigation items for a given parent, building the hierarchical product navigation structure\",\n      \"inputs\": \"Optional parent ProductNavItem\",\n      \"outputs\": \"Array of child ProductNavItem objects\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Reloads product documentation and updates the navigation tree view\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Promise that resolves when refresh is complete\"\n    },\n    {\n      \"name\": \"loadProductDocumentation\",\n      \"desc\": \"Loads enhanced product documentation from the workspace's shadow directory\",\n      \"inputs\": \"None\",\n      \"outputs\": \"EnhancedProductDocumentation object or null\"\n    },\n    {\n      \"name\": \"setupFileWatcher\",\n      \"desc\": \"Configures file system watchers to detect changes to product documentation files\",\n      \"inputs\": \"None\",\n      \"outputs\": \"None (side effect: sets up file watchers)\"\n    },\n    {\n      \"name\": \"openFile\",\n      \"desc\": \"Opens a source code file in the editor when user clicks on a navigation item\",\n      \"inputs\": \"ProductNavItem representing a file\",\n      \"outputs\": \"Promise that resolves when file is opened\"\n    },\n    {\n      \"name\": \"buildFeatureTree\",\n      \"desc\": \"Constructs the hierarchical navigation tree from product documentation features\",\n      \"inputs\": \"EnhancedProductDocumentation\",\n      \"outputs\": \"Array of top-level ProductNavItem objects\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fileDocumentation (EnhancedProductDocumentation, FileSummary, ModuleSummary)\",\n    \"path\",\n    \"fs\",\n    \"domain/services/fileWatcherService\"\n  ],\n  \"intent\": \"This file exists to replace traditional file-based navigation with a product-centric approach that organizes code by what it does rather than where it lives. It solves the problem of developers and users struggling to understand a codebase's functionality when navigating through arbitrary file/folder structures. By presenting code through the lens of features and capabilities, it makes codebases more discoverable and understandable, especially for new team members or when working with unfamiliar code.\"\n}\n```"
        },
        {
          "file": "src/reportsTreeProvider.ts",
          "role": "Core Logic",
          "purpose": "Provides a tree view sidebar that displays all available Shadow Watch reports with their generation status and allows users to open them.",
          "userVisibleActions": [
            "View a tree list of all Shadow Watch report types in the sidebar",
            "See which reports have been generated (green file icon) and which haven't (gray slash icon)",
            "See when each report was last generated in the tooltip",
            "Click on a generated report to open it in the editor",
            "See descriptive tooltips explaining what each report type contains",
            "View report file paths and timestamps on hover"
          ],
          "developerVisibleActions": [
            "Register report generation events to update the tree view",
            "Track five report types: workspace, product, architecture, refactoring, and unit-test",
            "Refresh the tree view automatically when reports are generated or deleted",
            "Handle report metadata including path, timestamp, and description",
            "Provide context values for available/unavailable reports to enable different menu actions",
            "Emit tree data change events to trigger UI updates"
          ],
          "keyFunctions": [
            {
              "name": "ReportTreeItem.constructor",
              "desc": "Creates a tree item representing a report with visual indicators for availability status",
              "inputs": "label, reportType, filePath, description, timestamp",
              "outputs": "TreeItem with icon, tooltip, command, and context value"
            },
            {
              "name": "getChildren",
              "desc": "Returns the list of all report types to display in the tree view",
              "inputs": "element (optional parent item)",
              "outputs": "Array of ReportTreeItem objects"
            },
            {
              "name": "refresh",
              "desc": "Triggers a refresh of the tree view to show updated report statuses",
              "inputs": "none",
              "outputs": "void (fires onDidChangeTreeData event)"
            },
            {
              "name": "updateReport",
              "desc": "Updates the metadata for a specific report type when it's generated or modified",
              "inputs": "reportInfo (type, path, timestamp, label, description)",
              "outputs": "void (updates internal map and refreshes tree)"
            },
            {
              "name": "deleteReport",
              "desc": "Marks a report as unavailable when it's deleted",
              "inputs": "reportType",
              "outputs": "void (removes from map and refreshes tree)"
            }
          ],
          "dependencies": [
            "vscode",
            "path",
            "fs"
          ],
          "intent": "Replaces the old webview-based report viewer with a permanent sidebar pane that gives users a centralized location to see all report types, their availability status, and quick access to open them. Solves the problem of users not knowing which reports exist, whether they've been generated, and how to access them.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view sidebar that displays all available Shadow Watch reports with their generation status and allows users to open them.\",\n  \"userVisibleActions\": [\n    \"View a tree list of all Shadow Watch report types in the sidebar\",\n    \"See which reports have been generated (green file icon) and which haven't (gray slash icon)\",\n    \"See when each report was last generated in the tooltip\",\n    \"Click on a generated report to open it in the editor\",\n    \"See descriptive tooltips explaining what each report type contains\",\n    \"View report file paths and timestamps on hover\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register report generation events to update the tree view\",\n    \"Track five report types: workspace, product, architecture, refactoring, and unit-test\",\n    \"Refresh the tree view automatically when reports are generated or deleted\",\n    \"Handle report metadata including path, timestamp, and description\",\n    \"Provide context values for available/unavailable reports to enable different menu actions\",\n    \"Emit tree data change events to trigger UI updates\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"ReportTreeItem.constructor\",\n      \"desc\": \"Creates a tree item representing a report with visual indicators for availability status\",\n      \"inputs\": \"label, reportType, filePath, description, timestamp\",\n      \"outputs\": \"TreeItem with icon, tooltip, command, and context value\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns the list of all report types to display in the tree view\",\n      \"inputs\": \"element (optional parent item)\",\n      \"outputs\": \"Array of ReportTreeItem objects\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Triggers a refresh of the tree view to show updated report statuses\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void (fires onDidChangeTreeData event)\"\n    },\n    {\n      \"name\": \"updateReport\",\n      \"desc\": \"Updates the metadata for a specific report type when it's generated or modified\",\n      \"inputs\": \"reportInfo (type, path, timestamp, label, description)\",\n      \"outputs\": \"void (updates internal map and refreshes tree)\"\n    },\n    {\n      \"name\": \"deleteReport\",\n      \"desc\": \"Marks a report as unavailable when it's deleted\",\n      \"inputs\": \"reportType\",\n      \"outputs\": \"void (removes from map and refreshes tree)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"Replaces the old webview-based report viewer with a permanent sidebar pane that gives users a centralized location to see all report types, their availability status, and quick access to open them. Solves the problem of users not knowing which reports exist, whether they've been generated, and how to access them.\"\n}\n```"
        },
        {
          "file": "src/staticAnalysisViewer.ts",
          "role": "GUI View",
          "purpose": "Displays a tree view of static code analysis issues organized by severity (errors, warnings, info) for users to browse and navigate to problem locations.",
          "userVisibleActions": [
            "View static analysis issues organized by severity categories (errors, warnings, info)",
            "See a summary count of total issues found",
            "Click on an issue to navigate to the file and line where it was detected",
            "See 'No static issues found' message when analysis finds no problems",
            "View issue descriptions and affected file locations in the tree view",
            "Expand/collapse severity categories to show/hide issues",
            "See icons indicating issue severity (error, warning, info)"
          ],
          "developerVisibleActions": [
            "Set insights data from analysis results to populate the tree view",
            "Refresh the tree view to update displayed issues",
            "Trigger 'Analyze Workspace' command to check for issues",
            "Navigate to specific file locations when issues are selected",
            "Organize issues into error, warning, and info severity categories",
            "Display formatted file paths and line numbers for each issue"
          ],
          "keyFunctions": [
            {
              "name": "setInsights",
              "desc": "Updates the tree view with new static analysis results",
              "inputs": "Array of Insight objects containing issue data",
              "outputs": "void (triggers tree refresh)"
            },
            {
              "name": "refresh",
              "desc": "Refreshes the tree view display to show current insights",
              "inputs": "none",
              "outputs": "void (fires tree data change event)"
            },
            {
              "name": "getTreeItem",
              "desc": "Returns the visual representation of a tree item",
              "inputs": "StaticAnalysisItem element",
              "outputs": "vscode.TreeItem for display"
            },
            {
              "name": "getChildren",
              "desc": "Provides child items for tree hierarchy (categories and issues)",
              "inputs": "Optional parent StaticAnalysisItem",
              "outputs": "Promise of StaticAnalysisItem array"
            },
            {
              "name": "getRootItems",
              "desc": "Generates top-level tree items including summary and severity categories",
              "inputs": "none",
              "outputs": "Array of StaticAnalysisItem for root level"
            },
            {
              "name": "getErrorItems",
              "desc": "Retrieves all error-severity issues for display",
              "inputs": "none",
              "outputs": "Array of StaticAnalysisItem for errors"
            },
            {
              "name": "getWarningItems",
              "desc": "Retrieves all warning-severity issues for display",
              "inputs": "none",
              "outputs": "Array of StaticAnalysisItem for warnings"
            },
            {
              "name": "getInfoItems",
              "desc": "Retrieves all info-severity issues for display",
              "inputs": "none",
              "outputs": "Array of StaticAnalysisItem for info items"
            }
          ],
          "dependencies": [
            "vscode",
            "path",
            "./insightGenerator"
          ],
          "intent": "Provides a structured, browsable tree view interface for developers to review static code analysis results, organized by severity level, with quick navigation to problem locations in the codebase.",
          "rawContent": "```json\n{\n  \"purpose\": \"Displays a tree view of static code analysis issues organized by severity (errors, warnings, info) for users to browse and navigate to problem locations.\",\n  \"userVisibleActions\": [\n    \"View static analysis issues organized by severity categories (errors, warnings, info)\",\n    \"See a summary count of total issues found\",\n    \"Click on an issue to navigate to the file and line where it was detected\",\n    \"See 'No static issues found' message when analysis finds no problems\",\n    \"View issue descriptions and affected file locations in the tree view\",\n    \"Expand/collapse severity categories to show/hide issues\",\n    \"See icons indicating issue severity (error, warning, info)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Set insights data from analysis results to populate the tree view\",\n    \"Refresh the tree view to update displayed issues\",\n    \"Trigger 'Analyze Workspace' command to check for issues\",\n    \"Navigate to specific file locations when issues are selected\",\n    \"Organize issues into error, warning, and info severity categories\",\n    \"Display formatted file paths and line numbers for each issue\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setInsights\",\n      \"desc\": \"Updates the tree view with new static analysis results\",\n      \"inputs\": \"Array of Insight objects containing issue data\",\n      \"outputs\": \"void (triggers tree refresh)\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Refreshes the tree view display to show current insights\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void (fires tree data change event)\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the visual representation of a tree item\",\n      \"inputs\": \"StaticAnalysisItem element\",\n      \"outputs\": \"vscode.TreeItem for display\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Provides child items for tree hierarchy (categories and issues)\",\n      \"inputs\": \"Optional parent StaticAnalysisItem\",\n      \"outputs\": \"Promise of StaticAnalysisItem array\"\n    },\n    {\n      \"name\": \"getRootItems\",\n      \"desc\": \"Generates top-level tree items including summary and severity categories\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for root level\"\n    },\n    {\n      \"name\": \"getErrorItems\",\n      \"desc\": \"Retrieves all error-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for errors\"\n    },\n    {\n      \"name\": \"getWarningItems\",\n      \"desc\": \"Retrieves all warning-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for warnings\"\n    },\n    {\n      \"name\": \"getInfoItems\",\n      \"desc\": \"Retrieves all info-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for info items\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"Provides a structured, browsable tree view interface for developers to review static code analysis results, organized by severity level, with quick navigation to problem locations in the codebase.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [
        {
          "command": "shadow-watch.analyzeCode",
          "description": "Triggers comprehensive code analysis of the current workspace, generating insights, diagnostics, and updating all tree views"
        },
        {
          "command": "shadow-watch.openAnalysisViewer",
          "description": "Opens the Analysis Viewer panel showing codebase statistics, file structure, functions, and entry points"
        },
        {
          "command": "shadow-watch.openInsightsViewer",
          "description": "Opens the Insights Viewer displaying AI-generated architectural insights and code quality recommendations"
        },
        {
          "command": "shadow-watch.openStaticAnalysisViewer",
          "description": "Opens the Static Analysis Viewer showing detected issues organized by severity (errors, warnings, info)"
        },
        {
          "command": "shadow-watch.regenerateProductDocumentation",
          "description": "Triggers AI-powered generation of product-level documentation describing the codebase's purpose and architecture"
        },
        {
          "command": "shadow-watch.regenerateInsights",
          "description": "Regenerates AI-powered code insights including architectural patterns, technical decisions, and improvement suggestions"
        },
        {
          "command": "shadow-watch.regenerateUnitTests",
          "description": "Generates AI-powered unit test plans identifying gaps in test coverage"
        },
        {
          "command": "shadow-watch.regenerateReport",
          "description": "Regenerates a specific report type (workspace, product, architecture, or unit test documentation)"
        },
        {
          "command": "shadow-watch.clearCache",
          "description": "Clears cached analysis results, forcing a fresh analysis on next run"
        },
        {
          "command": "shadow-watch.configureLLM",
          "description": "Opens configuration for LLM provider settings (API keys, model selection)"
        },
        {
          "command": "shadow-watch.copyInsights",
          "description": "Copies formatted analysis insights to clipboard for use with external AI assistants"
        },
        {
          "command": "shadow-watch.openReport",
          "description": "Opens a specific generated report in the VS Code editor"
        }
      ],
      "workers": [
        {
          "name": "File Watcher",
          "description": "Monitors TypeScript file saves and triggers automatic analysis",
          "jobFlow": "User saves a TypeScript file → File watcher detects change → Throttles rapid saves → Triggers code analysis → Updates all views and diagnostics → Displays results in tree views and Problems panel"
        },
        {
          "name": "LLM Analysis Pipeline",
          "description": "Orchestrates AI-powered code analysis and documentation generation",
          "jobFlow": "User triggers analysis command → Code is parsed and analyzed for structure/metrics → Results formatted into LLM prompt → API call to OpenAI/Claude → Structured response parsed → Insights/documentation generated → Results saved to workspace → Tree views updated → User notified of completion"
        },
        {
          "name": "Cache Manager",
          "description": "Manages persistent storage and automatic expiration of analysis results",
          "jobFlow": "Analysis completes → Results serialized to JSON → Saved to .shadow/cache directory with timestamp → On workspace open, checks cache age → If under 24 hours, loads from cache → If expired, triggers fresh analysis → Cache can be manually cleared via command"
        },
        {
          "name": "Diagnostics Provider",
          "description": "Converts code insights into VS Code diagnostics displayed in Problems panel",
          "jobFlow": "Insights generated → Each insight mapped to diagnostic (error/warning/info) → Diagnostics associated with file locations and line numbers → Problems panel populated → Editor shows squiggles at problem locations → User clicks diagnostic → Editor navigates to problem location"
        }
      ]
    },
    {
      "module": "src/config",
      "moduleType": "other",
      "capabilities": [
        "Centralized management of all Shadow Watch extension settings and preferences",
        "Real-time configuration updates that automatically propagate to all extension components",
        "LLM provider configuration for OpenAI and Claude integrations with secure API key management",
        "Customizable security severity thresholds for error, warning, and info level issues",
        "Automatic code analysis triggers configurable for file save events",
        "Display preferences for inline code hints and annotations",
        "Flexible output format selection for LLM analysis results across multiple AI chat interfaces"
      ],
      "summary": "The config module provides comprehensive settings management for the Shadow Watch extension, serving as the central configuration hub that controls all aspects of extension behavior. It enables users to customize their security analysis experience through VS Code's settings interface, managing everything from LLM provider credentials to analysis automation preferences.\n\nUsers can configure critical operational parameters including which LLM services to use (OpenAI or Claude), set security issue severity thresholds that determine when and how issues are flagged, and control when analysis occurs (automatically on save or manually triggered). The module also manages UI preferences like inline hint visibility and output formatting options.\n\nAll configuration changes are monitored in real-time, with automatic notifications sent to relevant extension components whenever settings are updated. This ensures that user preference changes take immediate effect without requiring extension reloads, providing a seamless configuration experience that adapts instantly to user needs.",
      "files": [
        {
          "file": "src/config/configurationManager.ts",
          "role": "Core Logic",
          "purpose": "Manages all Shadow Watch extension settings and notifies components when configuration changes",
          "userVisibleActions": [
            "User changes Shadow Watch settings in VS Code preferences",
            "Extension behavior updates automatically when settings change (e.g., enable/disable analysis, adjust thresholds)",
            "User configures LLM providers (OpenAI, Claude) and API keys",
            "User sets severity thresholds for security issues (error, warning, info)",
            "User enables/disables automatic analysis on file save",
            "User toggles inline hints display in code editor",
            "User configures output formats for LLM analysis results (Cursor, ChatGPT, generic, compact)"
          ],
          "developerVisibleActions": [
            "Provides centralized type-safe access to all extension configuration values",
            "Automatically watches for configuration changes and notifies registered listeners",
            "Validates configuration settings and returns validation errors",
            "Exposes configuration properties through getter methods (enabled, analyzeOnSave, showInlineHints, etc.)",
            "Allows components to register callbacks that trigger when settings change",
            "Provides access to LLM provider settings, API keys, and model configurations",
            "Exposes severity thresholds, file pattern exclusions, and analysis limits"
          ],
          "keyFunctions": [
            {
              "name": "constructor",
              "desc": "Initializes configuration manager and sets up automatic change detection",
              "inputs": "none",
              "outputs": "ConfigurationManager instance"
            },
            {
              "name": "onConfigurationChange",
              "desc": "Registers a callback function that runs when configuration changes",
              "inputs": "callback function",
              "outputs": "void"
            },
            {
              "name": "removeConfigurationChangeListener",
              "desc": "Unregisters a configuration change callback",
              "inputs": "callback function",
              "outputs": "void"
            },
            {
              "name": "enabled (getter)",
              "desc": "Returns whether Shadow Watch extension is enabled",
              "inputs": "none",
              "outputs": "boolean"
            },
            {
              "name": "analyzeOnSave (getter)",
              "desc": "Returns whether automatic analysis on file save is enabled",
              "inputs": "none",
              "outputs": "boolean"
            },
            {
              "name": "showInlineHints (getter)",
              "desc": "Returns whether inline security hints should be displayed in editor",
              "inputs": "none",
              "outputs": "boolean"
            }
          ],
          "dependencies": [
            "vscode"
          ],
          "intent": "This file exists to provide a single source of truth for all Shadow Watch configuration settings. It solves the problem of scattered configuration access throughout the codebase by centralizing configuration management, providing type safety, and enabling reactive updates when users change settings. It ensures all components use consistent configuration values and stay synchronized when settings change.",
          "rawContent": "```json\n{\n  \"purpose\": \"Manages all Shadow Watch extension settings and notifies components when configuration changes\",\n  \"userVisibleActions\": [\n    \"User changes Shadow Watch settings in VS Code preferences\",\n    \"Extension behavior updates automatically when settings change (e.g., enable/disable analysis, adjust thresholds)\",\n    \"User configures LLM providers (OpenAI, Claude) and API keys\",\n    \"User sets severity thresholds for security issues (error, warning, info)\",\n    \"User enables/disables automatic analysis on file save\",\n    \"User toggles inline hints display in code editor\",\n    \"User configures output formats for LLM analysis results (Cursor, ChatGPT, generic, compact)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provides centralized type-safe access to all extension configuration values\",\n    \"Automatically watches for configuration changes and notifies registered listeners\",\n    \"Validates configuration settings and returns validation errors\",\n    \"Exposes configuration properties through getter methods (enabled, analyzeOnSave, showInlineHints, etc.)\",\n    \"Allows components to register callbacks that trigger when settings change\",\n    \"Provides access to LLM provider settings, API keys, and model configurations\",\n    \"Exposes severity thresholds, file pattern exclusions, and analysis limits\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes configuration manager and sets up automatic change detection\",\n      \"inputs\": \"none\",\n      \"outputs\": \"ConfigurationManager instance\"\n    },\n    {\n      \"name\": \"onConfigurationChange\",\n      \"desc\": \"Registers a callback function that runs when configuration changes\",\n      \"inputs\": \"callback function\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"removeConfigurationChangeListener\",\n      \"desc\": \"Unregisters a configuration change callback\",\n      \"inputs\": \"callback function\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"enabled (getter)\",\n      \"desc\": \"Returns whether Shadow Watch extension is enabled\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    },\n    {\n      \"name\": \"analyzeOnSave (getter)\",\n      \"desc\": \"Returns whether automatic analysis on file save is enabled\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    },\n    {\n      \"name\": \"showInlineHints (getter)\",\n      \"desc\": \"Returns whether inline security hints should be displayed in editor\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to provide a single source of truth for all Shadow Watch configuration settings. It solves the problem of scattered configuration access throughout the codebase by centralizing configuration management, providing type safety, and enabling reactive updates when users change settings. It ensures all components use consistent configuration values and stay synchronized when settings change.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/context",
      "moduleType": "other",
      "capabilities": [
        "Automatically persists code analysis results to disk for future reference and reuse",
        "Converts complex code analysis data into a structured format optimized for LLM consumption",
        "Maintains a persistent documentation cache in the project workspace",
        "Enables code intelligence features by storing analyzed code structure and metadata"
      ],
      "summary": "The context module serves as a bridge between code analysis tools and AI-powered features by transforming raw analysis results into LLM-friendly formats. It automatically captures insights about code structure, dependencies, and relationships, then persists this information for future use.\n\nWhen code is analyzed, this module saves the results to a dedicated .shadow/docs directory within your project workspace. This creates a persistent cache of code intelligence that can be leveraged across multiple AI interactions without re-analyzing the same code. The module handles the conversion of technical analysis data into structured contexts that language models can effectively interpret and use for tasks like code generation, refactoring suggestions, and documentation.\n\nThe workflow is transparent to users: as you work with AI features that analyze your code, the context module automatically manages the storage and formatting of analysis results in the background. This cached analysis improves performance and consistency across AI-powered development workflows.",
      "files": [
        {
          "file": "src/context/analysisContextBuilder.ts",
          "role": "Core Logic",
          "purpose": "Converts code analysis results into a format suitable for LLM consumption and persists analysis data to disk for future reference",
          "userVisibleActions": [
            "Analysis results are automatically saved to the workspace for future use",
            "Code analysis data is stored in a .shadow/docs directory within the project"
          ],
          "developerVisibleActions": [
            "Converts CodeAnalysis objects into AnalysisContext format that can be sent to LLM services",
            "Saves analysis results with metadata (generation timestamp, workspace path) to code-analysis.json",
            "Creates .shadow/docs directory structure if it doesn't exist",
            "Handles workspace detection and validation before saving files"
          ],
          "keyFunctions": [
            {
              "name": "convertCodeAnalysisToContext",
              "desc": "Transforms CodeAnalysis data structure into AnalysisContext format for LLM processing",
              "inputs": "CodeAnalysis object containing files, imports, entry points, and metrics",
              "outputs": "AnalysisContext object with restructured file information, imports, entry points, and statistics"
            },
            {
              "name": "saveCodeAnalysis",
              "desc": "Persists code analysis results to the workspace filesystem for later retrieval",
              "inputs": "CodeAnalysis object to be saved",
              "outputs": "void - creates/updates code-analysis.json file in .shadow/docs directory"
            }
          ],
          "dependencies": [
            "vscode",
            "fs",
            "path",
            "../analyzer",
            "../llmService"
          ],
          "intent": "This file exists to bridge the gap between code analysis results and LLM consumption by reformatting the data, and to provide persistence so that expensive analysis operations don't need to be repeated. It solves the problem of maintaining analysis state across sessions and preparing data in the exact format required by the LLM service.",
          "rawContent": "```json\n{\n  \"purpose\": \"Converts code analysis results into a format suitable for LLM consumption and persists analysis data to disk for future reference\",\n  \"userVisibleActions\": [\n    \"Analysis results are automatically saved to the workspace for future use\",\n    \"Code analysis data is stored in a .shadow/docs directory within the project\"\n  ],\n  \"developerVisibleActions\": [\n    \"Converts CodeAnalysis objects into AnalysisContext format that can be sent to LLM services\",\n    \"Saves analysis results with metadata (generation timestamp, workspace path) to code-analysis.json\",\n    \"Creates .shadow/docs directory structure if it doesn't exist\",\n    \"Handles workspace detection and validation before saving files\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"convertCodeAnalysisToContext\",\n      \"desc\": \"Transforms CodeAnalysis data structure into AnalysisContext format for LLM processing\",\n      \"inputs\": \"CodeAnalysis object containing files, imports, entry points, and metrics\",\n      \"outputs\": \"AnalysisContext object with restructured file information, imports, entry points, and statistics\"\n    },\n    {\n      \"name\": \"saveCodeAnalysis\",\n      \"desc\": \"Persists code analysis results to the workspace filesystem for later retrieval\",\n      \"inputs\": \"CodeAnalysis object to be saved\",\n      \"outputs\": \"void - creates/updates code-analysis.json file in .shadow/docs directory\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"../analyzer\",\n    \"../llmService\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between code analysis results and LLM consumption by reformatting the data, and to provide persistence so that expensive analysis operations don't need to be repeated. It solves the problem of maintaining analysis state across sessions and preparing data in the exact format required by the LLM service.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/domain/bootstrap",
      "moduleType": "other",
      "capabilities": [
        "Initialize and configure the VS Code extension with all necessary components and services",
        "Register and manage all extension commands for code analysis, navigation, and insights",
        "Set up UI components including status bar, tree views, and diagnostic panels",
        "Establish event handlers for automatic file change detection and re-analysis",
        "Configure workspace-wide and file-specific code analysis capabilities",
        "Enable navigation between product features, analysis results, and test structures",
        "Provide clipboard operations for sharing insights and analysis data",
        "Manage extension settings and LLM provider configurations",
        "Display real-time status information and analysis reports"
      ],
      "summary": "The bootstrap module serves as the initialization and configuration layer for the VS Code extension, responsible for setting up all components when the extension activates. It orchestrates the registration of commands, initialization of UI elements (status bar, tree views, diagnostics), and configuration of services that power the extension's code analysis and insight generation capabilities.\n\nThis module enables users to interact with the extension through registered commands for analyzing code, navigating product structures, viewing insights, and managing extension data. It establishes the connection between user actions (like clicking buttons or triggering commands) and the underlying services that perform analysis, generate insights, and display results.\n\nThe bootstrap process creates a complete workflow infrastructure: users can analyze their workspace or individual files, view results in dedicated tree views, navigate through product features and test structures, copy insights to clipboard, and monitor extension status through the status bar. The module also sets up automatic re-analysis triggers when files change, ensuring insights stay current as code evolves.",
      "files": [
        {
          "file": "src/domain/bootstrap/commandRegistry.ts",
          "role": "Core Logic",
          "purpose": "Registers all VS Code commands for the extension, mapping command IDs to their handler functions",
          "userVisibleActions": [
            "Analyze entire workspace for code insights",
            "Analyze currently open file",
            "Copy all insights to clipboard",
            "Copy insights for a specific file",
            "Copy a single insight",
            "Clear cached analysis data",
            "Clear all extension data",
            "Open extension settings",
            "View latest analysis report",
            "View latest unit test report",
            "Switch between LLM providers",
            "Copy menu structure",
            "View current LLM provider status",
            "Navigate to a product feature or component",
            "Navigate to a specific analysis result",
            "View detailed information about a product item",
            "View detailed information about an insight",
            "View detailed information about a unit test"
          ],
          "developerVisibleActions": [
            "Centralizes command registration logic for maintainability",
            "Provides type-safe command handler interface",
            "Integrates with VS Code command palette and UI elements",
            "Coordinates between analyzer, insight generator, and UI components",
            "Manages analysis caching and data persistence",
            "Handles configuration and provider switching",
            "Routes navigation actions to appropriate viewers",
            "Enables clipboard operations for analysis results"
          ],
          "keyFunctions": [
            {
              "name": "register",
              "desc": "Registers all extension commands with VS Code's command system",
              "inputs": "context: ExtensionContext, components: ExtensionComponents",
              "outputs": "void - side effect of registering commands"
            },
            {
              "name": "analyzeWorkspace",
              "desc": "Triggers analysis of all files in the workspace",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "analyzeCurrentFile",
              "desc": "Triggers analysis of the currently active file",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "copyAllInsights",
              "desc": "Copies all generated insights to the clipboard",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "copyFileInsights",
              "desc": "Copies insights for a specific file to the clipboard",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "copyInsight",
              "desc": "Copies a single insight item to the clipboard",
              "inputs": "item: any",
              "outputs": "Promise<void>"
            },
            {
              "name": "clearCache",
              "desc": "Clears the analysis cache",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "clearAllData",
              "desc": "Clears all extension data including cache and settings",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "switchProvider",
              "desc": "Switches between different LLM provider configurations",
              "inputs": "none",
              "outputs": "Promise<void>"
            },
            {
              "name": "navigateToProductItem",
              "desc": "Opens the file/location associated with a product feature",
              "inputs": "item: ProductNavItem",
              "outputs": "Promise<void>"
            },
            {
              "name": "navigateToAnalysisItem",
              "desc": "Opens the file/location associated with an analysis result",
              "inputs": "item: AnalysisItem",
              "outputs": "Promise<void>"
            },
            {
              "name": "showProviderStatus",
              "desc": "Displays information about the current LLM provider configuration",
              "inputs": "none",
              "outputs": "Promise<void>"
            }
          ],
          "dependencies": [
            "vscode",
            "llmIntegration",
            "CodeAnalyzer",
            "InsightGenerator",
            "LLMFormatter",
            "InsightsTreeProvider",
            "DiagnosticsProvider",
            "AnalysisCache",
            "AnalysisViewerProvider",
            "ProductNavItem",
            "configurationManager",
            "ExtensionComponents"
          ],
          "intent": "Separates command registration logic from the main extension file to improve maintainability and organization. Provides a centralized place where all user-invocable commands are mapped to their implementation, making it easy to understand what actions users can perform and ensuring consistent command handling across the extension.",
          "rawContent": "```json\n{\n  \"purpose\": \"Registers all VS Code commands for the extension, mapping command IDs to their handler functions\",\n  \"userVisibleActions\": [\n    \"Analyze entire workspace for code insights\",\n    \"Analyze currently open file\",\n    \"Copy all insights to clipboard\",\n    \"Copy insights for a specific file\",\n    \"Copy a single insight\",\n    \"Clear cached analysis data\",\n    \"Clear all extension data\",\n    \"Open extension settings\",\n    \"View latest analysis report\",\n    \"View latest unit test report\",\n    \"Switch between LLM providers\",\n    \"Copy menu structure\",\n    \"View current LLM provider status\",\n    \"Navigate to a product feature or component\",\n    \"Navigate to a specific analysis result\",\n    \"View detailed information about a product item\",\n    \"View detailed information about an insight\",\n    \"View detailed information about a unit test\"\n  ],\n  \"developerVisibleActions\": [\n    \"Centralizes command registration logic for maintainability\",\n    \"Provides type-safe command handler interface\",\n    \"Integrates with VS Code command palette and UI elements\",\n    \"Coordinates between analyzer, insight generator, and UI components\",\n    \"Manages analysis caching and data persistence\",\n    \"Handles configuration and provider switching\",\n    \"Routes navigation actions to appropriate viewers\",\n    \"Enables clipboard operations for analysis results\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"register\",\n      \"desc\": \"Registers all extension commands with VS Code's command system\",\n      \"inputs\": \"context: ExtensionContext, components: ExtensionComponents\",\n      \"outputs\": \"void - side effect of registering commands\"\n    },\n    {\n      \"name\": \"analyzeWorkspace\",\n      \"desc\": \"Triggers analysis of all files in the workspace\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"analyzeCurrentFile\",\n      \"desc\": \"Triggers analysis of the currently active file\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"copyAllInsights\",\n      \"desc\": \"Copies all generated insights to the clipboard\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"copyFileInsights\",\n      \"desc\": \"Copies insights for a specific file to the clipboard\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"copyInsight\",\n      \"desc\": \"Copies a single insight item to the clipboard\",\n      \"inputs\": \"item: any\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clearCache\",\n      \"desc\": \"Clears the analysis cache\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clearAllData\",\n      \"desc\": \"Clears all extension data including cache and settings\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"switchProvider\",\n      \"desc\": \"Switches between different LLM provider configurations\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"navigateToProductItem\",\n      \"desc\": \"Opens the file/location associated with a product feature\",\n      \"inputs\": \"item: ProductNavItem\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"navigateToAnalysisItem\",\n      \"desc\": \"Opens the file/location associated with an analysis result\",\n      \"inputs\": \"item: AnalysisItem\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"showProviderStatus\",\n      \"desc\": \"Displays information about the current LLM provider configuration\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"llmIntegration\",\n    \"CodeAnalyzer\",\n    \"InsightGenerator\",\n    \"LLMFormatter\",\n    \"InsightsTreeProvider\",\n    \"DiagnosticsProvider\",\n    \"AnalysisCache\",\n    \"AnalysisViewerProvider\",\n    \"ProductNavItem\",\n    \"configurationManager\",\n    \"ExtensionComponents\"\n  ],\n  \"intent\": \"Separates command registration logic from the main extension file to improve maintainability and organization. Provides a centralized place where all user-invocable commands are mapped to their implementation, making it easy to understand what actions users can perform and ensuring consistent command handling across the extension.\"\n}\n```"
        },
        {
          "file": "src/domain/bootstrap/extensionBootstrapper.ts",
          "role": "Core Logic",
          "purpose": "Initializes and configures all extension components when the VS Code extension activates, connecting UI elements, services, and event handlers",
          "userVisibleActions": [
            "Status bar displays extension status and information",
            "Product Navigator view shows navigable product structure",
            "Analysis Viewer displays code analysis results",
            "Insights Viewer shows generated code insights",
            "Static Analysis Viewer presents static analysis findings",
            "Unit Tests Navigator displays test structure and results",
            "Reports Viewer shows generated analysis reports",
            "Diagnostics appear in Problems panel for code issues",
            "File changes trigger automatic re-analysis"
          ],
          "developerVisibleActions": [
            "Extension activates and initializes all components on workspace open",
            "Components are registered and connected to VS Code UI elements",
            "Tree views are created for navigation and visualization",
            "File watchers monitor code changes for automatic updates",
            "Cache system stores analysis results for performance",
            "Configuration manager provides settings access",
            "State manager tracks LLM integration state",
            "Error handler captures and reports failures",
            "Commands are registered for user interactions",
            "Event handlers connect UI actions to business logic"
          ],
          "keyFunctions": [
            {
              "name": "ExtensionComponents interface",
              "desc": "Defines the structure of all initialized extension components including analyzers, viewers, providers, and services",
              "inputs": "N/A - interface definition",
              "outputs": "Type definition for component container"
            }
          ],
          "dependencies": [
            "vscode",
            "../../analyzer",
            "../../insightGenerator",
            "../../llmFormatter",
            "../../fileWatcher",
            "../../insightsTreeView",
            "../../diagnosticsProvider",
            "../../cache",
            "../../llmIntegration",
            "../../productNavigator",
            "../../analysisViewer",
            "../../insightsViewer",
            "../../staticAnalysisViewer",
            "../../unitTestsNavigator",
            "../../config/configurationManager",
            "../../utils/errorHandler",
            "../../domain/services/fileWatcherService",
            "../../ui/reportsViewer",
            "../../reportsTreeProvider",
            "../../state/llmStateManager"
          ],
          "intent": "Separates extension activation and initialization logic from main extension entry point, providing centralized component bootstrapping, dependency injection, and lifecycle management for all extension features and UI elements",
          "rawContent": "```json\n{\n  \"purpose\": \"Initializes and configures all extension components when the VS Code extension activates, connecting UI elements, services, and event handlers\",\n  \"userVisibleActions\": [\n    \"Status bar displays extension status and information\",\n    \"Product Navigator view shows navigable product structure\",\n    \"Analysis Viewer displays code analysis results\",\n    \"Insights Viewer shows generated code insights\",\n    \"Static Analysis Viewer presents static analysis findings\",\n    \"Unit Tests Navigator displays test structure and results\",\n    \"Reports Viewer shows generated analysis reports\",\n    \"Diagnostics appear in Problems panel for code issues\",\n    \"File changes trigger automatic re-analysis\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extension activates and initializes all components on workspace open\",\n    \"Components are registered and connected to VS Code UI elements\",\n    \"Tree views are created for navigation and visualization\",\n    \"File watchers monitor code changes for automatic updates\",\n    \"Cache system stores analysis results for performance\",\n    \"Configuration manager provides settings access\",\n    \"State manager tracks LLM integration state\",\n    \"Error handler captures and reports failures\",\n    \"Commands are registered for user interactions\",\n    \"Event handlers connect UI actions to business logic\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"ExtensionComponents interface\",\n      \"desc\": \"Defines the structure of all initialized extension components including analyzers, viewers, providers, and services\",\n      \"inputs\": \"N/A - interface definition\",\n      \"outputs\": \"Type definition for component container\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"../../analyzer\",\n    \"../../insightGenerator\",\n    \"../../llmFormatter\",\n    \"../../fileWatcher\",\n    \"../../insightsTreeView\",\n    \"../../diagnosticsProvider\",\n    \"../../cache\",\n    \"../../llmIntegration\",\n    \"../../productNavigator\",\n    \"../../analysisViewer\",\n    \"../../insightsViewer\",\n    \"../../staticAnalysisViewer\",\n    \"../../unitTestsNavigator\",\n    \"../../config/configurationManager\",\n    \"../../utils/errorHandler\",\n    \"../../domain/services/fileWatcherService\",\n    \"../../ui/reportsViewer\",\n    \"../../reportsTreeProvider\",\n    \"../../state/llmStateManager\"\n  ],\n  \"intent\": \"Separates extension activation and initialization logic from main extension entry point, providing centralized component bootstrapping, dependency injection, and lifecycle management for all extension features and UI elements\"\n}\n```"
        }
      ],
      "commands": [
        {
          "command": "analyze-workspace",
          "description": "Analyze entire workspace for code insights and patterns"
        },
        {
          "command": "analyze-file",
          "description": "Analyze currently open file for insights"
        },
        {
          "command": "copy-all-insights",
          "description": "Copy all generated insights to clipboard"
        },
        {
          "command": "copy-file-insights",
          "description": "Copy insights for a specific file to clipboard"
        },
        {
          "command": "copy-insight",
          "description": "Copy a single insight to clipboard"
        },
        {
          "command": "clear-cache",
          "description": "Clear cached analysis data"
        },
        {
          "command": "clear-all-data",
          "description": "Clear all extension data and reset state"
        },
        {
          "command": "open-settings",
          "description": "Open extension settings configuration"
        },
        {
          "command": "view-analysis-report",
          "description": "View latest analysis report"
        },
        {
          "command": "view-test-report",
          "description": "View latest unit test report"
        },
        {
          "command": "switch-llm-provider",
          "description": "Switch between different LLM providers"
        },
        {
          "command": "copy-menu-structure",
          "description": "Copy menu structure to clipboard"
        },
        {
          "command": "view-llm-status",
          "description": "View current LLM provider status and configuration"
        },
        {
          "command": "navigate-to-product-item",
          "description": "Navigate to a specific product feature or component"
        },
        {
          "command": "navigate-to-analysis-result",
          "description": "Navigate to a specific analysis result location"
        },
        {
          "command": "view-product-details",
          "description": "View detailed information about a product item"
        },
        {
          "command": "view-insight-details",
          "description": "View detailed information about a code insight"
        },
        {
          "command": "view-test-details",
          "description": "View detailed information about a unit test"
        }
      ]
    },
    {
      "module": "src/domain/formatters",
      "moduleType": "other",
      "capabilities": [
        "Transform product documentation and code analysis into structured Markdown format",
        "Generate comprehensive documentation with multiple user perspectives (GUI, CLI, API)",
        "Organize file analysis results by component categories (UI, Business Logic, Data, Infrastructure)",
        "Format LLM-generated insights with behavioral summaries, feature lists, and usage examples",
        "Create timestamped documentation exports showing generation date and time",
        "Display warning messages for missing or incomplete documentation sections",
        "Structure file classifications with clear purpose descriptions"
      ],
      "summary": "The formatters module provides documentation generation and formatting capabilities that convert raw product analysis and code insights into polished, user-ready Markdown documents. It serves as the presentation layer for all documentation output, ensuring consistent formatting and organization across different documentation types.\n\nUsers can generate comprehensive product documentation that includes feature overviews, behavioral summaries, and usage examples from multiple perspectives (GUI, CLI, and API). The module automatically organizes file analysis results into logical categories, making it easy to understand codebase structure and component purposes. All generated documentation includes timestamps and proper sectioning, with clear warnings when information is missing or incomplete.\n\nThe primary workflow involves taking structured data from code analysis and LLM insights, then transforming it into readable, exportable Markdown documents. This enables users to view, share, and export documentation that accurately represents their product's capabilities, architecture, and usage patterns in a standardized format suitable for both human consumption and further processing.",
      "files": [
        {
          "file": "src/domain/formatters/documentationFormatter.ts",
          "role": "Core Logic",
          "purpose": "Formats product documentation and code analysis insights into structured Markdown documents for user consumption and export.",
          "userVisibleActions": [
            "View product documentation formatted as Markdown with overview, features, and user perspectives",
            "See file analysis results organized by component categories (UI, Business Logic, Data, Infrastructure)",
            "Read LLM insights formatted with behavioral summaries, feature lists, and usage examples",
            "Export documentation with timestamps showing generation date and time",
            "Access documentation sections for GUI, CLI, and API perspectives",
            "View file classifications and their purposes in structured sections",
            "See warning messages for empty or missing documentation sections"
          ],
          "developerVisibleActions": [
            "Call formatEnhancedDocsAsMarkdown() to convert product documentation objects into Markdown format",
            "Call formatFileAnalysisAsMarkdown() to convert file analysis results into categorized Markdown sections",
            "Call formatInsightsAsMarkdown() to convert LLM insights into comprehensive Markdown documentation",
            "Receive formatted Markdown strings ready for file writing or display",
            "Get automatic timestamp injection in UTC and local time formats",
            "Handle empty sections gracefully with warning messages",
            "Process nested data structures (arrays, objects) into bulleted lists and sections"
          ],
          "keyFunctions": [
            {
              "name": "formatEnhancedDocsAsMarkdown",
              "desc": "Converts enhanced product documentation object into formatted Markdown with sections for overview, features, user perspectives, tech stack, architecture, and file structures",
              "inputs": "EnhancedProductDocumentation object containing overview, features, user perspectives, tech stack, architecture, and file analysis",
              "outputs": "Formatted Markdown string with hierarchical sections and timestamps"
            },
            {
              "name": "formatFileAnalysisAsMarkdown",
              "desc": "Formats file analysis results into categorized Markdown sections (UI Components, Business Logic, Data Layer, Infrastructure) with file paths and purposes",
              "inputs": "File analysis results with categorized files (uiComponents, businessLogic, dataLayer, infrastructure)",
              "outputs": "Markdown string with categorized file listings or warning message if empty"
            },
            {
              "name": "formatInsightsAsMarkdown",
              "desc": "Converts LLM analysis insights into comprehensive Markdown documentation including behavioral summary, key features, user interactions, technical details, and usage examples",
              "inputs": "LLMInsights object containing behavioral summary, features, interactions, technical details, and examples",
              "outputs": "Formatted Markdown string with all insight sections organized hierarchically"
            }
          ],
          "dependencies": [
            "../../fileDocumentation (EnhancedProductDocumentation type)",
            "../../llmService (LLMInsights type)"
          ],
          "intent": "Separates documentation formatting logic from core analysis code, providing a dedicated service to transform structured data objects into human-readable Markdown documents that can be exported, displayed, or version-controlled.",
          "rawContent": "```json\n{\n  \"purpose\": \"Formats product documentation and code analysis insights into structured Markdown documents for user consumption and export.\",\n  \"userVisibleActions\": [\n    \"View product documentation formatted as Markdown with overview, features, and user perspectives\",\n    \"See file analysis results organized by component categories (UI, Business Logic, Data, Infrastructure)\",\n    \"Read LLM insights formatted with behavioral summaries, feature lists, and usage examples\",\n    \"Export documentation with timestamps showing generation date and time\",\n    \"Access documentation sections for GUI, CLI, and API perspectives\",\n    \"View file classifications and their purposes in structured sections\",\n    \"See warning messages for empty or missing documentation sections\"\n  ],\n  \"developerVisibleActions\": [\n    \"Call formatEnhancedDocsAsMarkdown() to convert product documentation objects into Markdown format\",\n    \"Call formatFileAnalysisAsMarkdown() to convert file analysis results into categorized Markdown sections\",\n    \"Call formatInsightsAsMarkdown() to convert LLM insights into comprehensive Markdown documentation\",\n    \"Receive formatted Markdown strings ready for file writing or display\",\n    \"Get automatic timestamp injection in UTC and local time formats\",\n    \"Handle empty sections gracefully with warning messages\",\n    \"Process nested data structures (arrays, objects) into bulleted lists and sections\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"formatEnhancedDocsAsMarkdown\",\n      \"desc\": \"Converts enhanced product documentation object into formatted Markdown with sections for overview, features, user perspectives, tech stack, architecture, and file structures\",\n      \"inputs\": \"EnhancedProductDocumentation object containing overview, features, user perspectives, tech stack, architecture, and file analysis\",\n      \"outputs\": \"Formatted Markdown string with hierarchical sections and timestamps\"\n    },\n    {\n      \"name\": \"formatFileAnalysisAsMarkdown\",\n      \"desc\": \"Formats file analysis results into categorized Markdown sections (UI Components, Business Logic, Data Layer, Infrastructure) with file paths and purposes\",\n      \"inputs\": \"File analysis results with categorized files (uiComponents, businessLogic, dataLayer, infrastructure)\",\n      \"outputs\": \"Markdown string with categorized file listings or warning message if empty\"\n    },\n    {\n      \"name\": \"formatInsightsAsMarkdown\",\n      \"desc\": \"Converts LLM analysis insights into comprehensive Markdown documentation including behavioral summary, key features, user interactions, technical details, and usage examples\",\n      \"inputs\": \"LLMInsights object containing behavioral summary, features, interactions, technical details, and examples\",\n      \"outputs\": \"Formatted Markdown string with all insight sections organized hierarchically\"\n    }\n  ],\n  \"dependencies\": [\n    \"../../fileDocumentation (EnhancedProductDocumentation type)\",\n    \"../../llmService (LLMInsights type)\"\n  ],\n  \"intent\": \"Separates documentation formatting logic from core analysis code, providing a dedicated service to transform structured data objects into human-readable Markdown documents that can be exported, displayed, or version-controlled.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/domain/handlers",
      "moduleType": "other",
      "capabilities": [
        "Navigate to source code files from product navigator items",
        "Jump to specific function definitions with automatic highlighting",
        "Navigate to API endpoint handler implementations",
        "Jump to function usage locations and references",
        "View function details including signatures, descriptions, and metadata",
        "Open analysis results with syntax-highlighted code context",
        "Receive clear error messages when navigation targets are unavailable"
      ],
      "summary": "The handlers module provides comprehensive code navigation capabilities that enable users to explore their workspace through interactive navigation flows. Users can click on items in the product navigator or analysis viewer to instantly jump to the corresponding source code, whether it's a file, function, API endpoint, or reference location.\n\nWhen navigating to functions, the module automatically opens the file, positions the cursor at the function definition, and highlights the relevant code section. Users can view detailed function information in a quick pick menu that displays signatures, descriptions, and metadata before navigating. For API endpoints, the module intelligently locates and opens the handler implementation. The module also supports navigating from analysis results, displaying code context with proper syntax highlighting.\n\nThroughout all navigation workflows, the module provides helpful feedback through error messages when files cannot be opened and warnings when navigation targets are not found, ensuring users always understand the outcome of their navigation attempts.",
      "files": [
        {
          "file": "src/domain/handlers/navigationHandler.ts",
          "role": "Core Logic",
          "purpose": "Handles navigation to files, functions, and endpoints within the workspace when users interact with the product navigator and analysis viewer.",
          "userVisibleActions": [
            "Opens source code files in the editor when clicking on file items",
            "Navigates to specific functions in files and highlights the function definition",
            "Shows error messages when files cannot be opened",
            "Displays function details in a quick pick menu with signature, description, and metadata",
            "Navigates to endpoint handlers when clicking on API endpoints",
            "Navigates to function usage locations when clicking on references",
            "Opens analysis items showing code context with syntax highlighting",
            "Shows warnings when navigation targets cannot be found"
          ],
          "developerVisibleActions": [
            "Converts relative file paths to absolute paths using workspace root",
            "Opens VS Code text documents programmatically",
            "Positions cursor at specific line numbers for functions and code locations",
            "Searches through document content to find function definitions by name",
            "Creates selection ranges to highlight code sections",
            "Displays formatted information panels using VS Code quick pick interface",
            "Handles multiple navigation types: files, functions, endpoints, and analysis items",
            "Falls back to line numbers when function names cannot be located in files"
          ],
          "keyFunctions": [
            {
              "name": "navigateToProductItem",
              "desc": "Opens files or navigates to functions/endpoints from product navigator items",
              "inputs": "ProductNavItem containing file path, function name, and line number",
              "outputs": "Promise<void> - opens editor at target location"
            },
            {
              "name": "navigateToAnalysisItem",
              "desc": "Opens files and shows code context for analysis viewer items",
              "inputs": "AnalysisItem with file path and line number information",
              "outputs": "Promise<void> - displays code in editor with selection"
            },
            {
              "name": "showItemDetails",
              "desc": "Displays detailed information about functions, endpoints, or entry points in a menu",
              "inputs": "ProductNavItem or EntryPoint with metadata like signature, description, parameters",
              "outputs": "Promise<void> - shows quick pick panel with formatted details"
            }
          ],
          "dependencies": [
            "vscode",
            "path",
            "ProductNavItem from productNavigator",
            "AnalysisItem from analysisViewer",
            "EntryPoint from analyzer"
          ],
          "intent": "This file exists to centralize all code navigation logic for the extension, separating navigation concerns from the main extension file. It solves the problem of providing consistent, user-friendly navigation across different types of code items (files, functions, endpoints, analysis results) while handling edge cases like missing files, relative paths, and function location resolution.",
          "rawContent": "```json\n{\n  \"purpose\": \"Handles navigation to files, functions, and endpoints within the workspace when users interact with the product navigator and analysis viewer.\",\n  \"userVisibleActions\": [\n    \"Opens source code files in the editor when clicking on file items\",\n    \"Navigates to specific functions in files and highlights the function definition\",\n    \"Shows error messages when files cannot be opened\",\n    \"Displays function details in a quick pick menu with signature, description, and metadata\",\n    \"Navigates to endpoint handlers when clicking on API endpoints\",\n    \"Navigates to function usage locations when clicking on references\",\n    \"Opens analysis items showing code context with syntax highlighting\",\n    \"Shows warnings when navigation targets cannot be found\"\n  ],\n  \"developerVisibleActions\": [\n    \"Converts relative file paths to absolute paths using workspace root\",\n    \"Opens VS Code text documents programmatically\",\n    \"Positions cursor at specific line numbers for functions and code locations\",\n    \"Searches through document content to find function definitions by name\",\n    \"Creates selection ranges to highlight code sections\",\n    \"Displays formatted information panels using VS Code quick pick interface\",\n    \"Handles multiple navigation types: files, functions, endpoints, and analysis items\",\n    \"Falls back to line numbers when function names cannot be located in files\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"navigateToProductItem\",\n      \"desc\": \"Opens files or navigates to functions/endpoints from product navigator items\",\n      \"inputs\": \"ProductNavItem containing file path, function name, and line number\",\n      \"outputs\": \"Promise<void> - opens editor at target location\"\n    },\n    {\n      \"name\": \"navigateToAnalysisItem\",\n      \"desc\": \"Opens files and shows code context for analysis viewer items\",\n      \"inputs\": \"AnalysisItem with file path and line number information\",\n      \"outputs\": \"Promise<void> - displays code in editor with selection\"\n    },\n    {\n      \"name\": \"showItemDetails\",\n      \"desc\": \"Displays detailed information about functions, endpoints, or entry points in a menu\",\n      \"inputs\": \"ProductNavItem or EntryPoint with metadata like signature, description, parameters\",\n      \"outputs\": \"Promise<void> - shows quick pick panel with formatted details\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"ProductNavItem from productNavigator\",\n    \"AnalysisItem from analysisViewer\",\n    \"EntryPoint from analyzer\"\n  ],\n  \"intent\": \"This file exists to centralize all code navigation logic for the extension, separating navigation concerns from the main extension file. It solves the problem of providing consistent, user-friendly navigation across different types of code items (files, functions, endpoints, analysis results) while handling edge cases like missing files, relative paths, and function location resolution.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/domain/prompts",
      "moduleType": "other",
      "capabilities": [
        "Generate structured prompts for LLM-based architecture analysis that produce comprehensive project documentation",
        "Create prompts for extracting user-facing product features and capabilities from codebases",
        "Build comprehensive test plan generation prompts that produce testing strategies for code files",
        "Generate code analysis prompts that explain file functionality, dependencies, and behavior",
        "Produce module-level summary prompts that consolidate related files into cohesive documentation",
        "Create detailed refactoring analysis prompts with extraction plans and migration steps",
        "Generate function-level analysis prompts that examine responsibilities, dependencies, and call relationships"
      ],
      "summary": "The prompts module provides centralized prompt construction services for all LLM-based code analysis and documentation tasks. It eliminates prompt duplication by offering specialized builders that generate structured, consistent prompts for different analysis purposes including architecture documentation, product feature extraction, test planning, and code understanding.\n\nUsers can leverage this module to generate comprehensive refactoring reports that include detailed extraction plans, step-by-step migration instructions, and before-and-after code examples. The module supports both high-level architecture analysis workflows and granular function-level analysis, providing detailed insights into code responsibilities, dependencies, and relationships.\n\nThe module serves as the foundation for automated documentation generation, enabling users to transform raw code into structured documentation, test plans, and refactoring strategies through carefully crafted LLM prompts that ensure consistent, high-quality output across all analysis tasks.",
      "files": [
        {
          "file": "src/domain/prompts/promptBuilder.ts",
          "role": "Core Logic",
          "purpose": "Provides centralized prompt construction services for all LLM analysis tasks, eliminating duplication by building structured prompts for architecture analysis, documentation, test generation, and code understanding.",
          "userVisibleActions": [
            "Generates architecture analysis prompts that produce structured project architecture documentation",
            "Creates product documentation prompts that extract user-facing features and capabilities",
            "Builds test plan prompts that generate comprehensive test strategies for code files",
            "Produces code analysis prompts that explain file functionality and behavior",
            "Generates module summary prompts that consolidate related files into cohesive documentation"
          ],
          "developerVisibleActions": [
            "Developer calls buildArchitecturePrompt to get a prompt for analyzing project structure and patterns",
            "Developer calls buildProductDocsPrompt to generate prompts for extracting product documentation",
            "Developer calls buildProductPurposePrompt to create prompts for understanding product purpose and value",
            "Developer calls buildFileAnalysisPrompt to generate prompts for analyzing individual files",
            "Developer calls buildModuleRollupPrompt to create prompts for summarizing module-level functionality",
            "Developer calls buildProductLevelPrompt to generate comprehensive product-wide documentation prompts",
            "Developer calls buildPerFileTestPlanPrompt to create prompts for test planning per file",
            "Developer calls buildTestCodeGenerationPrompt to generate actual test code from test plans",
            "Receives AnalysisContext, CodeAnalysis, and FileInfo objects as input",
            "Returns formatted string prompts ready for LLM consumption",
            "Incorporates existing code analysis, file metadata, and project structure into prompts"
          ],
          "keyFunctions": [
            {
              "name": "buildArchitecturePrompt",
              "desc": "Constructs a prompt for LLM to analyze project architecture, patterns, and structure",
              "inputs": "context: AnalysisContext, optional codeAnalysis, productDocs, productPurposeAnalysis, fileAccessHelper",
              "outputs": "formatted prompt string for architecture analysis"
            },
            {
              "name": "buildProductDocsPrompt",
              "desc": "Creates a prompt for extracting user-facing product documentation and features",
              "inputs": "context: AnalysisContext",
              "outputs": "formatted prompt string for product documentation extraction"
            },
            {
              "name": "buildProductPurposePrompt",
              "desc": "Generates a prompt for understanding product purpose, value proposition, and target users",
              "inputs": "productDocs: EnhancedProductDocumentation, context: AnalysisContext",
              "outputs": "formatted prompt string for product purpose analysis"
            },
            {
              "name": "buildFileAnalysisPrompt",
              "desc": "Creates a prompt for analyzing individual file functionality and behavior",
              "inputs": "file: FileInfo, content: string, role: string",
              "outputs": "formatted prompt string for file analysis"
            },
            {
              "name": "buildModuleRollupPrompt",
              "desc": "Constructs a prompt for rolling up multiple file summaries into module-level documentation",
              "inputs": "modulePath: string, moduleType: string, files: FileSummary[]",
              "outputs": "formatted prompt string for module summary generation"
            },
            {
              "name": "buildProductLevelPrompt",
              "desc": "Generates a comprehensive prompt for product-wide documentation synthesis",
              "inputs": "fileSummaries: FileSummary[], moduleSummaries: ModuleSummary[], analysis: CodeAnalysis, fileAccessHelper: FileAccessHelper",
              "outputs": "formatted prompt string for product-level documentation"
            },
            {
              "name": "buildPerFileTestPlanPrompt",
              "desc": "Creates a prompt for generating test plans for specific files and functions",
              "inputs": "filePath, fileContent, functionMetadata, existingTests, language, testFramework, optional projectSummary",
              "outputs": "formatted prompt string for test plan generation"
            },
            {
              "name": "buildTestCodeGenerationPrompt",
              "desc": "Constructs a prompt for generating actual test code from test plan items",
              "inputs": "testPlanItem, sourceCode, functionCode, language, testFramework",
              "outputs": "formatted prompt string for test code generation"
            }
          ],
          "dependencies": [
            "../../llmService",
            "../../analyzer",
            "../../fileDocumentation",
            "../../fileAccessHelper"
          ],
          "intent": "This file exists to solve the problem of prompt construction duplication across the codebase. By centralizing all LLM prompt building logic in one place, it ensures consistency in how prompts are structured, eliminates code duplication, and makes it easier to maintain and improve prompt quality for various analysis tasks including architecture analysis, documentation extraction, and test generation.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides centralized prompt construction services for all LLM analysis tasks, eliminating duplication by building structured prompts for architecture analysis, documentation, test generation, and code understanding.\",\n  \"userVisibleActions\": [\n    \"Generates architecture analysis prompts that produce structured project architecture documentation\",\n    \"Creates product documentation prompts that extract user-facing features and capabilities\",\n    \"Builds test plan prompts that generate comprehensive test strategies for code files\",\n    \"Produces code analysis prompts that explain file functionality and behavior\",\n    \"Generates module summary prompts that consolidate related files into cohesive documentation\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer calls buildArchitecturePrompt to get a prompt for analyzing project structure and patterns\",\n    \"Developer calls buildProductDocsPrompt to generate prompts for extracting product documentation\",\n    \"Developer calls buildProductPurposePrompt to create prompts for understanding product purpose and value\",\n    \"Developer calls buildFileAnalysisPrompt to generate prompts for analyzing individual files\",\n    \"Developer calls buildModuleRollupPrompt to create prompts for summarizing module-level functionality\",\n    \"Developer calls buildProductLevelPrompt to generate comprehensive product-wide documentation prompts\",\n    \"Developer calls buildPerFileTestPlanPrompt to create prompts for test planning per file\",\n    \"Developer calls buildTestCodeGenerationPrompt to generate actual test code from test plans\",\n    \"Receives AnalysisContext, CodeAnalysis, and FileInfo objects as input\",\n    \"Returns formatted string prompts ready for LLM consumption\",\n    \"Incorporates existing code analysis, file metadata, and project structure into prompts\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"buildArchitecturePrompt\",\n      \"desc\": \"Constructs a prompt for LLM to analyze project architecture, patterns, and structure\",\n      \"inputs\": \"context: AnalysisContext, optional codeAnalysis, productDocs, productPurposeAnalysis, fileAccessHelper\",\n      \"outputs\": \"formatted prompt string for architecture analysis\"\n    },\n    {\n      \"name\": \"buildProductDocsPrompt\",\n      \"desc\": \"Creates a prompt for extracting user-facing product documentation and features\",\n      \"inputs\": \"context: AnalysisContext\",\n      \"outputs\": \"formatted prompt string for product documentation extraction\"\n    },\n    {\n      \"name\": \"buildProductPurposePrompt\",\n      \"desc\": \"Generates a prompt for understanding product purpose, value proposition, and target users\",\n      \"inputs\": \"productDocs: EnhancedProductDocumentation, context: AnalysisContext\",\n      \"outputs\": \"formatted prompt string for product purpose analysis\"\n    },\n    {\n      \"name\": \"buildFileAnalysisPrompt\",\n      \"desc\": \"Creates a prompt for analyzing individual file functionality and behavior\",\n      \"inputs\": \"file: FileInfo, content: string, role: string\",\n      \"outputs\": \"formatted prompt string for file analysis\"\n    },\n    {\n      \"name\": \"buildModuleRollupPrompt\",\n      \"desc\": \"Constructs a prompt for rolling up multiple file summaries into module-level documentation\",\n      \"inputs\": \"modulePath: string, moduleType: string, files: FileSummary[]\",\n      \"outputs\": \"formatted prompt string for module summary generation\"\n    },\n    {\n      \"name\": \"buildProductLevelPrompt\",\n      \"desc\": \"Generates a comprehensive prompt for product-wide documentation synthesis\",\n      \"inputs\": \"fileSummaries: FileSummary[], moduleSummaries: ModuleSummary[], analysis: CodeAnalysis, fileAccessHelper: FileAccessHelper\",\n      \"outputs\": \"formatted prompt string for product-level documentation\"\n    },\n    {\n      \"name\": \"buildPerFileTestPlanPrompt\",\n      \"desc\": \"Creates a prompt for generating test plans for specific files and functions\",\n      \"inputs\": \"filePath, fileContent, functionMetadata, existingTests, language, testFramework, optional projectSummary\",\n      \"outputs\": \"formatted prompt string for test plan generation\"\n    },\n    {\n      \"name\": \"buildTestCodeGenerationPrompt\",\n      \"desc\": \"Constructs a prompt for generating actual test code from test plan items\",\n      \"inputs\": \"testPlanItem, sourceCode, functionCode, language, testFramework\",\n      \"outputs\": \"formatted prompt string for test code generation\"\n    }\n  ],\n  \"dependencies\": [\n    \"../../llmService\",\n    \"../../analyzer\",\n    \"../../fileDocumentation\",\n    \"../../fileAccessHelper\"\n  ],\n  \"intent\": \"This file exists to solve the problem of prompt construction duplication across the codebase. By centralizing all LLM prompt building logic in one place, it ensures consistency in how prompts are structured, eliminates code duplication, and makes it easier to maintain and improve prompt quality for various analysis tasks including architecture analysis, documentation extraction, and test generation.\"\n}\n```"
        },
        {
          "file": "src/domain/prompts/refactoringPromptBuilder.ts",
          "role": "Core Logic",
          "purpose": "Generates detailed, prescriptive prompts for LLM-based code refactoring analysis with extraction plans and migration steps.",
          "userVisibleActions": [
            "Receives comprehensive refactoring reports that explain what code should be extracted and why",
            "Gets detailed step-by-step migration instructions for code reorganization",
            "Views before-and-after code examples showing proposed refactoring changes",
            "Sees function-level analysis including responsibilities, dependencies, and call relationships"
          ],
          "developerVisibleActions": [
            "Creates structured prompts that guide LLMs to generate refactoring recommendations",
            "Combines code analysis, product documentation, and architecture insights into refactoring instructions",
            "Builds extraction plans that specify which functions should move to which files",
            "Generates function analysis reports showing dependencies, dependents, and responsibilities",
            "Provides detailed requirements for code extraction with migration steps and examples"
          ],
          "keyFunctions": [
            {
              "name": "buildDetailedRefactoringPrompt",
              "desc": "Constructs a comprehensive prompt for generating refactoring reports with function analysis and extraction plans",
              "inputs": "AnalysisContext, CodeAnalysis, optional EnhancedProductDocumentation, optional LLMInsights, optional FunctionAnalysis array",
              "outputs": "Complete prompt string for LLM refactoring analysis"
            },
            {
              "name": "buildBasePrompt",
              "desc": "Creates the foundational prompt structure combining context, code analysis, and documentation",
              "inputs": "AnalysisContext, CodeAnalysis, optional ProductDocumentation, optional ArchitectureInsights",
              "outputs": "Base prompt string"
            },
            {
              "name": "buildFunctionAnalysisSection",
              "desc": "Generates detailed analysis section for individual functions showing their relationships and responsibilities",
              "inputs": "Array of FunctionAnalysis objects",
              "outputs": "Formatted function analysis text"
            },
            {
              "name": "buildExtractionRequirementsSection",
              "desc": "Creates instructions for how to structure code extraction recommendations",
              "inputs": "None (defines format requirements)",
              "outputs": "Extraction requirements text"
            }
          ],
          "dependencies": [
            "../../analyzer (CodeAnalysis, FileInfo, FunctionMetadata)",
            "../../llmService (AnalysisContext, LLMInsights)",
            "../../fileDocumentation (EnhancedProductDocumentation)"
          ],
          "intent": "This file exists to standardize and enhance how refactoring instructions are communicated to LLMs, ensuring they generate actionable, detailed refactoring reports with concrete extraction plans, migration steps, and code examples rather than vague suggestions.",
          "rawContent": "```json\n{\n  \"purpose\": \"Generates detailed, prescriptive prompts for LLM-based code refactoring analysis with extraction plans and migration steps.\",\n  \"userVisibleActions\": [\n    \"Receives comprehensive refactoring reports that explain what code should be extracted and why\",\n    \"Gets detailed step-by-step migration instructions for code reorganization\",\n    \"Views before-and-after code examples showing proposed refactoring changes\",\n    \"Sees function-level analysis including responsibilities, dependencies, and call relationships\"\n  ],\n  \"developerVisibleActions\": [\n    \"Creates structured prompts that guide LLMs to generate refactoring recommendations\",\n    \"Combines code analysis, product documentation, and architecture insights into refactoring instructions\",\n    \"Builds extraction plans that specify which functions should move to which files\",\n    \"Generates function analysis reports showing dependencies, dependents, and responsibilities\",\n    \"Provides detailed requirements for code extraction with migration steps and examples\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"buildDetailedRefactoringPrompt\",\n      \"desc\": \"Constructs a comprehensive prompt for generating refactoring reports with function analysis and extraction plans\",\n      \"inputs\": \"AnalysisContext, CodeAnalysis, optional EnhancedProductDocumentation, optional LLMInsights, optional FunctionAnalysis array\",\n      \"outputs\": \"Complete prompt string for LLM refactoring analysis\"\n    },\n    {\n      \"name\": \"buildBasePrompt\",\n      \"desc\": \"Creates the foundational prompt structure combining context, code analysis, and documentation\",\n      \"inputs\": \"AnalysisContext, CodeAnalysis, optional ProductDocumentation, optional ArchitectureInsights\",\n      \"outputs\": \"Base prompt string\"\n    },\n    {\n      \"name\": \"buildFunctionAnalysisSection\",\n      \"desc\": \"Generates detailed analysis section for individual functions showing their relationships and responsibilities\",\n      \"inputs\": \"Array of FunctionAnalysis objects\",\n      \"outputs\": \"Formatted function analysis text\"\n    },\n    {\n      \"name\": \"buildExtractionRequirementsSection\",\n      \"desc\": \"Creates instructions for how to structure code extraction recommendations\",\n      \"inputs\": \"None (defines format requirements)\",\n      \"outputs\": \"Extraction requirements text\"\n    }\n  ],\n  \"dependencies\": [\n    \"../../analyzer (CodeAnalysis, FileInfo, FunctionMetadata)\",\n    \"../../llmService (AnalysisContext, LLMInsights)\",\n    \"../../fileDocumentation (EnhancedProductDocumentation)\"\n  ],\n  \"intent\": \"This file exists to standardize and enhance how refactoring instructions are communicated to LLMs, ensuring they generate actionable, detailed refactoring reports with concrete extraction plans, migration steps, and code examples rather than vague suggestions.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/domain/services",
      "moduleType": "other",
      "capabilities": [
        "Automatically monitors and responds to file system changes across the workspace without requiring manual refresh",
        "Performs iterative analysis by making multiple rounds of file access and code searches until sufficient context is gathered",
        "Automatically detects test framework configuration and identifies missing dependencies or setup requirements",
        "Updates UI views and displays in real-time when relevant files are created, modified, or deleted",
        "Retrieves additional file content and grep search results automatically during analysis workflows",
        "Reports test framework readiness including TypeScript support and configuration file status"
      ],
      "summary": "The services module provides three core automation capabilities that enhance the developer experience. It monitors the workspace file system to detect changes in real-time, ensuring that views and displays stay synchronized with the current state of files without manual intervention. When users save documents or add new files, the system automatically responds and updates relevant UI components.\n\nThe module enables intelligent analysis workflows where the system iteratively requests additional files and performs code searches across multiple rounds until it has gathered sufficient context to complete tasks. Users see progress updates as the analysis proceeds, and the system automatically incorporates grep search results and file content as needed. This creates a seamless experience where complex analysis tasks are handled through multiple automated iterations.\n\nFor testing workflows, the module automatically detects which test framework is in use (Jest, Mocha, Vitest, or Pytest) and validates the configuration setup. It identifies missing dependencies, checks for proper TypeScript support, and reports whether test setup files are present. This ensures that generated tests will work correctly without requiring manual configuration by the user.",
      "files": [
        {
          "file": "src/domain/services/fileWatcherService.ts",
          "role": "Core Logic",
          "purpose": "Provides centralized file system watching capabilities to monitor and respond to file changes, creations, and deletions across the workspace",
          "userVisibleActions": [
            "Automatically detects when files are created, modified, or deleted in the workspace",
            "Responds to changes in specific file types (e.g., .feature files, .insights files) without manual refresh",
            "Updates UI views and displays when relevant files change",
            "Triggers automatic updates when saving documents"
          ],
          "developerVisibleActions": [
            "Register file watchers for specific patterns (e.g., '**/*.feature', '**/*.insights')",
            "Handle file creation, change, and deletion events with custom callbacks",
            "Watch for document save events across all text documents",
            "Filter file changes using ignore patterns to exclude unwanted files",
            "Unregister watchers when no longer needed to prevent memory leaks",
            "Dispose all watchers when extension deactivates"
          ],
          "keyFunctions": [
            {
              "name": "watch",
              "desc": "Creates a file system watcher for a specific pattern and registers a handler for file changes",
              "inputs": "id (string), pattern (glob pattern or RelativePattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete)",
              "outputs": "Disposable object to stop watching"
            },
            {
              "name": "unwatch",
              "desc": "Removes a specific file watcher registration by its unique ID",
              "inputs": "id (string)",
              "outputs": "void"
            },
            {
              "name": "onDocumentSave",
              "desc": "Registers a handler to be called whenever any document is saved in the workspace",
              "inputs": "handler (callback function receiving TextDocument)",
              "outputs": "Disposable object to unregister the handler"
            },
            {
              "name": "getMatchingHandlers",
              "desc": "Finds all registered handlers that should process a given file URI",
              "inputs": "uri (file URI), patternKey (pattern identifier)",
              "outputs": "Set of PatternHandler objects"
            },
            {
              "name": "shouldIgnoreFile",
              "desc": "Determines if a file should be ignored based on configured ignore patterns",
              "inputs": "filePath (string), ignorePatterns (array of glob patterns)",
              "outputs": "boolean indicating whether to ignore the file"
            },
            {
              "name": "dispose",
              "desc": "Cleans up all watchers and handlers, releasing system resources",
              "inputs": "none",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "vscode",
            "path",
            "fs"
          ],
          "intent": "This file consolidates file watching functionality that was previously duplicated across multiple files (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It provides a single, reusable service for monitoring file system changes, reducing code duplication and ensuring consistent file watching behavior throughout the extension. The service allows different parts of the extension to react to file changes without each implementing their own watcher logic, and it handles cleanup to prevent resource leaks.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides centralized file system watching capabilities to monitor and respond to file changes, creations, and deletions across the workspace\",\n  \"userVisibleActions\": [\n    \"Automatically detects when files are created, modified, or deleted in the workspace\",\n    \"Responds to changes in specific file types (e.g., .feature files, .insights files) without manual refresh\",\n    \"Updates UI views and displays when relevant files change\",\n    \"Triggers automatic updates when saving documents\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register file watchers for specific patterns (e.g., '**/*.feature', '**/*.insights')\",\n    \"Handle file creation, change, and deletion events with custom callbacks\",\n    \"Watch for document save events across all text documents\",\n    \"Filter file changes using ignore patterns to exclude unwanted files\",\n    \"Unregister watchers when no longer needed to prevent memory leaks\",\n    \"Dispose all watchers when extension deactivates\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"watch\",\n      \"desc\": \"Creates a file system watcher for a specific pattern and registers a handler for file changes\",\n      \"inputs\": \"id (string), pattern (glob pattern or RelativePattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete)\",\n      \"outputs\": \"Disposable object to stop watching\"\n    },\n    {\n      \"name\": \"unwatch\",\n      \"desc\": \"Removes a specific file watcher registration by its unique ID\",\n      \"inputs\": \"id (string)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"onDocumentSave\",\n      \"desc\": \"Registers a handler to be called whenever any document is saved in the workspace\",\n      \"inputs\": \"handler (callback function receiving TextDocument)\",\n      \"outputs\": \"Disposable object to unregister the handler\"\n    },\n    {\n      \"name\": \"getMatchingHandlers\",\n      \"desc\": \"Finds all registered handlers that should process a given file URI\",\n      \"inputs\": \"uri (file URI), patternKey (pattern identifier)\",\n      \"outputs\": \"Set of PatternHandler objects\"\n    },\n    {\n      \"name\": \"shouldIgnoreFile\",\n      \"desc\": \"Determines if a file should be ignored based on configured ignore patterns\",\n      \"inputs\": \"filePath (string), ignorePatterns (array of glob patterns)\",\n      \"outputs\": \"boolean indicating whether to ignore the file\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all watchers and handlers, releasing system resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"This file consolidates file watching functionality that was previously duplicated across multiple files (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It provides a single, reusable service for monitoring file system changes, reducing code duplication and ensuring consistent file watching behavior throughout the extension. The service allows different parts of the extension to react to file changes without each implementing their own watcher logic, and it handles cleanup to prevent resource leaks.\"\n}\n```"
        },
        {
          "file": "src/domain/services/incrementalAnalysisService.ts",
          "role": "Core Logic",
          "purpose": "Handles iterative analysis where an LLM makes multiple requests for files or code searches until it has enough information to complete its task",
          "userVisibleActions": [
            "User receives analysis results that may require multiple rounds of file access and code searching",
            "User sees progress updates as the system iterates through analysis rounds",
            "User experiences automatic retrieval of additional file content when the LLM needs more context",
            "User gets grep search results automatically incorporated into analysis when patterns need to be found"
          ],
          "developerVisibleActions": [
            "Developer triggers incremental analysis that automatically handles LLM requests for more information",
            "Developer receives iteration callbacks showing progress through analysis rounds",
            "Developer gets structured results containing the final analysis, iteration count, and all requests made",
            "Developer can configure maximum iterations to prevent infinite loops",
            "Developer sees file read and grep search requests processed automatically up to 5 requests per iteration",
            "Developer receives conversation messages with assistant responses and user-provided additional information"
          ],
          "keyFunctions": [
            {
              "name": "processRequests",
              "desc": "Processes LLM requests for files and grep searches, returning formatted additional information and updated conversation messages",
              "inputs": "requests: LLMRequest[], currentResult: any, messages: conversation array",
              "outputs": "ProcessRequestsResult with additionalInfo string and updated messages array"
            },
            {
              "name": "IterationResult<T>",
              "desc": "Structure containing the final result, iteration count, all requests made, and whether to continue",
              "inputs": "Generic type T for result",
              "outputs": "result: T, iteration: number, maxIterations: number, requests: LLMRequest[], shouldContinue: boolean"
            },
            {
              "name": "IterationCallbacks<T>",
              "desc": "Optional callbacks for monitoring iteration progress",
              "inputs": "Generic type T for result",
              "outputs": "onIterationStart and onIterationComplete callback functions"
            }
          ],
          "dependencies": [
            "fileAccessHelper",
            "LLMRequest type definitions"
          ],
          "intent": "This file exists to eliminate code duplication and improve testability by extracting the iterative LLM analysis pattern into a reusable service. It solves the problem of LLMs needing multiple rounds of information gathering (file reads, grep searches) before completing an analysis, converting while-loop patterns into async iterator patterns that are easier to test and maintain.",
          "rawContent": "```json\n{\n  \"purpose\": \"Handles iterative analysis where an LLM makes multiple requests for files or code searches until it has enough information to complete its task\",\n  \"userVisibleActions\": [\n    \"User receives analysis results that may require multiple rounds of file access and code searching\",\n    \"User sees progress updates as the system iterates through analysis rounds\",\n    \"User experiences automatic retrieval of additional file content when the LLM needs more context\",\n    \"User gets grep search results automatically incorporated into analysis when patterns need to be found\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer triggers incremental analysis that automatically handles LLM requests for more information\",\n    \"Developer receives iteration callbacks showing progress through analysis rounds\",\n    \"Developer gets structured results containing the final analysis, iteration count, and all requests made\",\n    \"Developer can configure maximum iterations to prevent infinite loops\",\n    \"Developer sees file read and grep search requests processed automatically up to 5 requests per iteration\",\n    \"Developer receives conversation messages with assistant responses and user-provided additional information\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Processes LLM requests for files and grep searches, returning formatted additional information and updated conversation messages\",\n      \"inputs\": \"requests: LLMRequest[], currentResult: any, messages: conversation array\",\n      \"outputs\": \"ProcessRequestsResult with additionalInfo string and updated messages array\"\n    },\n    {\n      \"name\": \"IterationResult<T>\",\n      \"desc\": \"Structure containing the final result, iteration count, all requests made, and whether to continue\",\n      \"inputs\": \"Generic type T for result\",\n      \"outputs\": \"result: T, iteration: number, maxIterations: number, requests: LLMRequest[], shouldContinue: boolean\"\n    },\n    {\n      \"name\": \"IterationCallbacks<T>\",\n      \"desc\": \"Optional callbacks for monitoring iteration progress\",\n      \"inputs\": \"Generic type T for result\",\n      \"outputs\": \"onIterationStart and onIterationComplete callback functions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fileAccessHelper\",\n    \"LLMRequest type definitions\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication and improve testability by extracting the iterative LLM analysis pattern into a reusable service. It solves the problem of LLMs needing multiple rounds of information gathering (file reads, grep searches) before completing an analysis, converting while-loop patterns into async iterator patterns that are easier to test and maintain.\"\n}\n```"
        },
        {
          "file": "src/domain/services/testConfigurationService.ts",
          "role": "Core Logic",
          "purpose": "Automatically detects test framework configuration (Jest, Mocha, Vitest, Pytest) and identifies missing dependencies or setup requirements to ensure generated tests work without manual configuration.",
          "userVisibleActions": [
            "Automatically detects which test framework is being used in the workspace (Jest, Mocha, Vitest, or Pytest)",
            "Identifies missing test dependencies that need to be installed",
            "Shows configuration status indicating whether tests are ready to run",
            "Reports whether TypeScript support is properly configured for the test framework",
            "Indicates if test setup files or configuration files are missing"
          ],
          "developerVisibleActions": [
            "Scans package.json to detect test scripts and installed test framework dependencies",
            "Checks for framework-specific configuration files (jest.config.js, mocha.opts, vitest.config.ts, pytest.ini)",
            "Detects if TypeScript is used and validates TypeScript test support (ts-jest, @types packages)",
            "Returns detailed status including framework type, configuration state, and required setup actions",
            "Provides list of missing dependencies that need installation",
            "Determines if additional setup is required before tests can be generated"
          ],
          "keyFunctions": [
            {
              "name": "detectTestConfiguration",
              "desc": "Analyzes workspace to determine test framework, configuration status, and missing dependencies",
              "inputs": "workspaceRoot: string (path to workspace folder)",
              "outputs": "TestConfigStatus object with framework type, configuration state, missing dependencies, and setup actions"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "SWLogger"
          ],
          "intent": "Eliminates manual test configuration by automatically detecting the test framework and setup requirements, ensuring that AI-generated tests work immediately without requiring users to manually configure test environments or install missing dependencies.",
          "rawContent": "```json\n{\n  \"purpose\": \"Automatically detects test framework configuration (Jest, Mocha, Vitest, Pytest) and identifies missing dependencies or setup requirements to ensure generated tests work without manual configuration.\",\n  \"userVisibleActions\": [\n    \"Automatically detects which test framework is being used in the workspace (Jest, Mocha, Vitest, or Pytest)\",\n    \"Identifies missing test dependencies that need to be installed\",\n    \"Shows configuration status indicating whether tests are ready to run\",\n    \"Reports whether TypeScript support is properly configured for the test framework\",\n    \"Indicates if test setup files or configuration files are missing\"\n  ],\n  \"developerVisibleActions\": [\n    \"Scans package.json to detect test scripts and installed test framework dependencies\",\n    \"Checks for framework-specific configuration files (jest.config.js, mocha.opts, vitest.config.ts, pytest.ini)\",\n    \"Detects if TypeScript is used and validates TypeScript test support (ts-jest, @types packages)\",\n    \"Returns detailed status including framework type, configuration state, and required setup actions\",\n    \"Provides list of missing dependencies that need installation\",\n    \"Determines if additional setup is required before tests can be generated\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"detectTestConfiguration\",\n      \"desc\": \"Analyzes workspace to determine test framework, configuration status, and missing dependencies\",\n      \"inputs\": \"workspaceRoot: string (path to workspace folder)\",\n      \"outputs\": \"TestConfigStatus object with framework type, configuration state, missing dependencies, and setup actions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"SWLogger\"\n  ],\n  \"intent\": \"Eliminates manual test configuration by automatically detecting the test framework and setup requirements, ensuring that AI-generated tests work immediately without requiring users to manually configure test environments or install missing dependencies.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/infrastructure/fileSystem",
      "moduleType": "other",
      "capabilities": [
        "Caches file contents in memory to accelerate repeated file access operations",
        "Automatically refreshes cached content when files are modified on disk",
        "Processes multiple files in parallel for faster bulk operations",
        "Intelligently filters files to skip non-source directories and irrelevant files",
        "Provides consistent error handling across all file operations",
        "Reduces disk I/O to improve overall extension responsiveness"
      ],
      "summary": "The fileSystem module provides high-performance file access and processing capabilities for the extension. It maintains an intelligent in-memory cache that speeds up repeated file reads while automatically staying synchronized with disk changes, ensuring users always work with current file content without manual refresh actions.\n\nThe module handles bulk file operations efficiently by processing multiple files simultaneously and automatically filtering out non-source directories like node_modules, .git, dist, and build folders. This means users don't need to manually exclude common directories - the extension intelligently focuses on relevant source files.\n\nAll file operations are wrapped with consistent error handling, so users experience graceful degradation rather than crashes when file access issues occur. The combination of caching, parallel processing, and smart filtering results in noticeably faster extension performance, particularly when working with large codebases or performing operations that touch many files at once.",
      "files": [
        {
          "file": "src/infrastructure/fileSystem/fileCache.ts",
          "role": "Core Logic",
          "purpose": "Caches file contents in memory to reduce redundant file system reads and improve performance across the extension.",
          "userVisibleActions": [
            "Faster file access when the same file is read multiple times",
            "Automatic refresh of cached content when files are modified on disk",
            "Improved extension responsiveness due to reduced disk I/O operations"
          ],
          "developerVisibleActions": [
            "Retrieve file content with automatic caching via getFile() method",
            "Cache automatically invalidates when files change on disk through file system watcher",
            "LRU (Least Recently Used) eviction policy maintains cache size limits",
            "Cache statistics available for monitoring hits, misses, and evictions",
            "Cache entries expire after a TTL (time-to-live) period to ensure freshness",
            "File hash verification ensures cached content matches current disk content"
          ],
          "keyFunctions": [
            {
              "name": "getFile",
              "desc": "Retrieves file content from cache if available and valid, otherwise reads from disk and caches it",
              "inputs": "filePath: string",
              "outputs": "Promise<string> - file content"
            },
            {
              "name": "constructor",
              "desc": "Initializes the cache with configurable size limit and TTL settings",
              "inputs": "maxSize: number (default 500), ttl: number (default 5000ms)",
              "outputs": "FileCache instance"
            },
            {
              "name": "setupWatcher",
              "desc": "Sets up file system watcher to automatically invalidate cache entries when files change",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "isStale",
              "desc": "Checks if a cached entry has exceeded its TTL",
              "inputs": "cached: CachedFile",
              "outputs": "boolean"
            },
            {
              "name": "evictIfNeeded",
              "desc": "Removes least recently used entries when cache size exceeds maximum",
              "inputs": "none",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "vscode",
            "fs",
            "path"
          ],
          "intent": "This file exists to optimize file system operations by caching frequently accessed files in memory, reducing disk I/O and improving extension performance. It solves the problem of redundant file reads across multiple components by providing a centralized, automatically invalidating cache with size management and freshness guarantees.",
          "rawContent": "```json\n{\n  \"purpose\": \"Caches file contents in memory to reduce redundant file system reads and improve performance across the extension.\",\n  \"userVisibleActions\": [\n    \"Faster file access when the same file is read multiple times\",\n    \"Automatic refresh of cached content when files are modified on disk\",\n    \"Improved extension responsiveness due to reduced disk I/O operations\"\n  ],\n  \"developerVisibleActions\": [\n    \"Retrieve file content with automatic caching via getFile() method\",\n    \"Cache automatically invalidates when files change on disk through file system watcher\",\n    \"LRU (Least Recently Used) eviction policy maintains cache size limits\",\n    \"Cache statistics available for monitoring hits, misses, and evictions\",\n    \"Cache entries expire after a TTL (time-to-live) period to ensure freshness\",\n    \"File hash verification ensures cached content matches current disk content\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getFile\",\n      \"desc\": \"Retrieves file content from cache if available and valid, otherwise reads from disk and caches it\",\n      \"inputs\": \"filePath: string\",\n      \"outputs\": \"Promise<string> - file content\"\n    },\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes the cache with configurable size limit and TTL settings\",\n      \"inputs\": \"maxSize: number (default 500), ttl: number (default 5000ms)\",\n      \"outputs\": \"FileCache instance\"\n    },\n    {\n      \"name\": \"setupWatcher\",\n      \"desc\": \"Sets up file system watcher to automatically invalidate cache entries when files change\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"isStale\",\n      \"desc\": \"Checks if a cached entry has exceeded its TTL\",\n      \"inputs\": \"cached: CachedFile\",\n      \"outputs\": \"boolean\"\n    },\n    {\n      \"name\": \"evictIfNeeded\",\n      \"desc\": \"Removes least recently used entries when cache size exceeds maximum\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\"\n  ],\n  \"intent\": \"This file exists to optimize file system operations by caching frequently accessed files in memory, reducing disk I/O and improving extension performance. It solves the problem of redundant file reads across multiple components by providing a centralized, automatically invalidating cache with size management and freshness guarantees.\"\n}\n```"
        },
        {
          "file": "src/infrastructure/fileSystem/fileProcessor.ts",
          "role": "Core Logic",
          "purpose": "Provides a unified file processing system that filters, reads, and processes multiple files in parallel while handling errors consistently",
          "userVisibleActions": [
            "Files are automatically filtered to skip non-source directories (node_modules, .git, dist, build, etc.)",
            "Multiple files are processed simultaneously for faster operations",
            "Errors during file processing are caught and handled gracefully"
          ],
          "developerVisibleActions": [
            "Developer provides an array of file paths and a processing function",
            "System automatically filters out unwanted files based on patterns",
            "Files are read and processed in parallel batches",
            "Custom file filters can be provided to override default skip patterns",
            "Custom file readers can be injected for testing or alternate file sources",
            "Error context can be passed for better error tracking and debugging"
          ],
          "keyFunctions": [
            {
              "name": "shouldProcess",
              "desc": "Determines if a file should be processed based on filter patterns",
              "inputs": "filePath (string)",
              "outputs": "boolean indicating whether to process the file"
            },
            {
              "name": "readFile",
              "desc": "Reads file content from the filesystem",
              "inputs": "filePath (string)",
              "outputs": "Promise<string> containing file content"
            },
            {
              "name": "processFiles",
              "desc": "Processes multiple files in parallel with filtering, reading, and custom processing logic",
              "inputs": "files (string[]), processor function, optional error context",
              "outputs": "Promise<T[]> containing processed results for each file"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "../../utils/errorHandler"
          ],
          "intent": "This file exists to eliminate duplicate file processing patterns scattered across the codebase by providing a single, reusable system for filtering files, reading them, and processing them in parallel. It solves the problem of inconsistent file handling, reduces code duplication, and provides a standardized way to process multiple files with built-in error handling and customizable filtering.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a unified file processing system that filters, reads, and processes multiple files in parallel while handling errors consistently\",\n  \"userVisibleActions\": [\n    \"Files are automatically filtered to skip non-source directories (node_modules, .git, dist, build, etc.)\",\n    \"Multiple files are processed simultaneously for faster operations\",\n    \"Errors during file processing are caught and handled gracefully\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer provides an array of file paths and a processing function\",\n    \"System automatically filters out unwanted files based on patterns\",\n    \"Files are read and processed in parallel batches\",\n    \"Custom file filters can be provided to override default skip patterns\",\n    \"Custom file readers can be injected for testing or alternate file sources\",\n    \"Error context can be passed for better error tracking and debugging\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"shouldProcess\",\n      \"desc\": \"Determines if a file should be processed based on filter patterns\",\n      \"inputs\": \"filePath (string)\",\n      \"outputs\": \"boolean indicating whether to process the file\"\n    },\n    {\n      \"name\": \"readFile\",\n      \"desc\": \"Reads file content from the filesystem\",\n      \"inputs\": \"filePath (string)\",\n      \"outputs\": \"Promise<string> containing file content\"\n    },\n    {\n      \"name\": \"processFiles\",\n      \"desc\": \"Processes multiple files in parallel with filtering, reading, and custom processing logic\",\n      \"inputs\": \"files (string[]), processor function, optional error context\",\n      \"outputs\": \"Promise<T[]> containing processed results for each file\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"../../utils/errorHandler\"\n  ],\n  \"intent\": \"This file exists to eliminate duplicate file processing patterns scattered across the codebase by providing a single, reusable system for filtering files, reading them, and processing them in parallel. It solves the problem of inconsistent file handling, reduces code duplication, and provides a standardized way to process multiple files with built-in error handling and customizable filtering.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/infrastructure/persistence",
      "moduleType": "other",
      "capabilities": [
        "Automatically persists all analysis results to disk in organized directory structures",
        "Creates timestamped folders for each analysis run to maintain complete history",
        "Saves product documentation to .shadow/docs with formatted markdown content",
        "Stores architecture insights in .shadow/insights as structured reports",
        "Preserves project summaries with metadata for later review",
        "Maintains versioned analysis history for comparison and tracking changes over time"
      ],
      "summary": "The persistence module provides automatic, organized storage of all analysis results generated by Shadow. When you run analyses on your codebase, this module ensures that every result—whether product documentation, architecture insights, or project summaries—is saved to disk in a structured, timestamped format. This creates a permanent record of your analysis history.\n\nEach analysis run creates a new timestamped directory (e.g., .shadow/docs/2024-01-15_14-30-00) that contains all outputs from that session. This approach preserves the complete history of your project's evolution, allowing you to review past analyses, compare changes over time, and track how your documentation and insights have developed. Product documentation goes to .shadow/docs, while architecture insights are stored in .shadow/insights.\n\nAll saved files use formatted markdown with proper structure and metadata, making them easy to read, version control, and integrate into your existing documentation workflows. The persistent storage means you can always access previous analyses without re-running expensive AI operations, and you can track how your codebase understanding has evolved across different time periods.",
      "files": [
        {
          "file": "src/infrastructure/persistence/analysisResultRepository.ts",
          "role": "Core Logic",
          "purpose": "Manages saving and organizing analysis results (product documentation, architecture insights, summaries) to disk in timestamped directories",
          "userVisibleActions": [
            "Analysis results are automatically saved to .shadow/docs and .shadow/insights directories",
            "Each analysis run creates a new timestamped folder to preserve history",
            "Product documentation files are saved with formatted markdown content",
            "Architecture insights are saved as structured markdown reports",
            "Project summaries are saved in markdown format with metadata",
            "All saved files are accessible for later review and comparison"
          ],
          "developerVisibleActions": [
            "Initialize a product documentation run to prepare storage location",
            "Initialize an architecture insights run to prepare storage location",
            "Save individual product documentation files with enhanced metadata",
            "Save architecture insights with categorized findings",
            "Save project summaries with key metrics and information",
            "Finalize runs to complete storage operations",
            "Storage automatically creates timestamped directory structures",
            "Files are organized by analysis type and timestamp"
          ],
          "keyFunctions": [
            {
              "name": "initializeProductDocsRun",
              "desc": "Creates a new timestamped directory for storing product documentation",
              "inputs": "workspaceRoot (string)",
              "outputs": "runDir path (string)"
            },
            {
              "name": "initializeArchitectureInsightsRun",
              "desc": "Creates a new timestamped directory for storing architecture insights",
              "inputs": "workspaceRoot (string)",
              "outputs": "runDir path (string)"
            },
            {
              "name": "saveProductDocumentation",
              "desc": "Saves enhanced product documentation to a markdown file",
              "inputs": "relativePath (string), documentation (EnhancedProductDocumentation)",
              "outputs": "void"
            },
            {
              "name": "saveArchitectureInsights",
              "desc": "Saves architecture analysis insights to a markdown file",
              "inputs": "insights (LLMInsights)",
              "outputs": "void"
            },
            {
              "name": "saveSummary",
              "desc": "Saves project analysis summary to a markdown file",
              "inputs": "summary (object with title, description, keyFeatures, etc.)",
              "outputs": "void"
            },
            {
              "name": "finalizeProductDocsRun",
              "desc": "Completes the product documentation run and cleans up",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "finalizeArchitectureInsightsRun",
              "desc": "Completes the architecture insights run and cleans up",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "getCurrentProductDocsRunDir",
              "desc": "Retrieves the current product documentation storage directory",
              "inputs": "none",
              "outputs": "runDir path (string or null)"
            },
            {
              "name": "getCurrentArchitectureInsightsRunDir",
              "desc": "Retrieves the current architecture insights storage directory",
              "inputs": "none",
              "outputs": "runDir path (string or null)"
            }
          ],
          "dependencies": [
            "vscode",
            "fs",
            "path",
            "../../fileDocumentation (EnhancedProductDocumentation)",
            "../../llmService (LLMInsights)",
            "../../domain/formatters/documentationFormatter (DocumentationFormatter)",
            "../../storage/incrementalStorage (createTimestampedStorage)"
          ],
          "intent": "This file exists to separate data persistence concerns from analysis logic, providing a clean interface for saving analysis results to disk while maintaining organized, timestamped storage that preserves historical analysis runs and makes results easily accessible for review.",
          "rawContent": "```json\n{\n  \"purpose\": \"Manages saving and organizing analysis results (product documentation, architecture insights, summaries) to disk in timestamped directories\",\n  \"userVisibleActions\": [\n    \"Analysis results are automatically saved to .shadow/docs and .shadow/insights directories\",\n    \"Each analysis run creates a new timestamped folder to preserve history\",\n    \"Product documentation files are saved with formatted markdown content\",\n    \"Architecture insights are saved as structured markdown reports\",\n    \"Project summaries are saved in markdown format with metadata\",\n    \"All saved files are accessible for later review and comparison\"\n  ],\n  \"developerVisibleActions\": [\n    \"Initialize a product documentation run to prepare storage location\",\n    \"Initialize an architecture insights run to prepare storage location\",\n    \"Save individual product documentation files with enhanced metadata\",\n    \"Save architecture insights with categorized findings\",\n    \"Save project summaries with key metrics and information\",\n    \"Finalize runs to complete storage operations\",\n    \"Storage automatically creates timestamped directory structures\",\n    \"Files are organized by analysis type and timestamp\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initializeProductDocsRun\",\n      \"desc\": \"Creates a new timestamped directory for storing product documentation\",\n      \"inputs\": \"workspaceRoot (string)\",\n      \"outputs\": \"runDir path (string)\"\n    },\n    {\n      \"name\": \"initializeArchitectureInsightsRun\",\n      \"desc\": \"Creates a new timestamped directory for storing architecture insights\",\n      \"inputs\": \"workspaceRoot (string)\",\n      \"outputs\": \"runDir path (string)\"\n    },\n    {\n      \"name\": \"saveProductDocumentation\",\n      \"desc\": \"Saves enhanced product documentation to a markdown file\",\n      \"inputs\": \"relativePath (string), documentation (EnhancedProductDocumentation)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"saveArchitectureInsights\",\n      \"desc\": \"Saves architecture analysis insights to a markdown file\",\n      \"inputs\": \"insights (LLMInsights)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"saveSummary\",\n      \"desc\": \"Saves project analysis summary to a markdown file\",\n      \"inputs\": \"summary (object with title, description, keyFeatures, etc.)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"finalizeProductDocsRun\",\n      \"desc\": \"Completes the product documentation run and cleans up\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"finalizeArchitectureInsightsRun\",\n      \"desc\": \"Completes the architecture insights run and cleans up\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getCurrentProductDocsRunDir\",\n      \"desc\": \"Retrieves the current product documentation storage directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"runDir path (string or null)\"\n    },\n    {\n      \"name\": \"getCurrentArchitectureInsightsRunDir\",\n      \"desc\": \"Retrieves the current architecture insights storage directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"runDir path (string or null)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"../../fileDocumentation (EnhancedProductDocumentation)\",\n    \"../../llmService (LLMInsights)\",\n    \"../../domain/formatters/documentationFormatter (DocumentationFormatter)\",\n    \"../../storage/incrementalStorage (createTimestampedStorage)\"\n  ],\n  \"intent\": \"This file exists to separate data persistence concerns from analysis logic, providing a clean interface for saving analysis results to disk while maintaining organized, timestamped storage that preserves historical analysis runs and makes results easily accessible for review.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/infrastructure",
      "moduleType": "other",
      "capabilities": [
        "Display progress notifications for long-running operations",
        "Show cancellable progress indicators that users can interrupt",
        "Update progress messages dynamically during task execution",
        "Configure progress display location (notification area, status bar, etc.)",
        "Provide standardized progress feedback across the application"
      ],
      "summary": "The Infrastructure module provides a centralized progress notification service that enhances user experience during long-running operations. It enables the application to display consistent, informative progress indicators that keep users informed about ongoing tasks.\n\nUsers benefit from clear visual feedback when operations take time to complete, with the ability to cancel tasks if needed. Progress notifications can include both titles and dynamically updated messages, providing context about what's happening at each stage. The service supports multiple display locations, allowing progress information to appear in the most appropriate part of the interface—whether as a prominent notification or a subtle status bar indicator.\n\nThis module standardizes how progress is communicated throughout the application, ensuring users always have visibility into system activity and control over cancellable operations. It abstracts the complexity of progress management, providing a uniform interface for displaying task status regardless of the underlying operation type.",
      "files": [
        {
          "file": "src/infrastructure/progressService.ts",
          "role": "Core Logic",
          "purpose": "Provides a standardized service for displaying progress notifications to users during long-running operations.",
          "userVisibleActions": [
            "Shows progress notifications with title and optional message updates",
            "Displays cancellable progress indicators that users can dismiss",
            "Shows progress in different locations (notification, window status bar, etc.)"
          ],
          "developerVisibleActions": [
            "Developer wraps async operations with progress reporting using withProgress method",
            "Developer passes a title and optional configuration (cancellable, location)",
            "Developer receives a reporter object to update progress messages during execution",
            "Developer can check cancellation status via the cancellation token",
            "Developer receives the result of the wrapped async operation"
          ],
          "keyFunctions": [
            {
              "name": "withProgress",
              "desc": "Wraps an async task with progress reporting UI",
              "inputs": "options (title, cancellable flag, location) and an async task function that receives a ProgressReporter",
              "outputs": "Returns the result of the executed task"
            },
            {
              "name": "ProgressReporter.report",
              "desc": "Updates the progress message and optionally increments progress percentage",
              "inputs": "message string and optional increment number",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "vscode"
          ],
          "intent": "This file exists to reduce boilerplate code and ensure consistent progress reporting across the extension by wrapping VSCode's native withProgress API in a simpler, standardized interface that developers can reuse throughout the codebase.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a standardized service for displaying progress notifications to users during long-running operations.\",\n  \"userVisibleActions\": [\n    \"Shows progress notifications with title and optional message updates\",\n    \"Displays cancellable progress indicators that users can dismiss\",\n    \"Shows progress in different locations (notification, window status bar, etc.)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer wraps async operations with progress reporting using withProgress method\",\n    \"Developer passes a title and optional configuration (cancellable, location)\",\n    \"Developer receives a reporter object to update progress messages during execution\",\n    \"Developer can check cancellation status via the cancellation token\",\n    \"Developer receives the result of the wrapped async operation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"withProgress\",\n      \"desc\": \"Wraps an async task with progress reporting UI\",\n      \"inputs\": \"options (title, cancellable flag, location) and an async task function that receives a ProgressReporter\",\n      \"outputs\": \"Returns the result of the executed task\"\n    },\n    {\n      \"name\": \"ProgressReporter.report\",\n      \"desc\": \"Updates the progress message and optionally increments progress percentage\",\n      \"inputs\": \"message string and optional increment number\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to reduce boilerplate code and ensure consistent progress reporting across the extension by wrapping VSCode's native withProgress API in a simpler, standardized interface that developers can reuse throughout the codebase.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/state",
      "moduleType": "other",
      "capabilities": [
        "Persistent state management across VS Code sessions",
        "Automatic saving and restoration of user preferences and settings",
        "Real-time state synchronization for LLM-powered features",
        "Centralized management of insights, navigation, analysis, and test data",
        "Multi-view state coordination across tree views and output channels"
      ],
      "summary": "The state module provides comprehensive state management for the extension, ensuring that all user data, preferences, and LLM-generated content persists across VS Code sessions. It acts as the central nervous system for managing state across multiple UI components including the insights tree view, product navigator, analysis viewer, unit tests navigator, and reports viewer.\n\nUsers benefit from seamless state persistence where their settings, preferences, and generated content are automatically saved and restored when reopening VS Code. The module coordinates state changes across all LLM-powered features, ensuring that insights, analysis results, test information, and reports remain synchronized and immediately accessible. Changes are applied in real-time with automatic validation and persistence, providing a reliable and consistent user experience.\n\nThe module supports complex workflows involving multiple interconnected views and features, managing the lifecycle of LLM-generated content from creation through display and navigation. It handles state for documentation navigation, code analysis results, unit test exploration, and report generation, ensuring that all data remains consistent and accessible throughout the user's interaction with the extension.",
      "files": [
        {
          "file": "src/state/baseStateManager.ts",
          "role": "Core Logic",
          "purpose": "Provides a reusable base class for managing persistent state in VS Code extensions with automatic storage, validation, and change notifications",
          "userVisibleActions": [
            "State persists across VS Code sessions (user's data is saved and restored when reopening VS Code)",
            "User's settings and preferences are automatically remembered",
            "Changes to state are applied immediately and saved persistently"
          ],
          "developerVisibleActions": [
            "Extend this base class to create type-safe state managers for specific features",
            "Subscribe to state changes to react to updates in real-time",
            "Update state using either direct setState or functional updates",
            "State is automatically loaded from VS Code's global storage on initialization",
            "State changes trigger notifications to all subscribers",
            "Defensive copies prevent external mutation of state",
            "Validation runs automatically before state changes are applied",
            "Failed persistence operations are logged without crashing the extension"
          ],
          "keyFunctions": [
            {
              "name": "setState",
              "desc": "Sets new state, validates it, persists to storage, and notifies all subscribers",
              "inputs": "newState: T (the new state object)",
              "outputs": "void"
            },
            {
              "name": "getState",
              "desc": "Returns a defensive copy of the current state to prevent external mutations",
              "inputs": "none",
              "outputs": "T (deep copy of current state)"
            },
            {
              "name": "updateState",
              "desc": "Updates state using a transformation function applied to current state",
              "inputs": "updater: (current: T) => T (function that transforms current state)",
              "outputs": "void"
            },
            {
              "name": "subscribe",
              "desc": "Registers a listener function to be called whenever state changes",
              "inputs": "listener: (state: T) => void (callback function)",
              "outputs": "function (unsubscribe function to stop listening)"
            },
            {
              "name": "loadState",
              "desc": "Loads state from VS Code's global storage or returns default state if none exists",
              "inputs": "none",
              "outputs": "T (loaded or default state)"
            },
            {
              "name": "getDefaultState",
              "desc": "Abstract method that subclasses must implement to provide initial default state",
              "inputs": "none",
              "outputs": "T (default state object)"
            }
          ],
          "dependencies": [
            "vscode"
          ],
          "intent": "This file exists to eliminate duplicate state management code across the extension by providing a single, robust, reusable foundation for managing persistent state. It solves the problem of manually handling storage, validation, subscriptions, and notifications for every feature that needs to track state, ensuring consistency and reducing bugs.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a reusable base class for managing persistent state in VS Code extensions with automatic storage, validation, and change notifications\",\n  \"userVisibleActions\": [\n    \"State persists across VS Code sessions (user's data is saved and restored when reopening VS Code)\",\n    \"User's settings and preferences are automatically remembered\",\n    \"Changes to state are applied immediately and saved persistently\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extend this base class to create type-safe state managers for specific features\",\n    \"Subscribe to state changes to react to updates in real-time\",\n    \"Update state using either direct setState or functional updates\",\n    \"State is automatically loaded from VS Code's global storage on initialization\",\n    \"State changes trigger notifications to all subscribers\",\n    \"Defensive copies prevent external mutation of state\",\n    \"Validation runs automatically before state changes are applied\",\n    \"Failed persistence operations are logged without crashing the extension\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setState\",\n      \"desc\": \"Sets new state, validates it, persists to storage, and notifies all subscribers\",\n      \"inputs\": \"newState: T (the new state object)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getState\",\n      \"desc\": \"Returns a defensive copy of the current state to prevent external mutations\",\n      \"inputs\": \"none\",\n      \"outputs\": \"T (deep copy of current state)\"\n    },\n    {\n      \"name\": \"updateState\",\n      \"desc\": \"Updates state using a transformation function applied to current state\",\n      \"inputs\": \"updater: (current: T) => T (function that transforms current state)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"subscribe\",\n      \"desc\": \"Registers a listener function to be called whenever state changes\",\n      \"inputs\": \"listener: (state: T) => void (callback function)\",\n      \"outputs\": \"function (unsubscribe function to stop listening)\"\n    },\n    {\n      \"name\": \"loadState\",\n      \"desc\": \"Loads state from VS Code's global storage or returns default state if none exists\",\n      \"inputs\": \"none\",\n      \"outputs\": \"T (loaded or default state)\"\n    },\n    {\n      \"name\": \"getDefaultState\",\n      \"desc\": \"Abstract method that subclasses must implement to provide initial default state\",\n      \"inputs\": \"none\",\n      \"outputs\": \"T (default state object)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to eliminate duplicate state management code across the extension by providing a single, robust, reusable foundation for managing persistent state. It solves the problem of manually handling storage, validation, subscriptions, and notifications for every feature that needs to track state, ensuring consistency and reducing bugs.\"\n}\n```"
        },
        {
          "file": "src/state/llmStateManager.ts",
          "role": "Core Logic",
          "purpose": "Centralizes and manages all state for LLM-powered features, UI providers, and analysis results throughout the extension's lifecycle.",
          "userVisibleActions": [
            "View LLM-generated insights in the insights tree view",
            "Navigate product documentation through the product navigator",
            "See analysis results in the analysis viewer",
            "Browse unit test information in the unit tests navigator",
            "View generated reports through the reports viewer",
            "See output messages in the LLM output channel"
          ],
          "developerVisibleActions": [
            "Store and retrieve the current LLM service instance for making AI requests",
            "Cache analysis context to avoid redundant processing",
            "Store enhanced product documentation for later retrieval",
            "Maintain LLM insights between operations",
            "Store code analysis results for access by multiple components",
            "Manage references to all UI tree providers and viewers",
            "Update all registered UI providers when state changes",
            "Access output channel for logging LLM operations",
            "Clear all cached state when needed",
            "Check if LLM service is available before making requests"
          ],
          "keyFunctions": [
            {
              "name": "getLLMService",
              "desc": "Retrieves the initialized LLM service or throws error if not available",
              "inputs": "none",
              "outputs": "LLMService instance"
            },
            {
              "name": "setLLMService",
              "desc": "Stores the LLM service instance for extension-wide access",
              "inputs": "service: LLMService",
              "outputs": "void"
            },
            {
              "name": "getAnalysisContext",
              "desc": "Retrieves the last stored analysis context",
              "inputs": "none",
              "outputs": "AnalysisContext or null"
            },
            {
              "name": "setAnalysisContext",
              "desc": "Stores analysis context for later retrieval",
              "inputs": "context: AnalysisContext",
              "outputs": "void"
            },
            {
              "name": "getEnhancedProductDocs",
              "desc": "Retrieves cached enhanced product documentation",
              "inputs": "none",
              "outputs": "EnhancedProductDocumentation or null"
            },
            {
              "name": "setEnhancedProductDocs",
              "desc": "Stores enhanced product documentation",
              "inputs": "docs: EnhancedProductDocumentation",
              "outputs": "void"
            },
            {
              "name": "getLLMInsights",
              "desc": "Retrieves cached LLM-generated insights",
              "inputs": "none",
              "outputs": "LLMInsights or null"
            },
            {
              "name": "setLLMInsights",
              "desc": "Stores LLM insights and updates all registered UI providers",
              "inputs": "insights: LLMInsights",
              "outputs": "void"
            },
            {
              "name": "getCodeAnalysis",
              "desc": "Retrieves cached code analysis results",
              "inputs": "none",
              "outputs": "CodeAnalysis or null"
            },
            {
              "name": "setCodeAnalysis",
              "desc": "Stores code analysis results",
              "inputs": "analysis: CodeAnalysis",
              "outputs": "void"
            },
            {
              "name": "registerTreeProvider",
              "desc": "Registers the insights tree provider for state updates",
              "inputs": "provider: InsightsTreeProvider",
              "outputs": "void"
            },
            {
              "name": "registerProductNavigator",
              "desc": "Registers the product navigator for state updates",
              "inputs": "navigator: ProductNavigatorProvider",
              "outputs": "void"
            },
            {
              "name": "registerInsightsViewer",
              "desc": "Registers the insights viewer for state updates",
              "inputs": "viewer: InsightsViewerProvider",
              "outputs": "void"
            },
            {
              "name": "registerAnalysisViewer",
              "desc": "Registers the analysis viewer for state updates",
              "inputs": "viewer: AnalysisViewerProvider",
              "outputs": "void"
            },
            {
              "name": "registerUnitTestsNavigator",
              "desc": "Registers the unit tests navigator for state updates",
              "inputs": "navigator: UnitTestsNavigatorProvider",
              "outputs": "void"
            },
            {
              "name": "registerReportsViewer",
              "desc": "Registers the reports viewer for state updates",
              "inputs": "viewer: ReportsViewer",
              "outputs": "void"
            },
            {
              "name": "registerReportsTreeProvider",
              "desc": "Registers the reports tree provider for state updates",
              "inputs": "provider: ReportsTreeProvider",
              "outputs": "void"
            },
            {
              "name": "setOutputChannel",
              "desc": "Stores the output channel for logging LLM operations",
              "inputs": "channel: vscode.OutputChannel",
              "outputs": "void"
            },
            {
              "name": "getOutputChannel",
              "desc": "Retrieves the output channel for displaying LLM messages",
              "inputs": "none",
              "outputs": "vscode.OutputChannel or null"
            },
            {
              "name": "updateAllProviders",
              "desc": "Refreshes all registered UI providers with current state",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "clearState",
              "desc": "Clears all cached analysis data and state",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "hasLLMService",
              "desc": "Checks if LLM service is initialized and available",
              "inputs": "none",
              "outputs": "boolean"
            }
          ],
          "dependencies": [
            "vscode",
            "llmService",
            "fileDocumentation",
            "analyzer",
            "insightsTreeView",
            "productNavigator",
            "insightsViewer",
            "analysisViewer",
            "unitTestsNavigator",
            "ui/reportsViewer",
            "reportsTreeProvider"
          ],
          "intent": "Provides a single source of truth for all LLM-related state across the extension. Eliminates the need to pass state between components by centralizing storage and retrieval of LLM services, analysis results, documentation, and UI provider references. Ensures all UI components stay synchronized when state changes by automatically updating registered providers.",
          "rawContent": "```json\n{\n  \"purpose\": \"Centralizes and manages all state for LLM-powered features, UI providers, and analysis results throughout the extension's lifecycle.\",\n  \"userVisibleActions\": [\n    \"View LLM-generated insights in the insights tree view\",\n    \"Navigate product documentation through the product navigator\",\n    \"See analysis results in the analysis viewer\",\n    \"Browse unit test information in the unit tests navigator\",\n    \"View generated reports through the reports viewer\",\n    \"See output messages in the LLM output channel\"\n  ],\n  \"developerVisibleActions\": [\n    \"Store and retrieve the current LLM service instance for making AI requests\",\n    \"Cache analysis context to avoid redundant processing\",\n    \"Store enhanced product documentation for later retrieval\",\n    \"Maintain LLM insights between operations\",\n    \"Store code analysis results for access by multiple components\",\n    \"Manage references to all UI tree providers and viewers\",\n    \"Update all registered UI providers when state changes\",\n    \"Access output channel for logging LLM operations\",\n    \"Clear all cached state when needed\",\n    \"Check if LLM service is available before making requests\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getLLMService\",\n      \"desc\": \"Retrieves the initialized LLM service or throws error if not available\",\n      \"inputs\": \"none\",\n      \"outputs\": \"LLMService instance\"\n    },\n    {\n      \"name\": \"setLLMService\",\n      \"desc\": \"Stores the LLM service instance for extension-wide access\",\n      \"inputs\": \"service: LLMService\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getAnalysisContext\",\n      \"desc\": \"Retrieves the last stored analysis context\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisContext or null\"\n    },\n    {\n      \"name\": \"setAnalysisContext\",\n      \"desc\": \"Stores analysis context for later retrieval\",\n      \"inputs\": \"context: AnalysisContext\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getEnhancedProductDocs\",\n      \"desc\": \"Retrieves cached enhanced product documentation\",\n      \"inputs\": \"none\",\n      \"outputs\": \"EnhancedProductDocumentation or null\"\n    },\n    {\n      \"name\": \"setEnhancedProductDocs\",\n      \"desc\": \"Stores enhanced product documentation\",\n      \"inputs\": \"docs: EnhancedProductDocumentation\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getLLMInsights\",\n      \"desc\": \"Retrieves cached LLM-generated insights\",\n      \"inputs\": \"none\",\n      \"outputs\": \"LLMInsights or null\"\n    },\n    {\n      \"name\": \"setLLMInsights\",\n      \"desc\": \"Stores LLM insights and updates all registered UI providers\",\n      \"inputs\": \"insights: LLMInsights\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getCodeAnalysis\",\n      \"desc\": \"Retrieves cached code analysis results\",\n      \"inputs\": \"none\",\n      \"outputs\": \"CodeAnalysis or null\"\n    },\n    {\n      \"name\": \"setCodeAnalysis\",\n      \"desc\": \"Stores code analysis results\",\n      \"inputs\": \"analysis: CodeAnalysis\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerTreeProvider\",\n      \"desc\": \"Registers the insights tree provider for state updates\",\n      \"inputs\": \"provider: InsightsTreeProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerProductNavigator\",\n      \"desc\": \"Registers the product navigator for state updates\",\n      \"inputs\": \"navigator: ProductNavigatorProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerInsightsViewer\",\n      \"desc\": \"Registers the insights viewer for state updates\",\n      \"inputs\": \"viewer: InsightsViewerProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerAnalysisViewer\",\n      \"desc\": \"Registers the analysis viewer for state updates\",\n      \"inputs\": \"viewer: AnalysisViewerProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerUnitTestsNavigator\",\n      \"desc\": \"Registers the unit tests navigator for state updates\",\n      \"inputs\": \"navigator: UnitTestsNavigatorProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerReportsViewer\",\n      \"desc\": \"Registers the reports viewer for state updates\",\n      \"inputs\": \"viewer: ReportsViewer\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerReportsTreeProvider\",\n      \"desc\": \"Registers the reports tree provider for state updates\",\n      \"inputs\": \"provider: ReportsTreeProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setOutputChannel\",\n      \"desc\": \"Stores the output channel for logging LLM operations\",\n      \"inputs\": \"channel: vscode.OutputChannel\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getOutputChannel\",\n      \"desc\": \"Retrieves the output channel for displaying LLM messages\",\n      \"inputs\": \"none\",\n      \"outputs\": \"vscode.OutputChannel or null\"\n    },\n    {\n      \"name\": \"updateAllProviders\",\n      \"desc\": \"Refreshes all registered UI providers with current state\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"clearState\",\n      \"desc\": \"Clears all cached analysis data and state\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"hasLLMService\",\n      \"desc\": \"Checks if LLM service is initialized and available\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"llmService\",\n    \"fileDocumentation\",\n    \"analyzer\",\n    \"insightsTreeView\",\n    \"productNavigator\",\n    \"insightsViewer\",\n    \"analysisViewer\",\n    \"unitTestsNavigator\",\n    \"ui/reportsViewer\",\n    \"reportsTreeProvider\"\n  ],\n  \"intent\": \"Provides a single source of truth for all LLM-related state across the extension. Eliminates the need to pass state between components by centralizing storage and retrieval of LLM services, analysis results, documentation, and UI provider references. Ensures all UI components stay synchronized when state changes by automatically updating registered providers.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/storage",
      "moduleType": "other",
      "capabilities": [
        "Automatically save data to disk with timestamps for version tracking",
        "Incrementally save multiple versions of data with iteration numbers",
        "Preserve historical data across saves with timestamped file naming",
        "Store data in both JSON and optional Markdown formats",
        "Retrieve the most recent saved version of data",
        "Track when data was generated through automatic timestamping"
      ],
      "summary": "The storage module provides a generic incremental storage system that automatically manages versioned data persistence to disk. It handles the complexity of saving data with timestamps and iteration numbers, ensuring that all historical versions are preserved for audit trails and recovery purposes.\n\nUsers can save data incrementally without worrying about overwriting previous versions - each save creates a new timestamped file while maintaining the previous versions. The module supports both JSON format for structured data and optional Markdown format for human-readable documentation. When retrieving data, users automatically get the most recent version, but all historical versions remain accessible through their timestamped filenames.\n\nThis module is ideal for workflows that require data versioning, audit trails, or the ability to track changes over time. Common use cases include saving analysis results, configuration snapshots, or any data that needs to be preserved across multiple iterations with automatic timestamp tracking.",
      "files": [
        {
          "file": "src/storage/incrementalStorage.ts",
          "role": "Core Logic",
          "purpose": "Provides a generic storage system for saving and loading timestamped data incrementally to disk in JSON and optionally Markdown formats.",
          "userVisibleActions": [
            "Data is automatically saved to disk with timestamps for tracking when it was generated",
            "Multiple versions of data can be saved incrementally with iteration numbers",
            "Data can be retrieved from the most recent saved version",
            "Previously saved data is preserved in timestamped files for historical tracking"
          ],
          "developerVisibleActions": [
            "Create a storage instance configured for specific data types with custom prefixes and directories",
            "Save typed data objects with optional metadata like iteration number, run ID, and timestamps",
            "Load the most recent saved data automatically based on filename patterns",
            "Store data in both JSON and Markdown formats simultaneously when configured",
            "Organize saved files into subdirectories with customizable naming patterns",
            "Access saved file paths and metadata for debugging or reporting",
            "Handle storage errors through the ErrorHandler utility"
          ],
          "keyFunctions": [
            {
              "name": "save",
              "desc": "Saves data to disk with metadata, creating timestamped files with optional iteration numbers",
              "inputs": "data: T (generic typed data), metadata?: StorageMetadata (timestamps, iteration, runId, etc.)",
              "outputs": "Promise<void>"
            },
            {
              "name": "load",
              "desc": "Loads the most recently saved data from disk based on file patterns",
              "inputs": "None",
              "outputs": "Promise<{data: T, metadata: StorageMetadata} | null>"
            },
            {
              "name": "getFilePath",
              "desc": "Generates the file path for saving data based on metadata and configuration",
              "inputs": "metadata?: StorageMetadata",
              "outputs": "string (file path)"
            },
            {
              "name": "getLatestFile",
              "desc": "Finds the most recent file matching the storage pattern in the directory",
              "inputs": "None",
              "outputs": "string | null (file path)"
            },
            {
              "name": "ensureDirectory",
              "desc": "Creates the storage directory structure if it doesn't exist",
              "inputs": "None",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "fs",
            "path",
            "ErrorHandler"
          ],
          "intent": "This file exists to eliminate code duplication across different storage operations by providing a reusable, type-safe storage system. It solves the problem of consistently saving and retrieving timestamped data with metadata, supporting incremental workflows where multiple versions of data need to be preserved and tracked over time. It standardizes file naming, directory organization, and metadata handling across the application.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a generic storage system for saving and loading timestamped data incrementally to disk in JSON and optionally Markdown formats.\",\n  \"userVisibleActions\": [\n    \"Data is automatically saved to disk with timestamps for tracking when it was generated\",\n    \"Multiple versions of data can be saved incrementally with iteration numbers\",\n    \"Data can be retrieved from the most recent saved version\",\n    \"Previously saved data is preserved in timestamped files for historical tracking\"\n  ],\n  \"developerVisibleActions\": [\n    \"Create a storage instance configured for specific data types with custom prefixes and directories\",\n    \"Save typed data objects with optional metadata like iteration number, run ID, and timestamps\",\n    \"Load the most recent saved data automatically based on filename patterns\",\n    \"Store data in both JSON and Markdown formats simultaneously when configured\",\n    \"Organize saved files into subdirectories with customizable naming patterns\",\n    \"Access saved file paths and metadata for debugging or reporting\",\n    \"Handle storage errors through the ErrorHandler utility\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"save\",\n      \"desc\": \"Saves data to disk with metadata, creating timestamped files with optional iteration numbers\",\n      \"inputs\": \"data: T (generic typed data), metadata?: StorageMetadata (timestamps, iteration, runId, etc.)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"load\",\n      \"desc\": \"Loads the most recently saved data from disk based on file patterns\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Promise<{data: T, metadata: StorageMetadata} | null>\"\n    },\n    {\n      \"name\": \"getFilePath\",\n      \"desc\": \"Generates the file path for saving data based on metadata and configuration\",\n      \"inputs\": \"metadata?: StorageMetadata\",\n      \"outputs\": \"string (file path)\"\n    },\n    {\n      \"name\": \"getLatestFile\",\n      \"desc\": \"Finds the most recent file matching the storage pattern in the directory\",\n      \"inputs\": \"None\",\n      \"outputs\": \"string | null (file path)\"\n    },\n    {\n      \"name\": \"ensureDirectory\",\n      \"desc\": \"Creates the storage directory structure if it doesn't exist\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"ErrorHandler\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication across different storage operations by providing a reusable, type-safe storage system. It solves the problem of consistently saving and retrieving timestamped data with metadata, supporting incremental workflows where multiple versions of data need to be preserved and tracked over time. It standardizes file naming, directory organization, and metadata handling across the application.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/test/__mocks__",
      "moduleType": "tests",
      "capabilities": [
        "Enables isolated unit testing of VS Code extension code without requiring the actual VS Code extension host environment",
        "Provides mock implementations of core VS Code API objects including workspace, window, languages, and commands",
        "Supports test-driven development by simulating VS Code extension APIs with controllable test doubles",
        "Allows developers to verify extension behavior through automated Jest tests in a CI/CD pipeline"
      ],
      "summary": "This testing infrastructure module provides mock implementations of the VS Code Extension API specifically designed for Jest unit tests. It enables developers to test extension functionality in isolation without launching the full VS Code environment, significantly speeding up test execution and enabling automated testing in continuous integration pipelines.\n\nThe module mocks essential VS Code API surfaces including workspace configuration, window UI elements, language features, and command registration. This allows extension developers to write comprehensive unit tests that verify their extension's logic, error handling, and integration with VS Code APIs while maintaining fast test execution times and deterministic test behavior.\n\nWhile this module has no direct user-facing features in the production extension, it provides critical testing infrastructure that ensures extension quality and reliability. Developers can run tests locally during development and in automated CI/CD pipelines to catch regressions and verify correctness before shipping updates to end users.",
      "files": [
        {
          "file": "src/test/__mocks__/vscode.ts",
          "role": "Core Logic",
          "purpose": "Provides mock implementations of VS Code API objects and functions for Jest unit testing without requiring the actual VS Code extension host.",
          "userVisibleActions": [
            "No direct user-visible actions - this file only affects test execution and doesn't run in the actual extension"
          ],
          "developerVisibleActions": [
            "Enables Jest tests to run without VS Code by providing fake implementations of window.showInformationMessage, showErrorMessage, and other VS Code APIs",
            "Allows developers to write unit tests that call VS Code APIs without starting the full extension host",
            "Provides mockable functions that can be configured in tests to return specific values or simulate behaviors",
            "Simulates file URIs, workspace configurations, commands, and output channels for isolated testing",
            "Tracks mock function calls and results for test assertions"
          ],
          "keyFunctions": [
            {
              "name": "createMockFn",
              "desc": "Creates a mock function that can be configured to return values, resolve promises, or execute custom implementations in tests",
              "inputs": "None",
              "outputs": "A mock function object with methods like mockReturnValue, mockResolvedValue, mockRejectedValue, and mockImplementation"
            },
            {
              "name": "window.showInformationMessage",
              "desc": "Mock for displaying information messages to users",
              "inputs": "Message text and optional actions",
              "outputs": "Configurable mock return value"
            },
            {
              "name": "window.createOutputChannel",
              "desc": "Mock for creating output channels with methods to append lines, clear, show, and dispose",
              "inputs": "Channel name",
              "outputs": "Mock output channel object with appendLine, clear, dispose, and show methods"
            },
            {
              "name": "workspace.getConfiguration",
              "desc": "Mock for retrieving workspace configuration settings",
              "inputs": "Configuration section name",
              "outputs": "Mock configuration object with get, has, update, and inspect methods"
            },
            {
              "name": "Uri.file",
              "desc": "Mock for creating file URIs from file system paths",
              "inputs": "File system path string",
              "outputs": "Mock URI object with fsPath, scheme, and path properties"
            },
            {
              "name": "commands.registerCommand",
              "desc": "Mock for registering VS Code commands",
              "inputs": "Command identifier and callback function",
              "outputs": "Configurable mock return value"
            }
          ],
          "dependencies": [],
          "intent": "This file exists to enable unit testing of VS Code extension code without requiring the full VS Code environment. It solves the problem of testing extension logic in isolation by providing lightweight mock implementations of VS Code APIs that can be configured and monitored during tests, allowing developers to write fast, reliable unit tests without the overhead of the extension host.",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides mock implementations of VS Code API objects and functions for Jest unit testing without requiring the actual VS Code extension host.\",\n  \"userVisibleActions\": [\n    \"No direct user-visible actions - this file only affects test execution and doesn't run in the actual extension\"\n  ],\n  \"developerVisibleActions\": [\n    \"Enables Jest tests to run without VS Code by providing fake implementations of window.showInformationMessage, showErrorMessage, and other VS Code APIs\",\n    \"Allows developers to write unit tests that call VS Code APIs without starting the full extension host\",\n    \"Provides mockable functions that can be configured in tests to return specific values or simulate behaviors\",\n    \"Simulates file URIs, workspace configurations, commands, and output channels for isolated testing\",\n    \"Tracks mock function calls and results for test assertions\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"createMockFn\",\n      \"desc\": \"Creates a mock function that can be configured to return values, resolve promises, or execute custom implementations in tests\",\n      \"inputs\": \"None\",\n      \"outputs\": \"A mock function object with methods like mockReturnValue, mockResolvedValue, mockRejectedValue, and mockImplementation\"\n    },\n    {\n      \"name\": \"window.showInformationMessage\",\n      \"desc\": \"Mock for displaying information messages to users\",\n      \"inputs\": \"Message text and optional actions\",\n      \"outputs\": \"Configurable mock return value\"\n    },\n    {\n      \"name\": \"window.createOutputChannel\",\n      \"desc\": \"Mock for creating output channels with methods to append lines, clear, show, and dispose\",\n      \"inputs\": \"Channel name\",\n      \"outputs\": \"Mock output channel object with appendLine, clear, dispose, and show methods\"\n    },\n    {\n      \"name\": \"workspace.getConfiguration\",\n      \"desc\": \"Mock for retrieving workspace configuration settings\",\n      \"inputs\": \"Configuration section name\",\n      \"outputs\": \"Mock configuration object with get, has, update, and inspect methods\"\n    },\n    {\n      \"name\": \"Uri.file\",\n      \"desc\": \"Mock for creating file URIs from file system paths\",\n      \"inputs\": \"File system path string\",\n      \"outputs\": \"Mock URI object with fsPath, scheme, and path properties\"\n    },\n    {\n      \"name\": \"commands.registerCommand\",\n      \"desc\": \"Mock for registering VS Code commands\",\n      \"inputs\": \"Command identifier and callback function\",\n      \"outputs\": \"Configurable mock return value\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"This file exists to enable unit testing of VS Code extension code without requiring the full VS Code environment. It solves the problem of testing extension logic in isolation by providing lightweight mock implementations of VS Code APIs that can be configured and monitored during tests, allowing developers to write fast, reliable unit tests without the overhead of the extension host.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/ui",
      "moduleType": "gui",
      "capabilities": [
        "Provides a centralized dashboard view for all generated reports within the VS Code extension",
        "Displays clickable cards for each report type with availability status and metadata",
        "Shows timestamps indicating when each report was last generated",
        "Enables quick access to workspace, product, architecture, refactoring, and unit-test reports",
        "Distinguishes between available reports and reports not yet generated",
        "Opens HTML reports in the default browser with a single click"
      ],
      "summary": "The UI module provides a unified Reports Viewer interface that serves as a central hub for accessing all documentation and analysis reports generated by the extension. Users can view a webview panel displaying organized cards for each report type, including workspace summaries, product documentation, architecture diagrams, refactoring guides, and unit test documentation.\n\nThe Reports Viewer displays the current status of each report, showing whether it has been generated and when it was last updated. Each report card includes a descriptive label, brief description, and visual indicators for availability. Users can click on any available report card to open the corresponding HTML report in their default web browser, streamlining the workflow for reviewing generated documentation.\n\nThis centralized interface eliminates the need to navigate through the file system to find generated reports, providing a convenient dashboard that shows at a glance which reports are available and allows immediate access to them. The panel can be refreshed to reflect newly generated reports and closed when no longer needed.",
      "files": [
        {
          "file": "src/ui/reportsViewer.ts",
          "role": "GUI View",
          "purpose": "Displays a unified webview panel showing links to all generated reports (workspace, product, architecture, refactoring, unit-test) in the VS Code extension",
          "userVisibleActions": [
            "View a centralized Reports pane with links to all available reports",
            "Click on report cards to open HTML reports in default browser",
            "See which reports are available vs. not yet generated",
            "View timestamps showing when each report was last generated",
            "See descriptive labels and descriptions for each report type",
            "Refresh the Reports pane to see updated report availability",
            "Close the Reports pane when finished viewing"
          ],
          "developerVisibleActions": [
            "Register a new report by calling updateReport() with report type and file path",
            "Show the Reports pane by calling show() method",
            "Update report information including path and timestamp for each report type",
            "Clear a specific report by calling updateReport() with null path",
            "Handle webview messages for report opening actions",
            "Track five report types: workspace, product, architecture, refactoring, and unit-test",
            "Dispose of the Reports viewer to clean up resources"
          ],
          "keyFunctions": [
            {
              "name": "show",
              "desc": "Shows or reveals the Reports webview panel to the user",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "updateReport",
              "desc": "Updates the path, timestamp, and availability status of a specific report type",
              "inputs": "type (report type), path (file path or null)",
              "outputs": "void"
            },
            {
              "name": "updateContent",
              "desc": "Refreshes the webview content with current report information",
              "inputs": "none",
              "outputs": "void"
            },
            {
              "name": "getReportLabel",
              "desc": "Returns user-friendly display label for a report type",
              "inputs": "type (report type)",
              "outputs": "string label"
            },
            {
              "name": "getReportDescription",
              "desc": "Returns descriptive text explaining what each report type contains",
              "inputs": "type (report type)",
              "outputs": "string description"
            },
            {
              "name": "handleOpenReport",
              "desc": "Opens a report HTML file in the default external browser",
              "inputs": "reportType (string)",
              "outputs": "Promise<void>"
            },
            {
              "name": "generateHtmlContent",
              "desc": "Generates the HTML content for the Reports webview panel",
              "inputs": "none",
              "outputs": "string (HTML content)"
            },
            {
              "name": "dispose",
              "desc": "Cleans up and disposes of the webview panel",
              "inputs": "none",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "vscode",
            "./webview/baseWebviewProvider",
            "./webview/webviewTemplateEngine"
          ],
          "intent": "This file exists to replace individual webview panels for each report type with a single unified Reports pane. It solves the problem of managing multiple report viewers by providing a centralized dashboard where users can access all generated reports (workspace analysis, product requirements, architecture documentation, refactoring suggestions, and unit test reports) from one location. It tracks report availability, timestamps, and provides easy access to open reports in the browser.",
          "rawContent": "```json\n{\n  \"purpose\": \"Displays a unified webview panel showing links to all generated reports (workspace, product, architecture, refactoring, unit-test) in the VS Code extension\",\n  \"userVisibleActions\": [\n    \"View a centralized Reports pane with links to all available reports\",\n    \"Click on report cards to open HTML reports in default browser\",\n    \"See which reports are available vs. not yet generated\",\n    \"View timestamps showing when each report was last generated\",\n    \"See descriptive labels and descriptions for each report type\",\n    \"Refresh the Reports pane to see updated report availability\",\n    \"Close the Reports pane when finished viewing\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register a new report by calling updateReport() with report type and file path\",\n    \"Show the Reports pane by calling show() method\",\n    \"Update report information including path and timestamp for each report type\",\n    \"Clear a specific report by calling updateReport() with null path\",\n    \"Handle webview messages for report opening actions\",\n    \"Track five report types: workspace, product, architecture, refactoring, and unit-test\",\n    \"Dispose of the Reports viewer to clean up resources\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"show\",\n      \"desc\": \"Shows or reveals the Reports webview panel to the user\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"updateReport\",\n      \"desc\": \"Updates the path, timestamp, and availability status of a specific report type\",\n      \"inputs\": \"type (report type), path (file path or null)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"updateContent\",\n      \"desc\": \"Refreshes the webview content with current report information\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getReportLabel\",\n      \"desc\": \"Returns user-friendly display label for a report type\",\n      \"inputs\": \"type (report type)\",\n      \"outputs\": \"string label\"\n    },\n    {\n      \"name\": \"getReportDescription\",\n      \"desc\": \"Returns descriptive text explaining what each report type contains\",\n      \"inputs\": \"type (report type)\",\n      \"outputs\": \"string description\"\n    },\n    {\n      \"name\": \"handleOpenReport\",\n      \"desc\": \"Opens a report HTML file in the default external browser\",\n      \"inputs\": \"reportType (string)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"generateHtmlContent\",\n      \"desc\": \"Generates the HTML content for the Reports webview panel\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string (HTML content)\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up and disposes of the webview panel\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./webview/baseWebviewProvider\",\n    \"./webview/webviewTemplateEngine\"\n  ],\n  \"intent\": \"This file exists to replace individual webview panels for each report type with a single unified Reports pane. It solves the problem of managing multiple report viewers by providing a centralized dashboard where users can access all generated reports (workspace analysis, product requirements, architecture documentation, refactoring suggestions, and unit test reports) from one location. It tracks report availability, timestamps, and provides easy access to open reports in the browser.\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    },
    {
      "module": "src/ui/webview",
      "moduleType": "gui",
      "capabilities": [
        "Display custom webview panels within the VSCode interface",
        "Manage webview lifecycle including creation, activation, and disposal",
        "Render dynamic HTML content through a template-based system",
        "Handle webview state transitions and visibility changes",
        "Provide consistent webview behavior across different panel types"
      ],
      "summary": "The webview module provides the foundation for displaying custom web-based user interfaces within VSCode. It enables the application to show rich, interactive panels that can present information, forms, and visual content using HTML rendering. Users interact with these webview panels as they appear in the editor, with the module handling all the complexity of panel lifecycle management.\n\nWhen users trigger actions that require custom visualizations or interfaces, this module ensures webview panels are created, displayed, and managed consistently. The module handles bringing existing panels to the front when reactivated, cleaning up resources when panels are closed, and rendering content through a structured template system that ensures proper styling and functionality.\n\nThis infrastructure supports various types of webview-based features throughout the application, providing a reusable foundation that reduces code duplication and ensures consistent behavior. Users experience smooth transitions as panels open, update, and close, with the module handling all technical aspects of webview integration with the VSCode environment.",
      "files": [
        {
          "file": "src/ui/webview/baseWebviewProvider.ts",
          "role": "GUI View",
          "purpose": "Provides a base class for creating and managing webview panels in VSCode with shared functionality to reduce code duplication",
          "userVisibleActions": [
            "User sees webview panels appear or come to front when activated",
            "User sees webview panels close and disappear when disposed",
            "User sees webview content rendered with HTML through a template system"
          ],
          "developerVisibleActions": [
            "Developer creates reusable webview panels with consistent configuration",
            "Developer reveals existing panels instead of creating duplicates",
            "Developer sets HTML content using template engine with options",
            "Developer disposes webview panels programmatically by ID",
            "Developer configures panel behavior (scripts, column placement, context retention)"
          ],
          "keyFunctions": [
            {
              "name": "createOrRevealPanel",
              "desc": "Creates a new webview panel or reveals an existing one if it already exists",
              "inputs": "id (string), title (string), options (BaseWebviewOptions with viewColumn, enableScripts, retainContextWhenHidden)",
              "outputs": "vscode.WebviewPanel instance"
            },
            {
              "name": "setPanelHtml",
              "desc": "Sets the HTML content of a webview panel using the template engine",
              "inputs": "panel (vscode.WebviewPanel), options (WebviewTemplateOptions)",
              "outputs": "void"
            },
            {
              "name": "disposePanel",
              "desc": "Closes and removes a webview panel by its ID",
              "inputs": "id (string)",
              "outputs": "void"
            }
          ],
          "dependencies": [
            "vscode",
            "./webviewTemplateEngine"
          ],
          "intent": "This file exists to eliminate code duplication across different webview implementations by providing common functionality for creating, managing, and disposing webview panels with consistent behavior and configuration",
          "rawContent": "```json\n{\n  \"purpose\": \"Provides a base class for creating and managing webview panels in VSCode with shared functionality to reduce code duplication\",\n  \"userVisibleActions\": [\n    \"User sees webview panels appear or come to front when activated\",\n    \"User sees webview panels close and disappear when disposed\",\n    \"User sees webview content rendered with HTML through a template system\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer creates reusable webview panels with consistent configuration\",\n    \"Developer reveals existing panels instead of creating duplicates\",\n    \"Developer sets HTML content using template engine with options\",\n    \"Developer disposes webview panels programmatically by ID\",\n    \"Developer configures panel behavior (scripts, column placement, context retention)\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"createOrRevealPanel\",\n      \"desc\": \"Creates a new webview panel or reveals an existing one if it already exists\",\n      \"inputs\": \"id (string), title (string), options (BaseWebviewOptions with viewColumn, enableScripts, retainContextWhenHidden)\",\n      \"outputs\": \"vscode.WebviewPanel instance\"\n    },\n    {\n      \"name\": \"setPanelHtml\",\n      \"desc\": \"Sets the HTML content of a webview panel using the template engine\",\n      \"inputs\": \"panel (vscode.WebviewPanel), options (WebviewTemplateOptions)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"disposePanel\",\n      \"desc\": \"Closes and removes a webview panel by its ID\",\n      \"inputs\": \"id (string)\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./webviewTemplateEngine\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication across different webview implementations by providing common functionality for creating, managing, and disposing webview panels with consistent behavior and configuration\"\n}\n```"
        }
      ],
      "endpoints": [],
      "commands": [],
      "workers": []
    }
  ],
  "fileSummaries": [
    {
      "file": "jest.config.js",
      "role": "Core Logic",
      "purpose": "Configures Jest testing framework for TypeScript unit tests with coverage reporting and VS Code mocking support.",
      "userVisibleActions": [
        "Users indirectly benefit from automated testing ensuring code quality and stability",
        "Test results and coverage reports help users trust the extension's reliability"
      ],
      "developerVisibleActions": [
        "Developers can run unit tests using Jest framework with TypeScript support",
        "Developers can view test coverage reports in text, HTML, and lcov formats",
        "Developers can execute tests with 'npm test' or 'jest' commands",
        "Test files are automatically discovered in __tests__ folders or files matching *.test.ts or *.spec.ts patterns",
        "VS Code API calls are mocked during testing to enable unit testing without the actual VS Code environment",
        "TypeScript code is transpiled on-the-fly during test execution",
        "Coverage reports exclude test files, type definitions, and mock files from analysis",
        "Tests run in Node.js environment with 10-second timeout per test"
      ],
      "keyFunctions": [],
      "dependencies": [
        "ts-jest",
        "jest",
        "vscode"
      ],
      "intent": "This file exists to configure the Jest testing framework for a TypeScript-based VS Code extension, enabling developers to write and run unit tests with proper TypeScript compilation, VS Code API mocking, and comprehensive coverage reporting to ensure code quality and maintainability.",
      "rawContent": "```json\n{\n  \"purpose\": \"Configures Jest testing framework for TypeScript unit tests with coverage reporting and VS Code mocking support.\",\n  \"userVisibleActions\": [\n    \"Users indirectly benefit from automated testing ensuring code quality and stability\",\n    \"Test results and coverage reports help users trust the extension's reliability\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developers can run unit tests using Jest framework with TypeScript support\",\n    \"Developers can view test coverage reports in text, HTML, and lcov formats\",\n    \"Developers can execute tests with 'npm test' or 'jest' commands\",\n    \"Test files are automatically discovered in __tests__ folders or files matching *.test.ts or *.spec.ts patterns\",\n    \"VS Code API calls are mocked during testing to enable unit testing without the actual VS Code environment\",\n    \"TypeScript code is transpiled on-the-fly during test execution\",\n    \"Coverage reports exclude test files, type definitions, and mock files from analysis\",\n    \"Tests run in Node.js environment with 10-second timeout per test\"\n  ],\n  \"keyFunctions\": [],\n  \"dependencies\": [\n    \"ts-jest\",\n    \"jest\",\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to configure the Jest testing framework for a TypeScript-based VS Code extension, enabling developers to write and run unit tests with proper TypeScript compilation, VS Code API mocking, and comprehensive coverage reporting to ensure code quality and maintainability.\"\n}\n```"
    },
    {
      "file": "src/ai/llmRateLimiter.ts",
      "role": "Core Logic",
      "purpose": "Manages API rate limiting for LLM providers (OpenAI and Claude) to prevent exceeding their request quotas",
      "userVisibleActions": [
        "API requests are automatically throttled to stay within provider limits",
        "Requests may be delayed or rejected if rate limits are exceeded",
        "Different LLM providers (OpenAI, Claude) have different rate limit allowances"
      ],
      "developerVisibleActions": [
        "Configure custom rate limits for each LLM provider (max requests per time window)",
        "Check if a request can be made before calling the LLM API",
        "Record requests to track usage against rate limits",
        "OpenAI defaults to 60 requests per minute, Claude defaults to 50 requests per minute",
        "Rate limits are enforced using a sliding time window approach"
      ],
      "keyFunctions": [
        {
          "name": "constructor",
          "desc": "Initializes rate limiter with default limits for OpenAI (60 req/min) and Claude (50 req/min)",
          "inputs": "none",
          "outputs": "RateLimiter instance"
        },
        {
          "name": "configure",
          "desc": "Sets custom rate limit configuration for a specific LLM provider",
          "inputs": "provider (openai|claude), config (maxRequests, windowMs)",
          "outputs": "void"
        },
        {
          "name": "canMakeRequest",
          "desc": "Checks if a request can be made without exceeding the rate limit for the provider",
          "inputs": "provider (openai|claude)",
          "outputs": "boolean (true if request allowed, false if rate limit exceeded)"
        },
        {
          "name": "recordRequest",
          "desc": "Records the timestamp of a request to track usage against rate limits",
          "inputs": "provider (openai|claude)",
          "outputs": "void"
        }
      ],
      "dependencies": [],
      "intent": "Prevents the application from exceeding LLM provider API rate limits by tracking request timestamps and enforcing configurable request quotas per time window, ensuring reliable API access and avoiding service interruptions or penalties",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages API rate limiting for LLM providers (OpenAI and Claude) to prevent exceeding their request quotas\",\n  \"userVisibleActions\": [\n    \"API requests are automatically throttled to stay within provider limits\",\n    \"Requests may be delayed or rejected if rate limits are exceeded\",\n    \"Different LLM providers (OpenAI, Claude) have different rate limit allowances\"\n  ],\n  \"developerVisibleActions\": [\n    \"Configure custom rate limits for each LLM provider (max requests per time window)\",\n    \"Check if a request can be made before calling the LLM API\",\n    \"Record requests to track usage against rate limits\",\n    \"OpenAI defaults to 60 requests per minute, Claude defaults to 50 requests per minute\",\n    \"Rate limits are enforced using a sliding time window approach\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes rate limiter with default limits for OpenAI (60 req/min) and Claude (50 req/min)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"RateLimiter instance\"\n    },\n    {\n      \"name\": \"configure\",\n      \"desc\": \"Sets custom rate limit configuration for a specific LLM provider\",\n      \"inputs\": \"provider (openai|claude), config (maxRequests, windowMs)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"canMakeRequest\",\n      \"desc\": \"Checks if a request can be made without exceeding the rate limit for the provider\",\n      \"inputs\": \"provider (openai|claude)\",\n      \"outputs\": \"boolean (true if request allowed, false if rate limit exceeded)\"\n    },\n    {\n      \"name\": \"recordRequest\",\n      \"desc\": \"Records the timestamp of a request to track usage against rate limits\",\n      \"inputs\": \"provider (openai|claude)\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"Prevents the application from exceeding LLM provider API rate limits by tracking request timestamps and enforcing configurable request quotas per time window, ensuring reliable API access and avoiding service interruptions or penalties\"\n}\n```"
    },
    {
      "file": "src/ai/llmResponseParser.ts",
      "role": "Core Logic",
      "purpose": "Parses and extracts structured data from LLM text responses into standardized formats for file summaries, module summaries, and product documentation.",
      "userVisibleActions": [
        "When AI analysis completes, user receives structured documentation with clear sections for purpose, actions, and dependencies",
        "User sees organized file and module summaries with extracted key information",
        "User receives product documentation with categorized features and use cases",
        "When AI responses are malformed, user still gets partial data with fallback text extraction"
      ],
      "developerVisibleActions": [
        "Developer calls parser methods with raw LLM response text and receives typed objects (FileSummary, ModuleSummary, EnhancedProductDocumentation)",
        "Developer provides file paths and role information to get parsed file summaries",
        "Developer passes module paths to get consolidated module analysis",
        "Developer triggers product documentation parsing to extract features, use cases, and target users",
        "Parser attempts JSON parsing first, then falls back to text extraction if JSON parsing fails",
        "Developer receives LLMInsights objects with parsed purpose, capabilities, and context",
        "Parser handles extraction of list sections, nested structures, and specific data fields from unstructured text"
      ],
      "keyFunctions": [
        {
          "name": "parseFileSummary",
          "desc": "Extracts file-level documentation from LLM response",
          "inputs": "content (string), filePath (string), role (string)",
          "outputs": "FileSummary object with purpose, actions, functions, and dependencies"
        },
        {
          "name": "parseModuleSummary",
          "desc": "Extracts module-level documentation from LLM response",
          "inputs": "content (string), modulePath (string)",
          "outputs": "ModuleSummary object with organized module information"
        },
        {
          "name": "parseEnhancedProductDocumentation",
          "desc": "Extracts comprehensive product documentation from LLM response",
          "inputs": "content (string)",
          "outputs": "EnhancedProductDocumentation object with features, use cases, and target users"
        },
        {
          "name": "parseInsights",
          "desc": "Extracts general insights and analysis from LLM response",
          "inputs": "content (string)",
          "outputs": "LLMInsights object with purpose, capabilities, and context"
        },
        {
          "name": "extractSection",
          "desc": "Extracts a specific named section from text content",
          "inputs": "content (string), sectionName (string)",
          "outputs": "Extracted text string or empty string"
        },
        {
          "name": "extractListSection",
          "desc": "Extracts a list of items from a named section",
          "inputs": "content (string), sectionName (string)",
          "outputs": "Array of strings extracted from the section"
        }
      ],
      "dependencies": [
        "../fileDocumentation (FileSummary, ModuleSummary, EnhancedProductDocumentation)",
        "../llmService (LLMInsights, ProductPurposeAnalysis, AnalysisContext)"
      ],
      "intent": "Solves the problem of converting unstructured LLM text responses into consistent, typed data structures that can be programmatically used throughout the application. Acts as the bridge between raw AI output and structured documentation objects, handling both JSON and freeform text responses with fallback strategies.",
      "rawContent": "```json\n{\n  \"purpose\": \"Parses and extracts structured data from LLM text responses into standardized formats for file summaries, module summaries, and product documentation.\",\n  \"userVisibleActions\": [\n    \"When AI analysis completes, user receives structured documentation with clear sections for purpose, actions, and dependencies\",\n    \"User sees organized file and module summaries with extracted key information\",\n    \"User receives product documentation with categorized features and use cases\",\n    \"When AI responses are malformed, user still gets partial data with fallback text extraction\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer calls parser methods with raw LLM response text and receives typed objects (FileSummary, ModuleSummary, EnhancedProductDocumentation)\",\n    \"Developer provides file paths and role information to get parsed file summaries\",\n    \"Developer passes module paths to get consolidated module analysis\",\n    \"Developer triggers product documentation parsing to extract features, use cases, and target users\",\n    \"Parser attempts JSON parsing first, then falls back to text extraction if JSON parsing fails\",\n    \"Developer receives LLMInsights objects with parsed purpose, capabilities, and context\",\n    \"Parser handles extraction of list sections, nested structures, and specific data fields from unstructured text\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"parseFileSummary\",\n      \"desc\": \"Extracts file-level documentation from LLM response\",\n      \"inputs\": \"content (string), filePath (string), role (string)\",\n      \"outputs\": \"FileSummary object with purpose, actions, functions, and dependencies\"\n    },\n    {\n      \"name\": \"parseModuleSummary\",\n      \"desc\": \"Extracts module-level documentation from LLM response\",\n      \"inputs\": \"content (string), modulePath (string)\",\n      \"outputs\": \"ModuleSummary object with organized module information\"\n    },\n    {\n      \"name\": \"parseEnhancedProductDocumentation\",\n      \"desc\": \"Extracts comprehensive product documentation from LLM response\",\n      \"inputs\": \"content (string)\",\n      \"outputs\": \"EnhancedProductDocumentation object with features, use cases, and target users\"\n    },\n    {\n      \"name\": \"parseInsights\",\n      \"desc\": \"Extracts general insights and analysis from LLM response\",\n      \"inputs\": \"content (string)\",\n      \"outputs\": \"LLMInsights object with purpose, capabilities, and context\"\n    },\n    {\n      \"name\": \"extractSection\",\n      \"desc\": \"Extracts a specific named section from text content\",\n      \"inputs\": \"content (string), sectionName (string)\",\n      \"outputs\": \"Extracted text string or empty string\"\n    },\n    {\n      \"name\": \"extractListSection\",\n      \"desc\": \"Extracts a list of items from a named section\",\n      \"inputs\": \"content (string), sectionName (string)\",\n      \"outputs\": \"Array of strings extracted from the section\"\n    }\n  ],\n  \"dependencies\": [\n    \"../fileDocumentation (FileSummary, ModuleSummary, EnhancedProductDocumentation)\",\n    \"../llmService (LLMInsights, ProductPurposeAnalysis, AnalysisContext)\"\n  ],\n  \"intent\": \"Solves the problem of converting unstructured LLM text responses into consistent, typed data structures that can be programmatically used throughout the application. Acts as the bridge between raw AI output and structured documentation objects, handling both JSON and freeform text responses with fallback strategies.\"\n}\n```"
    },
    {
      "file": "src/ai/llmRetryHandler.ts",
      "role": "Core Logic",
      "purpose": "Handles automatic retry logic for LLM API requests with exponential backoff when errors occur",
      "userVisibleActions": [
        "API requests automatically retry when temporary failures occur (rate limits, timeouts, network issues)",
        "Longer wait times occur between successive retry attempts",
        "Failed requests eventually succeed or show error after maximum retries exhausted"
      ],
      "developerVisibleActions": [
        "Wrap API calls with retry handler to get automatic retry behavior",
        "Configure retry behavior (max attempts, delays, which errors trigger retries)",
        "Receive callbacks when retries occur to track attempt progress",
        "Get final result with number of attempts made",
        "Non-retryable errors immediately throw without retry attempts"
      ],
      "keyFunctions": [
        {
          "name": "executeWithRetry",
          "desc": "Executes an async operation with automatic retry logic and exponential backoff",
          "inputs": "operation function to execute, optional retry configuration (maxRetries, delays, error types)",
          "outputs": "Promise resolving to operation result with attempt count"
        },
        {
          "name": "isRetryableError",
          "desc": "Determines if an error should trigger a retry based on error type classification",
          "inputs": "error object, list of retryable error patterns",
          "outputs": "boolean indicating if error is retryable"
        }
      ],
      "dependencies": [],
      "intent": "Provides resilient LLM API communication by automatically handling transient failures like rate limits, timeouts, and network issues without requiring manual retry logic in calling code",
      "rawContent": "```json\n{\n  \"purpose\": \"Handles automatic retry logic for LLM API requests with exponential backoff when errors occur\",\n  \"userVisibleActions\": [\n    \"API requests automatically retry when temporary failures occur (rate limits, timeouts, network issues)\",\n    \"Longer wait times occur between successive retry attempts\",\n    \"Failed requests eventually succeed or show error after maximum retries exhausted\"\n  ],\n  \"developerVisibleActions\": [\n    \"Wrap API calls with retry handler to get automatic retry behavior\",\n    \"Configure retry behavior (max attempts, delays, which errors trigger retries)\",\n    \"Receive callbacks when retries occur to track attempt progress\",\n    \"Get final result with number of attempts made\",\n    \"Non-retryable errors immediately throw without retry attempts\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"executeWithRetry\",\n      \"desc\": \"Executes an async operation with automatic retry logic and exponential backoff\",\n      \"inputs\": \"operation function to execute, optional retry configuration (maxRetries, delays, error types)\",\n      \"outputs\": \"Promise resolving to operation result with attempt count\"\n    },\n    {\n      \"name\": \"isRetryableError\",\n      \"desc\": \"Determines if an error should trigger a retry based on error type classification\",\n      \"inputs\": \"error object, list of retryable error patterns\",\n      \"outputs\": \"boolean indicating if error is retryable\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"Provides resilient LLM API communication by automatically handling transient failures like rate limits, timeouts, and network issues without requiring manual retry logic in calling code\"\n}\n```"
    },
    {
      "file": "src/ai/providers/ILLMProvider.ts",
      "role": "Core Logic",
      "purpose": "Defines the standard interface that all AI language model providers (like OpenAI, Claude, etc.) must implement for consistent interaction throughout the application.",
      "userVisibleActions": [
        "User receives AI-generated text responses to their queries",
        "User receives structured JSON data from AI requests when specific formats are needed",
        "User experiences consistent AI behavior regardless of which provider (OpenAI, Claude, etc.) is configured",
        "User sees AI responses that respect configured parameters like temperature and token limits"
      ],
      "developerVisibleActions": [
        "Developer implements this interface to add support for new AI providers",
        "Developer calls sendRequest() to get text responses from any configured AI provider",
        "Developer calls sendStructuredRequest() to get parsed JSON responses with optional schemas",
        "Developer checks isConfigured() to verify provider is ready before making requests",
        "Developer uses standardized message format with role and content for all providers",
        "Developer configures AI behavior using maxTokens, temperature, and responseFormat options",
        "Developer receives additional context like finish reasons and raw responses for debugging"
      ],
      "keyFunctions": [
        {
          "name": "isConfigured",
          "desc": "Verifies if the AI provider has valid credentials and is ready to accept requests",
          "inputs": "none",
          "outputs": "boolean indicating if provider is configured"
        },
        {
          "name": "sendRequest",
          "desc": "Sends a conversation to the AI provider and retrieves a text response",
          "inputs": "LLMRequestOptions containing model, messages, system prompt, and generation parameters",
          "outputs": "Promise<LLMResponse> with content string and metadata"
        },
        {
          "name": "sendStructuredRequest",
          "desc": "Sends a request expecting structured JSON output, with optional schema validation",
          "inputs": "LLMRequestOptions and optional schema definition",
          "outputs": "Promise<StructuredOutputResponse<T>> with parsed typed data and optional follow-up requests"
        },
        {
          "name": "getName",
          "desc": "Returns the human-readable name of the provider for identification",
          "inputs": "none",
          "outputs": "string with provider name"
        }
      ],
      "dependencies": [],
      "intent": "This file exists to create a unified abstraction layer over different AI providers (OpenAI, Claude, custom implementations), allowing the rest of the application to work with any AI provider through a consistent interface without needing to know provider-specific details. It solves the problem of vendor lock-in and makes the codebase provider-agnostic, enabling easy switching or addition of new AI providers.",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines the standard interface that all AI language model providers (like OpenAI, Claude, etc.) must implement for consistent interaction throughout the application.\",\n  \"userVisibleActions\": [\n    \"User receives AI-generated text responses to their queries\",\n    \"User receives structured JSON data from AI requests when specific formats are needed\",\n    \"User experiences consistent AI behavior regardless of which provider (OpenAI, Claude, etc.) is configured\",\n    \"User sees AI responses that respect configured parameters like temperature and token limits\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer implements this interface to add support for new AI providers\",\n    \"Developer calls sendRequest() to get text responses from any configured AI provider\",\n    \"Developer calls sendStructuredRequest() to get parsed JSON responses with optional schemas\",\n    \"Developer checks isConfigured() to verify provider is ready before making requests\",\n    \"Developer uses standardized message format with role and content for all providers\",\n    \"Developer configures AI behavior using maxTokens, temperature, and responseFormat options\",\n    \"Developer receives additional context like finish reasons and raw responses for debugging\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"isConfigured\",\n      \"desc\": \"Verifies if the AI provider has valid credentials and is ready to accept requests\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean indicating if provider is configured\"\n    },\n    {\n      \"name\": \"sendRequest\",\n      \"desc\": \"Sends a conversation to the AI provider and retrieves a text response\",\n      \"inputs\": \"LLMRequestOptions containing model, messages, system prompt, and generation parameters\",\n      \"outputs\": \"Promise<LLMResponse> with content string and metadata\"\n    },\n    {\n      \"name\": \"sendStructuredRequest\",\n      \"desc\": \"Sends a request expecting structured JSON output, with optional schema validation\",\n      \"inputs\": \"LLMRequestOptions and optional schema definition\",\n      \"outputs\": \"Promise<StructuredOutputResponse<T>> with parsed typed data and optional follow-up requests\"\n    },\n    {\n      \"name\": \"getName\",\n      \"desc\": \"Returns the human-readable name of the provider for identification\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string with provider name\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"This file exists to create a unified abstraction layer over different AI providers (OpenAI, Claude, custom implementations), allowing the rest of the application to work with any AI provider through a consistent interface without needing to know provider-specific details. It solves the problem of vendor lock-in and makes the codebase provider-agnostic, enabling easy switching or addition of new AI providers.\"\n}\n```"
    },
    {
      "file": "src/ai/providers/anthropicProvider.ts",
      "role": "Core Logic",
      "purpose": "Integrates Anthropic's Claude AI models as an LLM provider for generating AI responses and structured outputs in the application",
      "userVisibleActions": [
        "Sends prompts to Claude AI and receives text responses",
        "Generates structured JSON outputs from Claude based on schemas",
        "Receives error messages when Claude API is not configured",
        "Experiences AI-powered features using Claude's language models"
      ],
      "developerVisibleActions": [
        "Configure Claude API key through configuration manager to enable the provider",
        "Send requests with custom models, system prompts, and message histories",
        "Request structured JSON outputs with schema validation",
        "Handle Claude-specific message format conversions automatically",
        "Set custom token limits (default 8192 for Claude Sonnet)",
        "Receive extracted JSON from Claude's text responses",
        "Check if provider is configured before use"
      ],
      "keyFunctions": [
        {
          "name": "initialize",
          "desc": "Sets up the Claude API client with API key from configuration",
          "inputs": "None (reads from config manager)",
          "outputs": "void (sets up internal client)"
        },
        {
          "name": "isConfigured",
          "desc": "Checks if Claude provider is ready to use",
          "inputs": "None",
          "outputs": "boolean indicating if API key is configured"
        },
        {
          "name": "getName",
          "desc": "Returns the provider identifier",
          "inputs": "None",
          "outputs": "'claude' string"
        },
        {
          "name": "sendRequest",
          "desc": "Sends a prompt to Claude and returns the AI response",
          "inputs": "LLMRequestOptions (messages, model, systemPrompt, maxTokens)",
          "outputs": "LLMResponse with content and token usage"
        },
        {
          "name": "sendStructuredOutputRequest",
          "desc": "Requests a JSON response from Claude conforming to a schema",
          "inputs": "LLMRequestOptions with schema definition",
          "outputs": "StructuredOutputResponse with extracted JSON data"
        }
      ],
      "dependencies": [
        "@anthropic-ai/sdk",
        "../../config/configurationManager",
        "../../utils/jsonExtractor",
        "./ILLMProvider"
      ],
      "intent": "Provides a unified interface to Anthropic's Claude AI models, handling API authentication, message format conversion, and response parsing so the application can seamlessly integrate Claude as one of multiple LLM providers without knowing Claude-specific implementation details",
      "rawContent": "```json\n{\n  \"purpose\": \"Integrates Anthropic's Claude AI models as an LLM provider for generating AI responses and structured outputs in the application\",\n  \"userVisibleActions\": [\n    \"Sends prompts to Claude AI and receives text responses\",\n    \"Generates structured JSON outputs from Claude based on schemas\",\n    \"Receives error messages when Claude API is not configured\",\n    \"Experiences AI-powered features using Claude's language models\"\n  ],\n  \"developerVisibleActions\": [\n    \"Configure Claude API key through configuration manager to enable the provider\",\n    \"Send requests with custom models, system prompts, and message histories\",\n    \"Request structured JSON outputs with schema validation\",\n    \"Handle Claude-specific message format conversions automatically\",\n    \"Set custom token limits (default 8192 for Claude Sonnet)\",\n    \"Receive extracted JSON from Claude's text responses\",\n    \"Check if provider is configured before use\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initialize\",\n      \"desc\": \"Sets up the Claude API client with API key from configuration\",\n      \"inputs\": \"None (reads from config manager)\",\n      \"outputs\": \"void (sets up internal client)\"\n    },\n    {\n      \"name\": \"isConfigured\",\n      \"desc\": \"Checks if Claude provider is ready to use\",\n      \"inputs\": \"None\",\n      \"outputs\": \"boolean indicating if API key is configured\"\n    },\n    {\n      \"name\": \"getName\",\n      \"desc\": \"Returns the provider identifier\",\n      \"inputs\": \"None\",\n      \"outputs\": \"'claude' string\"\n    },\n    {\n      \"name\": \"sendRequest\",\n      \"desc\": \"Sends a prompt to Claude and returns the AI response\",\n      \"inputs\": \"LLMRequestOptions (messages, model, systemPrompt, maxTokens)\",\n      \"outputs\": \"LLMResponse with content and token usage\"\n    },\n    {\n      \"name\": \"sendStructuredOutputRequest\",\n      \"desc\": \"Requests a JSON response from Claude conforming to a schema\",\n      \"inputs\": \"LLMRequestOptions with schema definition\",\n      \"outputs\": \"StructuredOutputResponse with extracted JSON data\"\n    }\n  ],\n  \"dependencies\": [\n    \"@anthropic-ai/sdk\",\n    \"../../config/configurationManager\",\n    \"../../utils/jsonExtractor\",\n    \"./ILLMProvider\"\n  ],\n  \"intent\": \"Provides a unified interface to Anthropic's Claude AI models, handling API authentication, message format conversion, and response parsing so the application can seamlessly integrate Claude as one of multiple LLM providers without knowing Claude-specific implementation details\"\n}\n```"
    },
    {
      "file": "src/ai/providers/openAIProvider.ts",
      "role": "Core Logic",
      "purpose": "Implements OpenAI API integration to send chat requests and receive responses from GPT models",
      "userVisibleActions": [
        "Enables AI-powered chat interactions using OpenAI's GPT models",
        "Provides structured JSON responses from AI when requested",
        "Returns AI-generated text content based on user prompts",
        "Shows error when OpenAI API key is not configured"
      ],
      "developerVisibleActions": [
        "Configure OpenAI API key through configuration manager",
        "Send chat messages with optional system prompts to OpenAI",
        "Request structured JSON outputs from the AI model",
        "Check if OpenAI provider is properly configured before use",
        "Handle token usage and cost tracking from API responses",
        "Set custom models (defaults to gpt-4o)",
        "Automatically extract JSON from AI responses"
      ],
      "keyFunctions": [
        {
          "name": "initialize",
          "desc": "Sets up OpenAI client with API key from configuration",
          "inputs": "None (reads from config)",
          "outputs": "Initializes client or sets to null if no key"
        },
        {
          "name": "isConfigured",
          "desc": "Checks if the OpenAI provider is ready to use",
          "inputs": "None",
          "outputs": "Boolean indicating if API key is set"
        },
        {
          "name": "getName",
          "desc": "Returns the provider identifier",
          "inputs": "None",
          "outputs": "String 'openai'"
        },
        {
          "name": "sendRequest",
          "desc": "Sends a chat completion request to OpenAI and returns the response",
          "inputs": "LLMRequestOptions (model, messages, systemPrompt, responseFormat)",
          "outputs": "LLMResponse with content, finish reason, and token usage"
        },
        {
          "name": "requestStructuredOutput",
          "desc": "Requests AI response in JSON format and parses it",
          "inputs": "LLMRequestOptions with JSON schema",
          "outputs": "StructuredOutputResponse with parsed JSON object or null"
        }
      ],
      "dependencies": [
        "openai",
        "../../config/configurationManager",
        "../../utils/jsonExtractor",
        "./ILLMProvider"
      ],
      "intent": "This file exists to provide a concrete implementation of the LLM provider interface specifically for OpenAI's API, enabling the application to communicate with GPT models for AI-powered features. It solves the problem of abstracting OpenAI-specific API calls behind a common interface while handling configuration, error cases, and response parsing including structured JSON outputs.",
      "rawContent": "```json\n{\n  \"purpose\": \"Implements OpenAI API integration to send chat requests and receive responses from GPT models\",\n  \"userVisibleActions\": [\n    \"Enables AI-powered chat interactions using OpenAI's GPT models\",\n    \"Provides structured JSON responses from AI when requested\",\n    \"Returns AI-generated text content based on user prompts\",\n    \"Shows error when OpenAI API key is not configured\"\n  ],\n  \"developerVisibleActions\": [\n    \"Configure OpenAI API key through configuration manager\",\n    \"Send chat messages with optional system prompts to OpenAI\",\n    \"Request structured JSON outputs from the AI model\",\n    \"Check if OpenAI provider is properly configured before use\",\n    \"Handle token usage and cost tracking from API responses\",\n    \"Set custom models (defaults to gpt-4o)\",\n    \"Automatically extract JSON from AI responses\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initialize\",\n      \"desc\": \"Sets up OpenAI client with API key from configuration\",\n      \"inputs\": \"None (reads from config)\",\n      \"outputs\": \"Initializes client or sets to null if no key\"\n    },\n    {\n      \"name\": \"isConfigured\",\n      \"desc\": \"Checks if the OpenAI provider is ready to use\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Boolean indicating if API key is set\"\n    },\n    {\n      \"name\": \"getName\",\n      \"desc\": \"Returns the provider identifier\",\n      \"inputs\": \"None\",\n      \"outputs\": \"String 'openai'\"\n    },\n    {\n      \"name\": \"sendRequest\",\n      \"desc\": \"Sends a chat completion request to OpenAI and returns the response\",\n      \"inputs\": \"LLMRequestOptions (model, messages, systemPrompt, responseFormat)\",\n      \"outputs\": \"LLMResponse with content, finish reason, and token usage\"\n    },\n    {\n      \"name\": \"requestStructuredOutput\",\n      \"desc\": \"Requests AI response in JSON format and parses it\",\n      \"inputs\": \"LLMRequestOptions with JSON schema\",\n      \"outputs\": \"StructuredOutputResponse with parsed JSON object or null\"\n    }\n  ],\n  \"dependencies\": [\n    \"openai\",\n    \"../../config/configurationManager\",\n    \"../../utils/jsonExtractor\",\n    \"./ILLMProvider\"\n  ],\n  \"intent\": \"This file exists to provide a concrete implementation of the LLM provider interface specifically for OpenAI's API, enabling the application to communicate with GPT models for AI-powered features. It solves the problem of abstracting OpenAI-specific API calls behind a common interface while handling configuration, error cases, and response parsing including structured JSON outputs.\"\n}\n```"
    },
    {
      "file": "src/ai/providers/providerFactory.ts",
      "role": "Core Logic",
      "purpose": "Creates and manages AI provider instances (OpenAI and Claude) based on configuration settings",
      "userVisibleActions": [
        "Switches between different AI providers (OpenAI or Claude) based on user configuration",
        "Automatically uses the AI provider that is properly configured with API keys",
        "Provides list of available AI providers that have been configured"
      ],
      "developerVisibleActions": [
        "Provides a single factory to get any AI provider instance without manual instantiation",
        "Manages provider lifecycle by reusing existing instances instead of creating duplicates",
        "Reads from configuration manager to determine which AI provider to use",
        "Validates if a provider has required API keys and configuration before use",
        "Throws error when requesting an unknown or unsupported provider type"
      ],
      "keyFunctions": [
        {
          "name": "getProvider",
          "desc": "Returns an instance of the specified AI provider (OpenAI or Claude)",
          "inputs": "provider: 'openai' | 'claude'",
          "outputs": "ILLMProvider instance"
        },
        {
          "name": "getCurrentProvider",
          "desc": "Returns the AI provider instance based on current user configuration",
          "inputs": "none",
          "outputs": "ILLMProvider instance for the configured provider"
        },
        {
          "name": "isProviderConfigured",
          "desc": "Checks if a specific AI provider has valid configuration and API keys",
          "inputs": "provider: 'openai' | 'claude'",
          "outputs": "boolean indicating if provider is ready to use"
        },
        {
          "name": "getConfiguredProviders",
          "desc": "Returns list of all AI providers that are properly configured",
          "inputs": "none",
          "outputs": "Array of configured provider names"
        }
      ],
      "dependencies": [
        "./ILLMProvider",
        "./openAIProvider",
        "./anthropicProvider",
        "../../config/configurationManager"
      ],
      "intent": "This file exists to centralize AI provider creation and management, ensuring only one instance of each provider exists, automatically selecting the correct provider based on user settings, and validating provider configuration before use. It solves the problem of scattered provider instantiation and simplifies switching between different AI services.",
      "rawContent": "```json\n{\n  \"purpose\": \"Creates and manages AI provider instances (OpenAI and Claude) based on configuration settings\",\n  \"userVisibleActions\": [\n    \"Switches between different AI providers (OpenAI or Claude) based on user configuration\",\n    \"Automatically uses the AI provider that is properly configured with API keys\",\n    \"Provides list of available AI providers that have been configured\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provides a single factory to get any AI provider instance without manual instantiation\",\n    \"Manages provider lifecycle by reusing existing instances instead of creating duplicates\",\n    \"Reads from configuration manager to determine which AI provider to use\",\n    \"Validates if a provider has required API keys and configuration before use\",\n    \"Throws error when requesting an unknown or unsupported provider type\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getProvider\",\n      \"desc\": \"Returns an instance of the specified AI provider (OpenAI or Claude)\",\n      \"inputs\": \"provider: 'openai' | 'claude'\",\n      \"outputs\": \"ILLMProvider instance\"\n    },\n    {\n      \"name\": \"getCurrentProvider\",\n      \"desc\": \"Returns the AI provider instance based on current user configuration\",\n      \"inputs\": \"none\",\n      \"outputs\": \"ILLMProvider instance for the configured provider\"\n    },\n    {\n      \"name\": \"isProviderConfigured\",\n      \"desc\": \"Checks if a specific AI provider has valid configuration and API keys\",\n      \"inputs\": \"provider: 'openai' | 'claude'\",\n      \"outputs\": \"boolean indicating if provider is ready to use\"\n    },\n    {\n      \"name\": \"getConfiguredProviders\",\n      \"desc\": \"Returns list of all AI providers that are properly configured\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of configured provider names\"\n    }\n  ],\n  \"dependencies\": [\n    \"./ILLMProvider\",\n    \"./openAIProvider\",\n    \"./anthropicProvider\",\n    \"../../config/configurationManager\"\n  ],\n  \"intent\": \"This file exists to centralize AI provider creation and management, ensuring only one instance of each provider exists, automatically selecting the correct provider based on user settings, and validating provider configuration before use. It solves the problem of scattered provider instantiation and simplifies switching between different AI services.\"\n}\n```"
    },
    {
      "file": "src/analysis/enhancedAnalyzer.ts",
      "role": "Core Logic",
      "purpose": "Performs deep code analysis by parsing Abstract Syntax Trees (AST) to extract detailed function metadata including branches, dependencies, state mutations, and behavioral hints.",
      "userVisibleActions": [
        "Provides detailed insights about code behavior and function characteristics",
        "Shows branch complexity and decision points in code",
        "Reveals dependencies between code modules and functions",
        "Identifies state mutations and side effects in functions",
        "Maps test coverage to functions"
      ],
      "developerVisibleActions": [
        "Analyzes TypeScript/JavaScript files using AST parsing to extract function metadata",
        "Extracts branch information (if/else, switch, loops) from function bodies",
        "Profiles dependencies between functions and external modules",
        "Detects state mutations and tracks which variables/objects are modified",
        "Generates behavioral hints about function purpose and side effects",
        "Maps test files to source code functions",
        "Provides fallback regex-based analysis for non-TypeScript languages",
        "Returns structured metadata including complexity metrics and code patterns"
      ],
      "keyFunctions": [
        {
          "name": "analyzeFileMetadata",
          "desc": "Analyzes a single code file and extracts enhanced metadata for all functions in it",
          "inputs": "filePath: string, content: string, language: string, functions: FunctionInfo[]",
          "outputs": "Map<string, FunctionMetadata> containing detailed function analysis"
        },
        {
          "name": "analyzeTypeScriptFunction",
          "desc": "Uses TypeScript AST parser to deeply analyze a function's structure, branches, dependencies, and behavior",
          "inputs": "filePath: string, content: string, func: FunctionInfo, functionContent: string",
          "outputs": "FunctionMetadata with AST-derived insights"
        },
        {
          "name": "analyzeFunctionWithRegex",
          "desc": "Provides basic function analysis using pattern matching for languages without AST support",
          "inputs": "filePath: string, func: FunctionInfo, functionContent: string, language: string",
          "outputs": "FunctionMetadata with regex-based analysis"
        },
        {
          "name": "extractFunctionContent",
          "desc": "Extracts the source code content of a function between specified line numbers",
          "inputs": "content: string, startLine: number, endLine: number",
          "outputs": "string containing the function's source code"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "typescript",
        "../analyzer"
      ],
      "intent": "This file exists to provide advanced code analysis capabilities beyond basic syntax parsing. It solves the problem of understanding code behavior, complexity, and relationships by parsing the AST structure, enabling features like intelligent test generation, code documentation, and dependency mapping. It bridges the gap between simple text analysis and deep semantic understanding of code.",
      "rawContent": "```json\n{\n  \"purpose\": \"Performs deep code analysis by parsing Abstract Syntax Trees (AST) to extract detailed function metadata including branches, dependencies, state mutations, and behavioral hints.\",\n  \"userVisibleActions\": [\n    \"Provides detailed insights about code behavior and function characteristics\",\n    \"Shows branch complexity and decision points in code\",\n    \"Reveals dependencies between code modules and functions\",\n    \"Identifies state mutations and side effects in functions\",\n    \"Maps test coverage to functions\"\n  ],\n  \"developerVisibleActions\": [\n    \"Analyzes TypeScript/JavaScript files using AST parsing to extract function metadata\",\n    \"Extracts branch information (if/else, switch, loops) from function bodies\",\n    \"Profiles dependencies between functions and external modules\",\n    \"Detects state mutations and tracks which variables/objects are modified\",\n    \"Generates behavioral hints about function purpose and side effects\",\n    \"Maps test files to source code functions\",\n    \"Provides fallback regex-based analysis for non-TypeScript languages\",\n    \"Returns structured metadata including complexity metrics and code patterns\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeFileMetadata\",\n      \"desc\": \"Analyzes a single code file and extracts enhanced metadata for all functions in it\",\n      \"inputs\": \"filePath: string, content: string, language: string, functions: FunctionInfo[]\",\n      \"outputs\": \"Map<string, FunctionMetadata> containing detailed function analysis\"\n    },\n    {\n      \"name\": \"analyzeTypeScriptFunction\",\n      \"desc\": \"Uses TypeScript AST parser to deeply analyze a function's structure, branches, dependencies, and behavior\",\n      \"inputs\": \"filePath: string, content: string, func: FunctionInfo, functionContent: string\",\n      \"outputs\": \"FunctionMetadata with AST-derived insights\"\n    },\n    {\n      \"name\": \"analyzeFunctionWithRegex\",\n      \"desc\": \"Provides basic function analysis using pattern matching for languages without AST support\",\n      \"inputs\": \"filePath: string, func: FunctionInfo, functionContent: string, language: string\",\n      \"outputs\": \"FunctionMetadata with regex-based analysis\"\n    },\n    {\n      \"name\": \"extractFunctionContent\",\n      \"desc\": \"Extracts the source code content of a function between specified line numbers\",\n      \"inputs\": \"content: string, startLine: number, endLine: number\",\n      \"outputs\": \"string containing the function's source code\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"typescript\",\n    \"../analyzer\"\n  ],\n  \"intent\": \"This file exists to provide advanced code analysis capabilities beyond basic syntax parsing. It solves the problem of understanding code behavior, complexity, and relationships by parsing the AST structure, enabling features like intelligent test generation, code documentation, and dependency mapping. It bridges the gap between simple text analysis and deep semantic understanding of code.\"\n}\n```"
    },
    {
      "file": "src/analysis/functionAnalyzer.ts",
      "role": "Core Logic",
      "purpose": "Analyzes functions in large code files to extract detailed information for generating refactoring reports",
      "userVisibleActions": [
        "Generates detailed analysis reports for functions in large files",
        "Identifies functions that exceed size thresholds and may need refactoring",
        "Provides function signatures, dependencies, and responsibilities in refactoring reports",
        "Shows which functions call or are called by other functions"
      ],
      "developerVisibleActions": [
        "Analyzes all functions in files exceeding a specified line threshold (default 500 lines)",
        "Extracts function metadata including signatures, parameters, return types",
        "Identifies function dependencies (what the function calls)",
        "Identifies function dependents (what calls this function)",
        "Determines function responsibilities by analyzing code behavior",
        "Resolves file paths from the code analysis results",
        "Handles analysis errors gracefully with warnings",
        "Returns structured FunctionAnalysis objects for report generation"
      ],
      "keyFunctions": [
        {
          "name": "analyzeFunctions",
          "desc": "Analyzes all functions in large files and extracts detailed information for refactoring",
          "inputs": "codeAnalysis (full code analysis results), largeFileThreshold (line count threshold, default 500)",
          "outputs": "Array of FunctionAnalysis objects containing detailed function information"
        },
        {
          "name": "analyzeFunction",
          "desc": "Performs detailed analysis of a single function including dependencies and responsibilities",
          "inputs": "filePath (file location), func (function info object), codeAnalysis (full analysis context)",
          "outputs": "FunctionAnalysis object with complete function details, or null if analysis fails"
        },
        {
          "name": "resolveFilePath",
          "desc": "Resolves relative or absolute file paths to full file system paths",
          "inputs": "filePath (path to resolve), codeAnalysis (context for resolution)",
          "outputs": "Full resolved file path"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "typescript",
        "../analyzer",
        "../domain/prompts/refactoringPromptBuilder"
      ],
      "intent": "This file exists to provide detailed function-level analysis for code refactoring recommendations. It extracts comprehensive information about functions in large files (signatures, dependencies, relationships) that can be used to generate intelligent refactoring suggestions and reports, helping developers identify functions that may benefit from restructuring or breaking into smaller components.",
      "rawContent": "```json\n{\n  \"purpose\": \"Analyzes functions in large code files to extract detailed information for generating refactoring reports\",\n  \"userVisibleActions\": [\n    \"Generates detailed analysis reports for functions in large files\",\n    \"Identifies functions that exceed size thresholds and may need refactoring\",\n    \"Provides function signatures, dependencies, and responsibilities in refactoring reports\",\n    \"Shows which functions call or are called by other functions\"\n  ],\n  \"developerVisibleActions\": [\n    \"Analyzes all functions in files exceeding a specified line threshold (default 500 lines)\",\n    \"Extracts function metadata including signatures, parameters, return types\",\n    \"Identifies function dependencies (what the function calls)\",\n    \"Identifies function dependents (what calls this function)\",\n    \"Determines function responsibilities by analyzing code behavior\",\n    \"Resolves file paths from the code analysis results\",\n    \"Handles analysis errors gracefully with warnings\",\n    \"Returns structured FunctionAnalysis objects for report generation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeFunctions\",\n      \"desc\": \"Analyzes all functions in large files and extracts detailed information for refactoring\",\n      \"inputs\": \"codeAnalysis (full code analysis results), largeFileThreshold (line count threshold, default 500)\",\n      \"outputs\": \"Array of FunctionAnalysis objects containing detailed function information\"\n    },\n    {\n      \"name\": \"analyzeFunction\",\n      \"desc\": \"Performs detailed analysis of a single function including dependencies and responsibilities\",\n      \"inputs\": \"filePath (file location), func (function info object), codeAnalysis (full analysis context)\",\n      \"outputs\": \"FunctionAnalysis object with complete function details, or null if analysis fails\"\n    },\n    {\n      \"name\": \"resolveFilePath\",\n      \"desc\": \"Resolves relative or absolute file paths to full file system paths\",\n      \"inputs\": \"filePath (path to resolve), codeAnalysis (context for resolution)\",\n      \"outputs\": \"Full resolved file path\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"typescript\",\n    \"../analyzer\",\n    \"../domain/prompts/refactoringPromptBuilder\"\n  ],\n  \"intent\": \"This file exists to provide detailed function-level analysis for code refactoring recommendations. It extracts comprehensive information about functions in large files (signatures, dependencies, relationships) that can be used to generate intelligent refactoring suggestions and reports, helping developers identify functions that may benefit from restructuring or breaking into smaller components.\"\n}\n```"
    },
    {
      "file": "src/analysisViewer.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view panel that displays code analysis results including statistics, files, functions, and entry points in a browsable hierarchical structure",
      "userVisibleActions": [
        "View a tree structure showing code analysis results in the sidebar",
        "Browse statistics about the analyzed codebase (file count, line count, function count)",
        "Navigate through files and directories in the analysis",
        "See file details including line count, function count, import/export count, and complexity",
        "Browse all functions with their metadata (lines of code, complexity, parameters)",
        "View entry points (main functions, exported items, test files)",
        "Click on items to jump to their location in the source code",
        "See grouped views of files by directory structure",
        "See message 'No analysis available' when no analysis has been run yet",
        "Refresh the tree view to see updated analysis results"
      ],
      "developerVisibleActions": [
        "Set analysis data by calling setAnalysis() to populate the tree view",
        "Manually refresh the tree view by calling refresh()",
        "Receive click events when users select items in the tree",
        "Display hierarchical analysis data organized by categories (statistics, files, functions, entry points)",
        "Show tooltips with additional information on hover",
        "Handle navigation to specific file locations when items are clicked",
        "Display icons for different item types (files, functions, directories, statistics)",
        "Organize files by directory structure for easier navigation"
      ],
      "keyFunctions": [
        {
          "name": "setAnalysis",
          "desc": "Sets the code analysis data to display in the tree view and triggers a refresh",
          "inputs": "analysis: CodeAnalysis | null",
          "outputs": "void"
        },
        {
          "name": "refresh",
          "desc": "Refreshes the tree view to update displayed data",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getTreeItem",
          "desc": "Returns the tree item representation for display in VS Code",
          "inputs": "element: AnalysisItem",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child items for a given tree node to build the hierarchy",
          "inputs": "element?: AnalysisItem",
          "outputs": "Thenable<AnalysisItem[]>"
        },
        {
          "name": "getRootItems",
          "desc": "Returns top-level categories shown in the tree (statistics, files, functions, entry points)",
          "inputs": "none",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getStatisticsItems",
          "desc": "Returns statistical summary items (total files, lines, functions, etc.)",
          "inputs": "none",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getFilesItems",
          "desc": "Returns all analyzed files organized by directory structure",
          "inputs": "none",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getFileDetails",
          "desc": "Returns detailed information about a specific file (line count, functions, imports, exports)",
          "inputs": "element: AnalysisItem",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getDirectoryFiles",
          "desc": "Returns all files within a specific directory",
          "inputs": "element: AnalysisItem",
          "outputs": "AnalysisItem[]"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "./analyzer (CodeAnalysis, FileInfo, FunctionInfo, EntryPoint types)"
      ],
      "intent": "This file exists to provide developers with an interactive, browsable view of their codebase analysis results directly in VS Code's sidebar, making it easy to explore code metrics, navigate to specific functions or files, and understand the structure and complexity of their project at a glance",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view panel that displays code analysis results including statistics, files, functions, and entry points in a browsable hierarchical structure\",\n  \"userVisibleActions\": [\n    \"View a tree structure showing code analysis results in the sidebar\",\n    \"Browse statistics about the analyzed codebase (file count, line count, function count)\",\n    \"Navigate through files and directories in the analysis\",\n    \"See file details including line count, function count, import/export count, and complexity\",\n    \"Browse all functions with their metadata (lines of code, complexity, parameters)\",\n    \"View entry points (main functions, exported items, test files)\",\n    \"Click on items to jump to their location in the source code\",\n    \"See grouped views of files by directory structure\",\n    \"See message 'No analysis available' when no analysis has been run yet\",\n    \"Refresh the tree view to see updated analysis results\"\n  ],\n  \"developerVisibleActions\": [\n    \"Set analysis data by calling setAnalysis() to populate the tree view\",\n    \"Manually refresh the tree view by calling refresh()\",\n    \"Receive click events when users select items in the tree\",\n    \"Display hierarchical analysis data organized by categories (statistics, files, functions, entry points)\",\n    \"Show tooltips with additional information on hover\",\n    \"Handle navigation to specific file locations when items are clicked\",\n    \"Display icons for different item types (files, functions, directories, statistics)\",\n    \"Organize files by directory structure for easier navigation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setAnalysis\",\n      \"desc\": \"Sets the code analysis data to display in the tree view and triggers a refresh\",\n      \"inputs\": \"analysis: CodeAnalysis | null\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Refreshes the tree view to update displayed data\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the tree item representation for display in VS Code\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for a given tree node to build the hierarchy\",\n      \"inputs\": \"element?: AnalysisItem\",\n      \"outputs\": \"Thenable<AnalysisItem[]>\"\n    },\n    {\n      \"name\": \"getRootItems\",\n      \"desc\": \"Returns top-level categories shown in the tree (statistics, files, functions, entry points)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getStatisticsItems\",\n      \"desc\": \"Returns statistical summary items (total files, lines, functions, etc.)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getFilesItems\",\n      \"desc\": \"Returns all analyzed files organized by directory structure\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getFileDetails\",\n      \"desc\": \"Returns detailed information about a specific file (line count, functions, imports, exports)\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getDirectoryFiles\",\n      \"desc\": \"Returns all files within a specific directory\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"AnalysisItem[]\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./analyzer (CodeAnalysis, FileInfo, FunctionInfo, EntryPoint types)\"\n  ],\n  \"intent\": \"This file exists to provide developers with an interactive, browsable view of their codebase analysis results directly in VS Code's sidebar, making it easy to explore code metrics, navigate to specific functions or files, and understand the structure and complexity of their project at a glance\"\n}\n```"
    },
    {
      "file": "src/analyzer.ts",
      "role": "Core Logic",
      "purpose": "Defines the core data structures and interfaces for code analysis results, including file metadata, function signatures, dependencies, test mappings, and code duplication detection.",
      "userVisibleActions": [
        "See analysis results showing total files, lines, and functions in their codebase",
        "View list of large files that may need refactoring",
        "Identify orphaned files that are not imported anywhere",
        "Discover entry points (main functions) in the codebase",
        "Find duplicate code blocks across files",
        "See which functions are not covered by tests",
        "View function complexity and risk levels (high/medium/low)",
        "Understand function dependencies on databases, HTTP, filesystem, and other external resources"
      ],
      "developerVisibleActions": [
        "Import and use CodeAnalysis interface to structure analysis results",
        "Access file information including path, lines of code, complexity metrics, and roles",
        "Query function metadata including parameters, return types, visibility, and documentation",
        "Retrieve import relationships between files to understand module dependencies",
        "Access test mapping data to see which tests cover which source files and functions",
        "Use FunctionMetadata to get detailed function signatures, branches, and state mutations",
        "Access duplicate code detection results grouped by similarity hash",
        "Query dependency information to identify external service integrations",
        "Use AnalysisCache for caching and retrieving analysis results"
      ],
      "keyFunctions": [
        {
          "name": "CodeAnalysis",
          "desc": "Primary interface containing complete codebase analysis results",
          "inputs": "None (interface definition)",
          "outputs": "Structured data with file counts, function lists, imports, orphaned files, entry points, duplicates, and optional enhanced metadata"
        },
        {
          "name": "FunctionMetadata",
          "desc": "Detailed metadata for a single function including signature, documentation, control flow, and dependencies",
          "inputs": "None (interface definition)",
          "outputs": "Function name, parameters, return type, visibility, branches, dependencies, state mutations, risk level, and line numbers"
        },
        {
          "name": "TestMapping",
          "desc": "Maps source files and functions to their corresponding test coverage",
          "inputs": "None (interface definition)",
          "outputs": "Source-to-test file mappings, function-to-test mappings, and list of uncovered functions"
        },
        {
          "name": "DependencyInfo",
          "desc": "Describes external and internal dependencies used by functions",
          "inputs": "None (interface definition)",
          "outputs": "Dependency name, type (db/http/filesystem/etc), whether it's internal, and line number"
        },
        {
          "name": "BranchInfo",
          "desc": "Represents control flow branches in code (if/else/loop/try/catch)",
          "inputs": "None (interface definition)",
          "outputs": "Branch type, human-readable condition description, and line number"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./cache"
      ],
      "intent": "This file exists to establish a standardized schema for code analysis results across the entire application. It solves the problem of consistently representing complex code structure information (functions, dependencies, tests, duplicates) in a way that different parts of the system can understand and use, enabling features like test coverage visualization, dependency tracking, code quality assessment, and duplicate detection.",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines the core data structures and interfaces for code analysis results, including file metadata, function signatures, dependencies, test mappings, and code duplication detection.\",\n  \"userVisibleActions\": [\n    \"See analysis results showing total files, lines, and functions in their codebase\",\n    \"View list of large files that may need refactoring\",\n    \"Identify orphaned files that are not imported anywhere\",\n    \"Discover entry points (main functions) in the codebase\",\n    \"Find duplicate code blocks across files\",\n    \"See which functions are not covered by tests\",\n    \"View function complexity and risk levels (high/medium/low)\",\n    \"Understand function dependencies on databases, HTTP, filesystem, and other external resources\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import and use CodeAnalysis interface to structure analysis results\",\n    \"Access file information including path, lines of code, complexity metrics, and roles\",\n    \"Query function metadata including parameters, return types, visibility, and documentation\",\n    \"Retrieve import relationships between files to understand module dependencies\",\n    \"Access test mapping data to see which tests cover which source files and functions\",\n    \"Use FunctionMetadata to get detailed function signatures, branches, and state mutations\",\n    \"Access duplicate code detection results grouped by similarity hash\",\n    \"Query dependency information to identify external service integrations\",\n    \"Use AnalysisCache for caching and retrieving analysis results\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"CodeAnalysis\",\n      \"desc\": \"Primary interface containing complete codebase analysis results\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Structured data with file counts, function lists, imports, orphaned files, entry points, duplicates, and optional enhanced metadata\"\n    },\n    {\n      \"name\": \"FunctionMetadata\",\n      \"desc\": \"Detailed metadata for a single function including signature, documentation, control flow, and dependencies\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Function name, parameters, return type, visibility, branches, dependencies, state mutations, risk level, and line numbers\"\n    },\n    {\n      \"name\": \"TestMapping\",\n      \"desc\": \"Maps source files and functions to their corresponding test coverage\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Source-to-test file mappings, function-to-test mappings, and list of uncovered functions\"\n    },\n    {\n      \"name\": \"DependencyInfo\",\n      \"desc\": \"Describes external and internal dependencies used by functions\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Dependency name, type (db/http/filesystem/etc), whether it's internal, and line number\"\n    },\n    {\n      \"name\": \"BranchInfo\",\n      \"desc\": \"Represents control flow branches in code (if/else/loop/try/catch)\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Branch type, human-readable condition description, and line number\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./cache\"\n  ],\n  \"intent\": \"This file exists to establish a standardized schema for code analysis results across the entire application. It solves the problem of consistently representing complex code structure information (functions, dependencies, tests, duplicates) in a way that different parts of the system can understand and use, enabling features like test coverage visualization, dependency tracking, code quality assessment, and duplicate detection.\"\n}\n```"
    },
    {
      "file": "src/cache.ts",
      "role": "Core Logic",
      "purpose": "Manages persistent storage and retrieval of code analysis results with automatic expiration",
      "userVisibleActions": [
        "Analysis results load instantly when reopening a workspace (if cached within 24 hours)",
        "Analysis cache automatically expires after 24 hours, triggering fresh analysis",
        "Cache can be manually cleared to force fresh analysis"
      ],
      "developerVisibleActions": [
        "Cache directory (.shadowwatch-cache) is created in the specified storage path",
        "Analysis results are automatically saved after each analysis completes",
        "Cache files are named using base64-encoded workspace paths",
        "Stale cache entries (older than 24 hours) are automatically ignored",
        "Cache read/write errors are logged to console but don't block operations"
      ],
      "keyFunctions": [
        {
          "name": "constructor",
          "desc": "Initializes cache with storage location and creates cache directory",
          "inputs": "storagePath: string",
          "outputs": "AnalysisCache instance"
        },
        {
          "name": "getCacheKey",
          "desc": "Generates safe filename from workspace path for cache storage",
          "inputs": "workspaceRoot: string",
          "outputs": "base64-encoded string suitable for filename"
        },
        {
          "name": "get",
          "desc": "Retrieves cached analysis for workspace if exists and not expired",
          "inputs": "workspaceRoot: string",
          "outputs": "Promise<CodeAnalysis | null> - cached data or null if missing/expired"
        },
        {
          "name": "set",
          "desc": "Saves analysis results to cache with current timestamp",
          "inputs": "workspaceRoot: string, data: CodeAnalysis",
          "outputs": "Promise<void>"
        },
        {
          "name": "clear",
          "desc": "Removes all cached analysis files from cache directory",
          "inputs": "none",
          "outputs": "Promise<void>"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./analyzer (CodeAnalysis type)"
      ],
      "intent": "Improves extension performance by caching expensive code analysis results, avoiding redundant analysis when reopening workspaces while ensuring cached data doesn't become stale through time-based expiration",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages persistent storage and retrieval of code analysis results with automatic expiration\",\n  \"userVisibleActions\": [\n    \"Analysis results load instantly when reopening a workspace (if cached within 24 hours)\",\n    \"Analysis cache automatically expires after 24 hours, triggering fresh analysis\",\n    \"Cache can be manually cleared to force fresh analysis\"\n  ],\n  \"developerVisibleActions\": [\n    \"Cache directory (.shadowwatch-cache) is created in the specified storage path\",\n    \"Analysis results are automatically saved after each analysis completes\",\n    \"Cache files are named using base64-encoded workspace paths\",\n    \"Stale cache entries (older than 24 hours) are automatically ignored\",\n    \"Cache read/write errors are logged to console but don't block operations\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes cache with storage location and creates cache directory\",\n      \"inputs\": \"storagePath: string\",\n      \"outputs\": \"AnalysisCache instance\"\n    },\n    {\n      \"name\": \"getCacheKey\",\n      \"desc\": \"Generates safe filename from workspace path for cache storage\",\n      \"inputs\": \"workspaceRoot: string\",\n      \"outputs\": \"base64-encoded string suitable for filename\"\n    },\n    {\n      \"name\": \"get\",\n      \"desc\": \"Retrieves cached analysis for workspace if exists and not expired\",\n      \"inputs\": \"workspaceRoot: string\",\n      \"outputs\": \"Promise<CodeAnalysis | null> - cached data or null if missing/expired\"\n    },\n    {\n      \"name\": \"set\",\n      \"desc\": \"Saves analysis results to cache with current timestamp\",\n      \"inputs\": \"workspaceRoot: string, data: CodeAnalysis\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all cached analysis files from cache directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer (CodeAnalysis type)\"\n  ],\n  \"intent\": \"Improves extension performance by caching expensive code analysis results, avoiding redundant analysis when reopening workspaces while ensuring cached data doesn't become stale through time-based expiration\"\n}\n```"
    },
    {
      "file": "src/config/configurationManager.ts",
      "role": "Core Logic",
      "purpose": "Manages all Shadow Watch extension settings and notifies components when configuration changes",
      "userVisibleActions": [
        "User changes Shadow Watch settings in VS Code preferences",
        "Extension behavior updates automatically when settings change (e.g., enable/disable analysis, adjust thresholds)",
        "User configures LLM providers (OpenAI, Claude) and API keys",
        "User sets severity thresholds for security issues (error, warning, info)",
        "User enables/disables automatic analysis on file save",
        "User toggles inline hints display in code editor",
        "User configures output formats for LLM analysis results (Cursor, ChatGPT, generic, compact)"
      ],
      "developerVisibleActions": [
        "Provides centralized type-safe access to all extension configuration values",
        "Automatically watches for configuration changes and notifies registered listeners",
        "Validates configuration settings and returns validation errors",
        "Exposes configuration properties through getter methods (enabled, analyzeOnSave, showInlineHints, etc.)",
        "Allows components to register callbacks that trigger when settings change",
        "Provides access to LLM provider settings, API keys, and model configurations",
        "Exposes severity thresholds, file pattern exclusions, and analysis limits"
      ],
      "keyFunctions": [
        {
          "name": "constructor",
          "desc": "Initializes configuration manager and sets up automatic change detection",
          "inputs": "none",
          "outputs": "ConfigurationManager instance"
        },
        {
          "name": "onConfigurationChange",
          "desc": "Registers a callback function that runs when configuration changes",
          "inputs": "callback function",
          "outputs": "void"
        },
        {
          "name": "removeConfigurationChangeListener",
          "desc": "Unregisters a configuration change callback",
          "inputs": "callback function",
          "outputs": "void"
        },
        {
          "name": "enabled (getter)",
          "desc": "Returns whether Shadow Watch extension is enabled",
          "inputs": "none",
          "outputs": "boolean"
        },
        {
          "name": "analyzeOnSave (getter)",
          "desc": "Returns whether automatic analysis on file save is enabled",
          "inputs": "none",
          "outputs": "boolean"
        },
        {
          "name": "showInlineHints (getter)",
          "desc": "Returns whether inline security hints should be displayed in editor",
          "inputs": "none",
          "outputs": "boolean"
        }
      ],
      "dependencies": [
        "vscode"
      ],
      "intent": "This file exists to provide a single source of truth for all Shadow Watch configuration settings. It solves the problem of scattered configuration access throughout the codebase by centralizing configuration management, providing type safety, and enabling reactive updates when users change settings. It ensures all components use consistent configuration values and stay synchronized when settings change.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages all Shadow Watch extension settings and notifies components when configuration changes\",\n  \"userVisibleActions\": [\n    \"User changes Shadow Watch settings in VS Code preferences\",\n    \"Extension behavior updates automatically when settings change (e.g., enable/disable analysis, adjust thresholds)\",\n    \"User configures LLM providers (OpenAI, Claude) and API keys\",\n    \"User sets severity thresholds for security issues (error, warning, info)\",\n    \"User enables/disables automatic analysis on file save\",\n    \"User toggles inline hints display in code editor\",\n    \"User configures output formats for LLM analysis results (Cursor, ChatGPT, generic, compact)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provides centralized type-safe access to all extension configuration values\",\n    \"Automatically watches for configuration changes and notifies registered listeners\",\n    \"Validates configuration settings and returns validation errors\",\n    \"Exposes configuration properties through getter methods (enabled, analyzeOnSave, showInlineHints, etc.)\",\n    \"Allows components to register callbacks that trigger when settings change\",\n    \"Provides access to LLM provider settings, API keys, and model configurations\",\n    \"Exposes severity thresholds, file pattern exclusions, and analysis limits\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes configuration manager and sets up automatic change detection\",\n      \"inputs\": \"none\",\n      \"outputs\": \"ConfigurationManager instance\"\n    },\n    {\n      \"name\": \"onConfigurationChange\",\n      \"desc\": \"Registers a callback function that runs when configuration changes\",\n      \"inputs\": \"callback function\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"removeConfigurationChangeListener\",\n      \"desc\": \"Unregisters a configuration change callback\",\n      \"inputs\": \"callback function\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"enabled (getter)\",\n      \"desc\": \"Returns whether Shadow Watch extension is enabled\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    },\n    {\n      \"name\": \"analyzeOnSave (getter)\",\n      \"desc\": \"Returns whether automatic analysis on file save is enabled\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    },\n    {\n      \"name\": \"showInlineHints (getter)\",\n      \"desc\": \"Returns whether inline security hints should be displayed in editor\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to provide a single source of truth for all Shadow Watch configuration settings. It solves the problem of scattered configuration access throughout the codebase by centralizing configuration management, providing type safety, and enabling reactive updates when users change settings. It ensures all components use consistent configuration values and stay synchronized when settings change.\"\n}\n```"
    },
    {
      "file": "src/context/analysisContextBuilder.ts",
      "role": "Core Logic",
      "purpose": "Converts code analysis results into a format suitable for LLM consumption and persists analysis data to disk for future reference",
      "userVisibleActions": [
        "Analysis results are automatically saved to the workspace for future use",
        "Code analysis data is stored in a .shadow/docs directory within the project"
      ],
      "developerVisibleActions": [
        "Converts CodeAnalysis objects into AnalysisContext format that can be sent to LLM services",
        "Saves analysis results with metadata (generation timestamp, workspace path) to code-analysis.json",
        "Creates .shadow/docs directory structure if it doesn't exist",
        "Handles workspace detection and validation before saving files"
      ],
      "keyFunctions": [
        {
          "name": "convertCodeAnalysisToContext",
          "desc": "Transforms CodeAnalysis data structure into AnalysisContext format for LLM processing",
          "inputs": "CodeAnalysis object containing files, imports, entry points, and metrics",
          "outputs": "AnalysisContext object with restructured file information, imports, entry points, and statistics"
        },
        {
          "name": "saveCodeAnalysis",
          "desc": "Persists code analysis results to the workspace filesystem for later retrieval",
          "inputs": "CodeAnalysis object to be saved",
          "outputs": "void - creates/updates code-analysis.json file in .shadow/docs directory"
        }
      ],
      "dependencies": [
        "vscode",
        "fs",
        "path",
        "../analyzer",
        "../llmService"
      ],
      "intent": "This file exists to bridge the gap between code analysis results and LLM consumption by reformatting the data, and to provide persistence so that expensive analysis operations don't need to be repeated. It solves the problem of maintaining analysis state across sessions and preparing data in the exact format required by the LLM service.",
      "rawContent": "```json\n{\n  \"purpose\": \"Converts code analysis results into a format suitable for LLM consumption and persists analysis data to disk for future reference\",\n  \"userVisibleActions\": [\n    \"Analysis results are automatically saved to the workspace for future use\",\n    \"Code analysis data is stored in a .shadow/docs directory within the project\"\n  ],\n  \"developerVisibleActions\": [\n    \"Converts CodeAnalysis objects into AnalysisContext format that can be sent to LLM services\",\n    \"Saves analysis results with metadata (generation timestamp, workspace path) to code-analysis.json\",\n    \"Creates .shadow/docs directory structure if it doesn't exist\",\n    \"Handles workspace detection and validation before saving files\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"convertCodeAnalysisToContext\",\n      \"desc\": \"Transforms CodeAnalysis data structure into AnalysisContext format for LLM processing\",\n      \"inputs\": \"CodeAnalysis object containing files, imports, entry points, and metrics\",\n      \"outputs\": \"AnalysisContext object with restructured file information, imports, entry points, and statistics\"\n    },\n    {\n      \"name\": \"saveCodeAnalysis\",\n      \"desc\": \"Persists code analysis results to the workspace filesystem for later retrieval\",\n      \"inputs\": \"CodeAnalysis object to be saved\",\n      \"outputs\": \"void - creates/updates code-analysis.json file in .shadow/docs directory\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"../analyzer\",\n    \"../llmService\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between code analysis results and LLM consumption by reformatting the data, and to provide persistence so that expensive analysis operations don't need to be repeated. It solves the problem of maintaining analysis state across sessions and preparing data in the exact format required by the LLM service.\"\n}\n```"
    },
    {
      "file": "src/diagnosticsProvider.ts",
      "role": "Core Logic",
      "purpose": "Manages and displays code diagnostics (warnings, errors, info messages) in the VS Code Problems panel based on insights generated from code analysis",
      "userVisibleActions": [
        "Shows diagnostic messages (warnings, errors, info) in the Problems panel for issues found in code files",
        "Displays colored underlines or squiggles in code editor at specific line numbers where issues are detected",
        "Groups diagnostic messages by file in the Problems panel",
        "Shows 'Shadow Watch' as the source of diagnostic messages",
        "Clears all diagnostic messages when requested",
        "Updates diagnostics in real-time as insights are generated"
      ],
      "developerVisibleActions": [
        "Creates a diagnostic collection named 'shadowWatch' that appears in the Problems panel",
        "Converts Insight objects into VS Code Diagnostic objects that integrate with the editor",
        "Updates diagnostics for all files or for a specific file based on insight data",
        "Maps insight severity levels to VS Code diagnostic severity (Error, Warning, Information, Hint)",
        "Positions diagnostics at specific line numbers extracted from insights",
        "Clears diagnostics when analysis is reset or updated",
        "Provides cleanup through dispose method for proper resource management"
      ],
      "keyFunctions": [
        {
          "name": "updateDiagnostics",
          "desc": "Updates diagnostics for all files based on an array of insights",
          "inputs": "insights: Insight[] - Array of insight objects containing file paths, line numbers, descriptions, and severity",
          "outputs": "void - Displays diagnostics in Problems panel"
        },
        {
          "name": "updateDiagnosticsForFile",
          "desc": "Updates diagnostics for a specific file only",
          "inputs": "uri: vscode.Uri - File URI, insights: Insight[] - Insights for that file",
          "outputs": "void - Displays diagnostics for the specified file"
        },
        {
          "name": "clear",
          "desc": "Removes all diagnostics from the Problems panel",
          "inputs": "None",
          "outputs": "void"
        },
        {
          "name": "createDiagnostic",
          "desc": "Converts an Insight object into a VS Code Diagnostic object",
          "inputs": "insight: Insight - Contains description, severity, line number, file path, and ID",
          "outputs": "vscode.Diagnostic - VS Code diagnostic that appears in Problems panel and editor"
        },
        {
          "name": "getSeverity",
          "desc": "Maps insight severity string to VS Code DiagnosticSeverity enum",
          "inputs": "severity: string - Severity level from insight",
          "outputs": "vscode.DiagnosticSeverity - VS Code severity enum value"
        },
        {
          "name": "dispose",
          "desc": "Cleans up and disposes the diagnostic collection",
          "inputs": "None",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "./insightGenerator"
      ],
      "intent": "This file exists to bridge the gap between code analysis insights and VS Code's built-in diagnostics system, allowing code issues to be displayed natively in the Problems panel and editor with proper formatting, severity levels, and file grouping - giving users a familiar interface for viewing and navigating code issues discovered by Shadow Watch",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages and displays code diagnostics (warnings, errors, info messages) in the VS Code Problems panel based on insights generated from code analysis\",\n  \"userVisibleActions\": [\n    \"Shows diagnostic messages (warnings, errors, info) in the Problems panel for issues found in code files\",\n    \"Displays colored underlines or squiggles in code editor at specific line numbers where issues are detected\",\n    \"Groups diagnostic messages by file in the Problems panel\",\n    \"Shows 'Shadow Watch' as the source of diagnostic messages\",\n    \"Clears all diagnostic messages when requested\",\n    \"Updates diagnostics in real-time as insights are generated\"\n  ],\n  \"developerVisibleActions\": [\n    \"Creates a diagnostic collection named 'shadowWatch' that appears in the Problems panel\",\n    \"Converts Insight objects into VS Code Diagnostic objects that integrate with the editor\",\n    \"Updates diagnostics for all files or for a specific file based on insight data\",\n    \"Maps insight severity levels to VS Code diagnostic severity (Error, Warning, Information, Hint)\",\n    \"Positions diagnostics at specific line numbers extracted from insights\",\n    \"Clears diagnostics when analysis is reset or updated\",\n    \"Provides cleanup through dispose method for proper resource management\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"updateDiagnostics\",\n      \"desc\": \"Updates diagnostics for all files based on an array of insights\",\n      \"inputs\": \"insights: Insight[] - Array of insight objects containing file paths, line numbers, descriptions, and severity\",\n      \"outputs\": \"void - Displays diagnostics in Problems panel\"\n    },\n    {\n      \"name\": \"updateDiagnosticsForFile\",\n      \"desc\": \"Updates diagnostics for a specific file only\",\n      \"inputs\": \"uri: vscode.Uri - File URI, insights: Insight[] - Insights for that file\",\n      \"outputs\": \"void - Displays diagnostics for the specified file\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all diagnostics from the Problems panel\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"createDiagnostic\",\n      \"desc\": \"Converts an Insight object into a VS Code Diagnostic object\",\n      \"inputs\": \"insight: Insight - Contains description, severity, line number, file path, and ID\",\n      \"outputs\": \"vscode.Diagnostic - VS Code diagnostic that appears in Problems panel and editor\"\n    },\n    {\n      \"name\": \"getSeverity\",\n      \"desc\": \"Maps insight severity string to VS Code DiagnosticSeverity enum\",\n      \"inputs\": \"severity: string - Severity level from insight\",\n      \"outputs\": \"vscode.DiagnosticSeverity - VS Code severity enum value\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up and disposes the diagnostic collection\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between code analysis insights and VS Code's built-in diagnostics system, allowing code issues to be displayed natively in the Problems panel and editor with proper formatting, severity levels, and file grouping - giving users a familiar interface for viewing and navigating code issues discovered by Shadow Watch\"\n}\n```"
    },
    {
      "file": "src/domain/bootstrap/commandRegistry.ts",
      "role": "Core Logic",
      "purpose": "Registers all VS Code commands for the extension, mapping command IDs to their handler functions",
      "userVisibleActions": [
        "Analyze entire workspace for code insights",
        "Analyze currently open file",
        "Copy all insights to clipboard",
        "Copy insights for a specific file",
        "Copy a single insight",
        "Clear cached analysis data",
        "Clear all extension data",
        "Open extension settings",
        "View latest analysis report",
        "View latest unit test report",
        "Switch between LLM providers",
        "Copy menu structure",
        "View current LLM provider status",
        "Navigate to a product feature or component",
        "Navigate to a specific analysis result",
        "View detailed information about a product item",
        "View detailed information about an insight",
        "View detailed information about a unit test"
      ],
      "developerVisibleActions": [
        "Centralizes command registration logic for maintainability",
        "Provides type-safe command handler interface",
        "Integrates with VS Code command palette and UI elements",
        "Coordinates between analyzer, insight generator, and UI components",
        "Manages analysis caching and data persistence",
        "Handles configuration and provider switching",
        "Routes navigation actions to appropriate viewers",
        "Enables clipboard operations for analysis results"
      ],
      "keyFunctions": [
        {
          "name": "register",
          "desc": "Registers all extension commands with VS Code's command system",
          "inputs": "context: ExtensionContext, components: ExtensionComponents",
          "outputs": "void - side effect of registering commands"
        },
        {
          "name": "analyzeWorkspace",
          "desc": "Triggers analysis of all files in the workspace",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "analyzeCurrentFile",
          "desc": "Triggers analysis of the currently active file",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "copyAllInsights",
          "desc": "Copies all generated insights to the clipboard",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "copyFileInsights",
          "desc": "Copies insights for a specific file to the clipboard",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "copyInsight",
          "desc": "Copies a single insight item to the clipboard",
          "inputs": "item: any",
          "outputs": "Promise<void>"
        },
        {
          "name": "clearCache",
          "desc": "Clears the analysis cache",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "clearAllData",
          "desc": "Clears all extension data including cache and settings",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "switchProvider",
          "desc": "Switches between different LLM provider configurations",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "navigateToProductItem",
          "desc": "Opens the file/location associated with a product feature",
          "inputs": "item: ProductNavItem",
          "outputs": "Promise<void>"
        },
        {
          "name": "navigateToAnalysisItem",
          "desc": "Opens the file/location associated with an analysis result",
          "inputs": "item: AnalysisItem",
          "outputs": "Promise<void>"
        },
        {
          "name": "showProviderStatus",
          "desc": "Displays information about the current LLM provider configuration",
          "inputs": "none",
          "outputs": "Promise<void>"
        }
      ],
      "dependencies": [
        "vscode",
        "llmIntegration",
        "CodeAnalyzer",
        "InsightGenerator",
        "LLMFormatter",
        "InsightsTreeProvider",
        "DiagnosticsProvider",
        "AnalysisCache",
        "AnalysisViewerProvider",
        "ProductNavItem",
        "configurationManager",
        "ExtensionComponents"
      ],
      "intent": "Separates command registration logic from the main extension file to improve maintainability and organization. Provides a centralized place where all user-invocable commands are mapped to their implementation, making it easy to understand what actions users can perform and ensuring consistent command handling across the extension.",
      "rawContent": "```json\n{\n  \"purpose\": \"Registers all VS Code commands for the extension, mapping command IDs to their handler functions\",\n  \"userVisibleActions\": [\n    \"Analyze entire workspace for code insights\",\n    \"Analyze currently open file\",\n    \"Copy all insights to clipboard\",\n    \"Copy insights for a specific file\",\n    \"Copy a single insight\",\n    \"Clear cached analysis data\",\n    \"Clear all extension data\",\n    \"Open extension settings\",\n    \"View latest analysis report\",\n    \"View latest unit test report\",\n    \"Switch between LLM providers\",\n    \"Copy menu structure\",\n    \"View current LLM provider status\",\n    \"Navigate to a product feature or component\",\n    \"Navigate to a specific analysis result\",\n    \"View detailed information about a product item\",\n    \"View detailed information about an insight\",\n    \"View detailed information about a unit test\"\n  ],\n  \"developerVisibleActions\": [\n    \"Centralizes command registration logic for maintainability\",\n    \"Provides type-safe command handler interface\",\n    \"Integrates with VS Code command palette and UI elements\",\n    \"Coordinates between analyzer, insight generator, and UI components\",\n    \"Manages analysis caching and data persistence\",\n    \"Handles configuration and provider switching\",\n    \"Routes navigation actions to appropriate viewers\",\n    \"Enables clipboard operations for analysis results\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"register\",\n      \"desc\": \"Registers all extension commands with VS Code's command system\",\n      \"inputs\": \"context: ExtensionContext, components: ExtensionComponents\",\n      \"outputs\": \"void - side effect of registering commands\"\n    },\n    {\n      \"name\": \"analyzeWorkspace\",\n      \"desc\": \"Triggers analysis of all files in the workspace\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"analyzeCurrentFile\",\n      \"desc\": \"Triggers analysis of the currently active file\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"copyAllInsights\",\n      \"desc\": \"Copies all generated insights to the clipboard\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"copyFileInsights\",\n      \"desc\": \"Copies insights for a specific file to the clipboard\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"copyInsight\",\n      \"desc\": \"Copies a single insight item to the clipboard\",\n      \"inputs\": \"item: any\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clearCache\",\n      \"desc\": \"Clears the analysis cache\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clearAllData\",\n      \"desc\": \"Clears all extension data including cache and settings\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"switchProvider\",\n      \"desc\": \"Switches between different LLM provider configurations\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"navigateToProductItem\",\n      \"desc\": \"Opens the file/location associated with a product feature\",\n      \"inputs\": \"item: ProductNavItem\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"navigateToAnalysisItem\",\n      \"desc\": \"Opens the file/location associated with an analysis result\",\n      \"inputs\": \"item: AnalysisItem\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"showProviderStatus\",\n      \"desc\": \"Displays information about the current LLM provider configuration\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"llmIntegration\",\n    \"CodeAnalyzer\",\n    \"InsightGenerator\",\n    \"LLMFormatter\",\n    \"InsightsTreeProvider\",\n    \"DiagnosticsProvider\",\n    \"AnalysisCache\",\n    \"AnalysisViewerProvider\",\n    \"ProductNavItem\",\n    \"configurationManager\",\n    \"ExtensionComponents\"\n  ],\n  \"intent\": \"Separates command registration logic from the main extension file to improve maintainability and organization. Provides a centralized place where all user-invocable commands are mapped to their implementation, making it easy to understand what actions users can perform and ensuring consistent command handling across the extension.\"\n}\n```"
    },
    {
      "file": "src/domain/bootstrap/extensionBootstrapper.ts",
      "role": "Core Logic",
      "purpose": "Initializes and configures all extension components when the VS Code extension activates, connecting UI elements, services, and event handlers",
      "userVisibleActions": [
        "Status bar displays extension status and information",
        "Product Navigator view shows navigable product structure",
        "Analysis Viewer displays code analysis results",
        "Insights Viewer shows generated code insights",
        "Static Analysis Viewer presents static analysis findings",
        "Unit Tests Navigator displays test structure and results",
        "Reports Viewer shows generated analysis reports",
        "Diagnostics appear in Problems panel for code issues",
        "File changes trigger automatic re-analysis"
      ],
      "developerVisibleActions": [
        "Extension activates and initializes all components on workspace open",
        "Components are registered and connected to VS Code UI elements",
        "Tree views are created for navigation and visualization",
        "File watchers monitor code changes for automatic updates",
        "Cache system stores analysis results for performance",
        "Configuration manager provides settings access",
        "State manager tracks LLM integration state",
        "Error handler captures and reports failures",
        "Commands are registered for user interactions",
        "Event handlers connect UI actions to business logic"
      ],
      "keyFunctions": [
        {
          "name": "ExtensionComponents interface",
          "desc": "Defines the structure of all initialized extension components including analyzers, viewers, providers, and services",
          "inputs": "N/A - interface definition",
          "outputs": "Type definition for component container"
        }
      ],
      "dependencies": [
        "vscode",
        "../../analyzer",
        "../../insightGenerator",
        "../../llmFormatter",
        "../../fileWatcher",
        "../../insightsTreeView",
        "../../diagnosticsProvider",
        "../../cache",
        "../../llmIntegration",
        "../../productNavigator",
        "../../analysisViewer",
        "../../insightsViewer",
        "../../staticAnalysisViewer",
        "../../unitTestsNavigator",
        "../../config/configurationManager",
        "../../utils/errorHandler",
        "../../domain/services/fileWatcherService",
        "../../ui/reportsViewer",
        "../../reportsTreeProvider",
        "../../state/llmStateManager"
      ],
      "intent": "Separates extension activation and initialization logic from main extension entry point, providing centralized component bootstrapping, dependency injection, and lifecycle management for all extension features and UI elements",
      "rawContent": "```json\n{\n  \"purpose\": \"Initializes and configures all extension components when the VS Code extension activates, connecting UI elements, services, and event handlers\",\n  \"userVisibleActions\": [\n    \"Status bar displays extension status and information\",\n    \"Product Navigator view shows navigable product structure\",\n    \"Analysis Viewer displays code analysis results\",\n    \"Insights Viewer shows generated code insights\",\n    \"Static Analysis Viewer presents static analysis findings\",\n    \"Unit Tests Navigator displays test structure and results\",\n    \"Reports Viewer shows generated analysis reports\",\n    \"Diagnostics appear in Problems panel for code issues\",\n    \"File changes trigger automatic re-analysis\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extension activates and initializes all components on workspace open\",\n    \"Components are registered and connected to VS Code UI elements\",\n    \"Tree views are created for navigation and visualization\",\n    \"File watchers monitor code changes for automatic updates\",\n    \"Cache system stores analysis results for performance\",\n    \"Configuration manager provides settings access\",\n    \"State manager tracks LLM integration state\",\n    \"Error handler captures and reports failures\",\n    \"Commands are registered for user interactions\",\n    \"Event handlers connect UI actions to business logic\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"ExtensionComponents interface\",\n      \"desc\": \"Defines the structure of all initialized extension components including analyzers, viewers, providers, and services\",\n      \"inputs\": \"N/A - interface definition\",\n      \"outputs\": \"Type definition for component container\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"../../analyzer\",\n    \"../../insightGenerator\",\n    \"../../llmFormatter\",\n    \"../../fileWatcher\",\n    \"../../insightsTreeView\",\n    \"../../diagnosticsProvider\",\n    \"../../cache\",\n    \"../../llmIntegration\",\n    \"../../productNavigator\",\n    \"../../analysisViewer\",\n    \"../../insightsViewer\",\n    \"../../staticAnalysisViewer\",\n    \"../../unitTestsNavigator\",\n    \"../../config/configurationManager\",\n    \"../../utils/errorHandler\",\n    \"../../domain/services/fileWatcherService\",\n    \"../../ui/reportsViewer\",\n    \"../../reportsTreeProvider\",\n    \"../../state/llmStateManager\"\n  ],\n  \"intent\": \"Separates extension activation and initialization logic from main extension entry point, providing centralized component bootstrapping, dependency injection, and lifecycle management for all extension features and UI elements\"\n}\n```"
    },
    {
      "file": "src/domain/formatters/documentationFormatter.ts",
      "role": "Core Logic",
      "purpose": "Formats product documentation and code analysis insights into structured Markdown documents for user consumption and export.",
      "userVisibleActions": [
        "View product documentation formatted as Markdown with overview, features, and user perspectives",
        "See file analysis results organized by component categories (UI, Business Logic, Data, Infrastructure)",
        "Read LLM insights formatted with behavioral summaries, feature lists, and usage examples",
        "Export documentation with timestamps showing generation date and time",
        "Access documentation sections for GUI, CLI, and API perspectives",
        "View file classifications and their purposes in structured sections",
        "See warning messages for empty or missing documentation sections"
      ],
      "developerVisibleActions": [
        "Call formatEnhancedDocsAsMarkdown() to convert product documentation objects into Markdown format",
        "Call formatFileAnalysisAsMarkdown() to convert file analysis results into categorized Markdown sections",
        "Call formatInsightsAsMarkdown() to convert LLM insights into comprehensive Markdown documentation",
        "Receive formatted Markdown strings ready for file writing or display",
        "Get automatic timestamp injection in UTC and local time formats",
        "Handle empty sections gracefully with warning messages",
        "Process nested data structures (arrays, objects) into bulleted lists and sections"
      ],
      "keyFunctions": [
        {
          "name": "formatEnhancedDocsAsMarkdown",
          "desc": "Converts enhanced product documentation object into formatted Markdown with sections for overview, features, user perspectives, tech stack, architecture, and file structures",
          "inputs": "EnhancedProductDocumentation object containing overview, features, user perspectives, tech stack, architecture, and file analysis",
          "outputs": "Formatted Markdown string with hierarchical sections and timestamps"
        },
        {
          "name": "formatFileAnalysisAsMarkdown",
          "desc": "Formats file analysis results into categorized Markdown sections (UI Components, Business Logic, Data Layer, Infrastructure) with file paths and purposes",
          "inputs": "File analysis results with categorized files (uiComponents, businessLogic, dataLayer, infrastructure)",
          "outputs": "Markdown string with categorized file listings or warning message if empty"
        },
        {
          "name": "formatInsightsAsMarkdown",
          "desc": "Converts LLM analysis insights into comprehensive Markdown documentation including behavioral summary, key features, user interactions, technical details, and usage examples",
          "inputs": "LLMInsights object containing behavioral summary, features, interactions, technical details, and examples",
          "outputs": "Formatted Markdown string with all insight sections organized hierarchically"
        }
      ],
      "dependencies": [
        "../../fileDocumentation (EnhancedProductDocumentation type)",
        "../../llmService (LLMInsights type)"
      ],
      "intent": "Separates documentation formatting logic from core analysis code, providing a dedicated service to transform structured data objects into human-readable Markdown documents that can be exported, displayed, or version-controlled.",
      "rawContent": "```json\n{\n  \"purpose\": \"Formats product documentation and code analysis insights into structured Markdown documents for user consumption and export.\",\n  \"userVisibleActions\": [\n    \"View product documentation formatted as Markdown with overview, features, and user perspectives\",\n    \"See file analysis results organized by component categories (UI, Business Logic, Data, Infrastructure)\",\n    \"Read LLM insights formatted with behavioral summaries, feature lists, and usage examples\",\n    \"Export documentation with timestamps showing generation date and time\",\n    \"Access documentation sections for GUI, CLI, and API perspectives\",\n    \"View file classifications and their purposes in structured sections\",\n    \"See warning messages for empty or missing documentation sections\"\n  ],\n  \"developerVisibleActions\": [\n    \"Call formatEnhancedDocsAsMarkdown() to convert product documentation objects into Markdown format\",\n    \"Call formatFileAnalysisAsMarkdown() to convert file analysis results into categorized Markdown sections\",\n    \"Call formatInsightsAsMarkdown() to convert LLM insights into comprehensive Markdown documentation\",\n    \"Receive formatted Markdown strings ready for file writing or display\",\n    \"Get automatic timestamp injection in UTC and local time formats\",\n    \"Handle empty sections gracefully with warning messages\",\n    \"Process nested data structures (arrays, objects) into bulleted lists and sections\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"formatEnhancedDocsAsMarkdown\",\n      \"desc\": \"Converts enhanced product documentation object into formatted Markdown with sections for overview, features, user perspectives, tech stack, architecture, and file structures\",\n      \"inputs\": \"EnhancedProductDocumentation object containing overview, features, user perspectives, tech stack, architecture, and file analysis\",\n      \"outputs\": \"Formatted Markdown string with hierarchical sections and timestamps\"\n    },\n    {\n      \"name\": \"formatFileAnalysisAsMarkdown\",\n      \"desc\": \"Formats file analysis results into categorized Markdown sections (UI Components, Business Logic, Data Layer, Infrastructure) with file paths and purposes\",\n      \"inputs\": \"File analysis results with categorized files (uiComponents, businessLogic, dataLayer, infrastructure)\",\n      \"outputs\": \"Markdown string with categorized file listings or warning message if empty\"\n    },\n    {\n      \"name\": \"formatInsightsAsMarkdown\",\n      \"desc\": \"Converts LLM analysis insights into comprehensive Markdown documentation including behavioral summary, key features, user interactions, technical details, and usage examples\",\n      \"inputs\": \"LLMInsights object containing behavioral summary, features, interactions, technical details, and examples\",\n      \"outputs\": \"Formatted Markdown string with all insight sections organized hierarchically\"\n    }\n  ],\n  \"dependencies\": [\n    \"../../fileDocumentation (EnhancedProductDocumentation type)\",\n    \"../../llmService (LLMInsights type)\"\n  ],\n  \"intent\": \"Separates documentation formatting logic from core analysis code, providing a dedicated service to transform structured data objects into human-readable Markdown documents that can be exported, displayed, or version-controlled.\"\n}\n```"
    },
    {
      "file": "src/domain/handlers/navigationHandler.ts",
      "role": "Core Logic",
      "purpose": "Handles navigation to files, functions, and endpoints within the workspace when users interact with the product navigator and analysis viewer.",
      "userVisibleActions": [
        "Opens source code files in the editor when clicking on file items",
        "Navigates to specific functions in files and highlights the function definition",
        "Shows error messages when files cannot be opened",
        "Displays function details in a quick pick menu with signature, description, and metadata",
        "Navigates to endpoint handlers when clicking on API endpoints",
        "Navigates to function usage locations when clicking on references",
        "Opens analysis items showing code context with syntax highlighting",
        "Shows warnings when navigation targets cannot be found"
      ],
      "developerVisibleActions": [
        "Converts relative file paths to absolute paths using workspace root",
        "Opens VS Code text documents programmatically",
        "Positions cursor at specific line numbers for functions and code locations",
        "Searches through document content to find function definitions by name",
        "Creates selection ranges to highlight code sections",
        "Displays formatted information panels using VS Code quick pick interface",
        "Handles multiple navigation types: files, functions, endpoints, and analysis items",
        "Falls back to line numbers when function names cannot be located in files"
      ],
      "keyFunctions": [
        {
          "name": "navigateToProductItem",
          "desc": "Opens files or navigates to functions/endpoints from product navigator items",
          "inputs": "ProductNavItem containing file path, function name, and line number",
          "outputs": "Promise<void> - opens editor at target location"
        },
        {
          "name": "navigateToAnalysisItem",
          "desc": "Opens files and shows code context for analysis viewer items",
          "inputs": "AnalysisItem with file path and line number information",
          "outputs": "Promise<void> - displays code in editor with selection"
        },
        {
          "name": "showItemDetails",
          "desc": "Displays detailed information about functions, endpoints, or entry points in a menu",
          "inputs": "ProductNavItem or EntryPoint with metadata like signature, description, parameters",
          "outputs": "Promise<void> - shows quick pick panel with formatted details"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "ProductNavItem from productNavigator",
        "AnalysisItem from analysisViewer",
        "EntryPoint from analyzer"
      ],
      "intent": "This file exists to centralize all code navigation logic for the extension, separating navigation concerns from the main extension file. It solves the problem of providing consistent, user-friendly navigation across different types of code items (files, functions, endpoints, analysis results) while handling edge cases like missing files, relative paths, and function location resolution.",
      "rawContent": "```json\n{\n  \"purpose\": \"Handles navigation to files, functions, and endpoints within the workspace when users interact with the product navigator and analysis viewer.\",\n  \"userVisibleActions\": [\n    \"Opens source code files in the editor when clicking on file items\",\n    \"Navigates to specific functions in files and highlights the function definition\",\n    \"Shows error messages when files cannot be opened\",\n    \"Displays function details in a quick pick menu with signature, description, and metadata\",\n    \"Navigates to endpoint handlers when clicking on API endpoints\",\n    \"Navigates to function usage locations when clicking on references\",\n    \"Opens analysis items showing code context with syntax highlighting\",\n    \"Shows warnings when navigation targets cannot be found\"\n  ],\n  \"developerVisibleActions\": [\n    \"Converts relative file paths to absolute paths using workspace root\",\n    \"Opens VS Code text documents programmatically\",\n    \"Positions cursor at specific line numbers for functions and code locations\",\n    \"Searches through document content to find function definitions by name\",\n    \"Creates selection ranges to highlight code sections\",\n    \"Displays formatted information panels using VS Code quick pick interface\",\n    \"Handles multiple navigation types: files, functions, endpoints, and analysis items\",\n    \"Falls back to line numbers when function names cannot be located in files\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"navigateToProductItem\",\n      \"desc\": \"Opens files or navigates to functions/endpoints from product navigator items\",\n      \"inputs\": \"ProductNavItem containing file path, function name, and line number\",\n      \"outputs\": \"Promise<void> - opens editor at target location\"\n    },\n    {\n      \"name\": \"navigateToAnalysisItem\",\n      \"desc\": \"Opens files and shows code context for analysis viewer items\",\n      \"inputs\": \"AnalysisItem with file path and line number information\",\n      \"outputs\": \"Promise<void> - displays code in editor with selection\"\n    },\n    {\n      \"name\": \"showItemDetails\",\n      \"desc\": \"Displays detailed information about functions, endpoints, or entry points in a menu\",\n      \"inputs\": \"ProductNavItem or EntryPoint with metadata like signature, description, parameters\",\n      \"outputs\": \"Promise<void> - shows quick pick panel with formatted details\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"ProductNavItem from productNavigator\",\n    \"AnalysisItem from analysisViewer\",\n    \"EntryPoint from analyzer\"\n  ],\n  \"intent\": \"This file exists to centralize all code navigation logic for the extension, separating navigation concerns from the main extension file. It solves the problem of providing consistent, user-friendly navigation across different types of code items (files, functions, endpoints, analysis results) while handling edge cases like missing files, relative paths, and function location resolution.\"\n}\n```"
    },
    {
      "file": "src/domain/prompts/promptBuilder.ts",
      "role": "Core Logic",
      "purpose": "Provides centralized prompt construction services for all LLM analysis tasks, eliminating duplication by building structured prompts for architecture analysis, documentation, test generation, and code understanding.",
      "userVisibleActions": [
        "Generates architecture analysis prompts that produce structured project architecture documentation",
        "Creates product documentation prompts that extract user-facing features and capabilities",
        "Builds test plan prompts that generate comprehensive test strategies for code files",
        "Produces code analysis prompts that explain file functionality and behavior",
        "Generates module summary prompts that consolidate related files into cohesive documentation"
      ],
      "developerVisibleActions": [
        "Developer calls buildArchitecturePrompt to get a prompt for analyzing project structure and patterns",
        "Developer calls buildProductDocsPrompt to generate prompts for extracting product documentation",
        "Developer calls buildProductPurposePrompt to create prompts for understanding product purpose and value",
        "Developer calls buildFileAnalysisPrompt to generate prompts for analyzing individual files",
        "Developer calls buildModuleRollupPrompt to create prompts for summarizing module-level functionality",
        "Developer calls buildProductLevelPrompt to generate comprehensive product-wide documentation prompts",
        "Developer calls buildPerFileTestPlanPrompt to create prompts for test planning per file",
        "Developer calls buildTestCodeGenerationPrompt to generate actual test code from test plans",
        "Receives AnalysisContext, CodeAnalysis, and FileInfo objects as input",
        "Returns formatted string prompts ready for LLM consumption",
        "Incorporates existing code analysis, file metadata, and project structure into prompts"
      ],
      "keyFunctions": [
        {
          "name": "buildArchitecturePrompt",
          "desc": "Constructs a prompt for LLM to analyze project architecture, patterns, and structure",
          "inputs": "context: AnalysisContext, optional codeAnalysis, productDocs, productPurposeAnalysis, fileAccessHelper",
          "outputs": "formatted prompt string for architecture analysis"
        },
        {
          "name": "buildProductDocsPrompt",
          "desc": "Creates a prompt for extracting user-facing product documentation and features",
          "inputs": "context: AnalysisContext",
          "outputs": "formatted prompt string for product documentation extraction"
        },
        {
          "name": "buildProductPurposePrompt",
          "desc": "Generates a prompt for understanding product purpose, value proposition, and target users",
          "inputs": "productDocs: EnhancedProductDocumentation, context: AnalysisContext",
          "outputs": "formatted prompt string for product purpose analysis"
        },
        {
          "name": "buildFileAnalysisPrompt",
          "desc": "Creates a prompt for analyzing individual file functionality and behavior",
          "inputs": "file: FileInfo, content: string, role: string",
          "outputs": "formatted prompt string for file analysis"
        },
        {
          "name": "buildModuleRollupPrompt",
          "desc": "Constructs a prompt for rolling up multiple file summaries into module-level documentation",
          "inputs": "modulePath: string, moduleType: string, files: FileSummary[]",
          "outputs": "formatted prompt string for module summary generation"
        },
        {
          "name": "buildProductLevelPrompt",
          "desc": "Generates a comprehensive prompt for product-wide documentation synthesis",
          "inputs": "fileSummaries: FileSummary[], moduleSummaries: ModuleSummary[], analysis: CodeAnalysis, fileAccessHelper: FileAccessHelper",
          "outputs": "formatted prompt string for product-level documentation"
        },
        {
          "name": "buildPerFileTestPlanPrompt",
          "desc": "Creates a prompt for generating test plans for specific files and functions",
          "inputs": "filePath, fileContent, functionMetadata, existingTests, language, testFramework, optional projectSummary",
          "outputs": "formatted prompt string for test plan generation"
        },
        {
          "name": "buildTestCodeGenerationPrompt",
          "desc": "Constructs a prompt for generating actual test code from test plan items",
          "inputs": "testPlanItem, sourceCode, functionCode, language, testFramework",
          "outputs": "formatted prompt string for test code generation"
        }
      ],
      "dependencies": [
        "../../llmService",
        "../../analyzer",
        "../../fileDocumentation",
        "../../fileAccessHelper"
      ],
      "intent": "This file exists to solve the problem of prompt construction duplication across the codebase. By centralizing all LLM prompt building logic in one place, it ensures consistency in how prompts are structured, eliminates code duplication, and makes it easier to maintain and improve prompt quality for various analysis tasks including architecture analysis, documentation extraction, and test generation.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides centralized prompt construction services for all LLM analysis tasks, eliminating duplication by building structured prompts for architecture analysis, documentation, test generation, and code understanding.\",\n  \"userVisibleActions\": [\n    \"Generates architecture analysis prompts that produce structured project architecture documentation\",\n    \"Creates product documentation prompts that extract user-facing features and capabilities\",\n    \"Builds test plan prompts that generate comprehensive test strategies for code files\",\n    \"Produces code analysis prompts that explain file functionality and behavior\",\n    \"Generates module summary prompts that consolidate related files into cohesive documentation\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer calls buildArchitecturePrompt to get a prompt for analyzing project structure and patterns\",\n    \"Developer calls buildProductDocsPrompt to generate prompts for extracting product documentation\",\n    \"Developer calls buildProductPurposePrompt to create prompts for understanding product purpose and value\",\n    \"Developer calls buildFileAnalysisPrompt to generate prompts for analyzing individual files\",\n    \"Developer calls buildModuleRollupPrompt to create prompts for summarizing module-level functionality\",\n    \"Developer calls buildProductLevelPrompt to generate comprehensive product-wide documentation prompts\",\n    \"Developer calls buildPerFileTestPlanPrompt to create prompts for test planning per file\",\n    \"Developer calls buildTestCodeGenerationPrompt to generate actual test code from test plans\",\n    \"Receives AnalysisContext, CodeAnalysis, and FileInfo objects as input\",\n    \"Returns formatted string prompts ready for LLM consumption\",\n    \"Incorporates existing code analysis, file metadata, and project structure into prompts\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"buildArchitecturePrompt\",\n      \"desc\": \"Constructs a prompt for LLM to analyze project architecture, patterns, and structure\",\n      \"inputs\": \"context: AnalysisContext, optional codeAnalysis, productDocs, productPurposeAnalysis, fileAccessHelper\",\n      \"outputs\": \"formatted prompt string for architecture analysis\"\n    },\n    {\n      \"name\": \"buildProductDocsPrompt\",\n      \"desc\": \"Creates a prompt for extracting user-facing product documentation and features\",\n      \"inputs\": \"context: AnalysisContext\",\n      \"outputs\": \"formatted prompt string for product documentation extraction\"\n    },\n    {\n      \"name\": \"buildProductPurposePrompt\",\n      \"desc\": \"Generates a prompt for understanding product purpose, value proposition, and target users\",\n      \"inputs\": \"productDocs: EnhancedProductDocumentation, context: AnalysisContext\",\n      \"outputs\": \"formatted prompt string for product purpose analysis\"\n    },\n    {\n      \"name\": \"buildFileAnalysisPrompt\",\n      \"desc\": \"Creates a prompt for analyzing individual file functionality and behavior\",\n      \"inputs\": \"file: FileInfo, content: string, role: string\",\n      \"outputs\": \"formatted prompt string for file analysis\"\n    },\n    {\n      \"name\": \"buildModuleRollupPrompt\",\n      \"desc\": \"Constructs a prompt for rolling up multiple file summaries into module-level documentation\",\n      \"inputs\": \"modulePath: string, moduleType: string, files: FileSummary[]\",\n      \"outputs\": \"formatted prompt string for module summary generation\"\n    },\n    {\n      \"name\": \"buildProductLevelPrompt\",\n      \"desc\": \"Generates a comprehensive prompt for product-wide documentation synthesis\",\n      \"inputs\": \"fileSummaries: FileSummary[], moduleSummaries: ModuleSummary[], analysis: CodeAnalysis, fileAccessHelper: FileAccessHelper\",\n      \"outputs\": \"formatted prompt string for product-level documentation\"\n    },\n    {\n      \"name\": \"buildPerFileTestPlanPrompt\",\n      \"desc\": \"Creates a prompt for generating test plans for specific files and functions\",\n      \"inputs\": \"filePath, fileContent, functionMetadata, existingTests, language, testFramework, optional projectSummary\",\n      \"outputs\": \"formatted prompt string for test plan generation\"\n    },\n    {\n      \"name\": \"buildTestCodeGenerationPrompt\",\n      \"desc\": \"Constructs a prompt for generating actual test code from test plan items\",\n      \"inputs\": \"testPlanItem, sourceCode, functionCode, language, testFramework\",\n      \"outputs\": \"formatted prompt string for test code generation\"\n    }\n  ],\n  \"dependencies\": [\n    \"../../llmService\",\n    \"../../analyzer\",\n    \"../../fileDocumentation\",\n    \"../../fileAccessHelper\"\n  ],\n  \"intent\": \"This file exists to solve the problem of prompt construction duplication across the codebase. By centralizing all LLM prompt building logic in one place, it ensures consistency in how prompts are structured, eliminates code duplication, and makes it easier to maintain and improve prompt quality for various analysis tasks including architecture analysis, documentation extraction, and test generation.\"\n}\n```"
    },
    {
      "file": "src/domain/prompts/refactoringPromptBuilder.ts",
      "role": "Core Logic",
      "purpose": "Generates detailed, prescriptive prompts for LLM-based code refactoring analysis with extraction plans and migration steps.",
      "userVisibleActions": [
        "Receives comprehensive refactoring reports that explain what code should be extracted and why",
        "Gets detailed step-by-step migration instructions for code reorganization",
        "Views before-and-after code examples showing proposed refactoring changes",
        "Sees function-level analysis including responsibilities, dependencies, and call relationships"
      ],
      "developerVisibleActions": [
        "Creates structured prompts that guide LLMs to generate refactoring recommendations",
        "Combines code analysis, product documentation, and architecture insights into refactoring instructions",
        "Builds extraction plans that specify which functions should move to which files",
        "Generates function analysis reports showing dependencies, dependents, and responsibilities",
        "Provides detailed requirements for code extraction with migration steps and examples"
      ],
      "keyFunctions": [
        {
          "name": "buildDetailedRefactoringPrompt",
          "desc": "Constructs a comprehensive prompt for generating refactoring reports with function analysis and extraction plans",
          "inputs": "AnalysisContext, CodeAnalysis, optional EnhancedProductDocumentation, optional LLMInsights, optional FunctionAnalysis array",
          "outputs": "Complete prompt string for LLM refactoring analysis"
        },
        {
          "name": "buildBasePrompt",
          "desc": "Creates the foundational prompt structure combining context, code analysis, and documentation",
          "inputs": "AnalysisContext, CodeAnalysis, optional ProductDocumentation, optional ArchitectureInsights",
          "outputs": "Base prompt string"
        },
        {
          "name": "buildFunctionAnalysisSection",
          "desc": "Generates detailed analysis section for individual functions showing their relationships and responsibilities",
          "inputs": "Array of FunctionAnalysis objects",
          "outputs": "Formatted function analysis text"
        },
        {
          "name": "buildExtractionRequirementsSection",
          "desc": "Creates instructions for how to structure code extraction recommendations",
          "inputs": "None (defines format requirements)",
          "outputs": "Extraction requirements text"
        }
      ],
      "dependencies": [
        "../../analyzer (CodeAnalysis, FileInfo, FunctionMetadata)",
        "../../llmService (AnalysisContext, LLMInsights)",
        "../../fileDocumentation (EnhancedProductDocumentation)"
      ],
      "intent": "This file exists to standardize and enhance how refactoring instructions are communicated to LLMs, ensuring they generate actionable, detailed refactoring reports with concrete extraction plans, migration steps, and code examples rather than vague suggestions.",
      "rawContent": "```json\n{\n  \"purpose\": \"Generates detailed, prescriptive prompts for LLM-based code refactoring analysis with extraction plans and migration steps.\",\n  \"userVisibleActions\": [\n    \"Receives comprehensive refactoring reports that explain what code should be extracted and why\",\n    \"Gets detailed step-by-step migration instructions for code reorganization\",\n    \"Views before-and-after code examples showing proposed refactoring changes\",\n    \"Sees function-level analysis including responsibilities, dependencies, and call relationships\"\n  ],\n  \"developerVisibleActions\": [\n    \"Creates structured prompts that guide LLMs to generate refactoring recommendations\",\n    \"Combines code analysis, product documentation, and architecture insights into refactoring instructions\",\n    \"Builds extraction plans that specify which functions should move to which files\",\n    \"Generates function analysis reports showing dependencies, dependents, and responsibilities\",\n    \"Provides detailed requirements for code extraction with migration steps and examples\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"buildDetailedRefactoringPrompt\",\n      \"desc\": \"Constructs a comprehensive prompt for generating refactoring reports with function analysis and extraction plans\",\n      \"inputs\": \"AnalysisContext, CodeAnalysis, optional EnhancedProductDocumentation, optional LLMInsights, optional FunctionAnalysis array\",\n      \"outputs\": \"Complete prompt string for LLM refactoring analysis\"\n    },\n    {\n      \"name\": \"buildBasePrompt\",\n      \"desc\": \"Creates the foundational prompt structure combining context, code analysis, and documentation\",\n      \"inputs\": \"AnalysisContext, CodeAnalysis, optional ProductDocumentation, optional ArchitectureInsights\",\n      \"outputs\": \"Base prompt string\"\n    },\n    {\n      \"name\": \"buildFunctionAnalysisSection\",\n      \"desc\": \"Generates detailed analysis section for individual functions showing their relationships and responsibilities\",\n      \"inputs\": \"Array of FunctionAnalysis objects\",\n      \"outputs\": \"Formatted function analysis text\"\n    },\n    {\n      \"name\": \"buildExtractionRequirementsSection\",\n      \"desc\": \"Creates instructions for how to structure code extraction recommendations\",\n      \"inputs\": \"None (defines format requirements)\",\n      \"outputs\": \"Extraction requirements text\"\n    }\n  ],\n  \"dependencies\": [\n    \"../../analyzer (CodeAnalysis, FileInfo, FunctionMetadata)\",\n    \"../../llmService (AnalysisContext, LLMInsights)\",\n    \"../../fileDocumentation (EnhancedProductDocumentation)\"\n  ],\n  \"intent\": \"This file exists to standardize and enhance how refactoring instructions are communicated to LLMs, ensuring they generate actionable, detailed refactoring reports with concrete extraction plans, migration steps, and code examples rather than vague suggestions.\"\n}\n```"
    },
    {
      "file": "src/domain/services/fileWatcherService.ts",
      "role": "Core Logic",
      "purpose": "Provides centralized file system watching capabilities to monitor and respond to file changes, creations, and deletions across the workspace",
      "userVisibleActions": [
        "Automatically detects when files are created, modified, or deleted in the workspace",
        "Responds to changes in specific file types (e.g., .feature files, .insights files) without manual refresh",
        "Updates UI views and displays when relevant files change",
        "Triggers automatic updates when saving documents"
      ],
      "developerVisibleActions": [
        "Register file watchers for specific patterns (e.g., '**/*.feature', '**/*.insights')",
        "Handle file creation, change, and deletion events with custom callbacks",
        "Watch for document save events across all text documents",
        "Filter file changes using ignore patterns to exclude unwanted files",
        "Unregister watchers when no longer needed to prevent memory leaks",
        "Dispose all watchers when extension deactivates"
      ],
      "keyFunctions": [
        {
          "name": "watch",
          "desc": "Creates a file system watcher for a specific pattern and registers a handler for file changes",
          "inputs": "id (string), pattern (glob pattern or RelativePattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete)",
          "outputs": "Disposable object to stop watching"
        },
        {
          "name": "unwatch",
          "desc": "Removes a specific file watcher registration by its unique ID",
          "inputs": "id (string)",
          "outputs": "void"
        },
        {
          "name": "onDocumentSave",
          "desc": "Registers a handler to be called whenever any document is saved in the workspace",
          "inputs": "handler (callback function receiving TextDocument)",
          "outputs": "Disposable object to unregister the handler"
        },
        {
          "name": "getMatchingHandlers",
          "desc": "Finds all registered handlers that should process a given file URI",
          "inputs": "uri (file URI), patternKey (pattern identifier)",
          "outputs": "Set of PatternHandler objects"
        },
        {
          "name": "shouldIgnoreFile",
          "desc": "Determines if a file should be ignored based on configured ignore patterns",
          "inputs": "filePath (string), ignorePatterns (array of glob patterns)",
          "outputs": "boolean indicating whether to ignore the file"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all watchers and handlers, releasing system resources",
          "inputs": "none",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "This file consolidates file watching functionality that was previously duplicated across multiple files (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It provides a single, reusable service for monitoring file system changes, reducing code duplication and ensuring consistent file watching behavior throughout the extension. The service allows different parts of the extension to react to file changes without each implementing their own watcher logic, and it handles cleanup to prevent resource leaks.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides centralized file system watching capabilities to monitor and respond to file changes, creations, and deletions across the workspace\",\n  \"userVisibleActions\": [\n    \"Automatically detects when files are created, modified, or deleted in the workspace\",\n    \"Responds to changes in specific file types (e.g., .feature files, .insights files) without manual refresh\",\n    \"Updates UI views and displays when relevant files change\",\n    \"Triggers automatic updates when saving documents\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register file watchers for specific patterns (e.g., '**/*.feature', '**/*.insights')\",\n    \"Handle file creation, change, and deletion events with custom callbacks\",\n    \"Watch for document save events across all text documents\",\n    \"Filter file changes using ignore patterns to exclude unwanted files\",\n    \"Unregister watchers when no longer needed to prevent memory leaks\",\n    \"Dispose all watchers when extension deactivates\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"watch\",\n      \"desc\": \"Creates a file system watcher for a specific pattern and registers a handler for file changes\",\n      \"inputs\": \"id (string), pattern (glob pattern or RelativePattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete)\",\n      \"outputs\": \"Disposable object to stop watching\"\n    },\n    {\n      \"name\": \"unwatch\",\n      \"desc\": \"Removes a specific file watcher registration by its unique ID\",\n      \"inputs\": \"id (string)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"onDocumentSave\",\n      \"desc\": \"Registers a handler to be called whenever any document is saved in the workspace\",\n      \"inputs\": \"handler (callback function receiving TextDocument)\",\n      \"outputs\": \"Disposable object to unregister the handler\"\n    },\n    {\n      \"name\": \"getMatchingHandlers\",\n      \"desc\": \"Finds all registered handlers that should process a given file URI\",\n      \"inputs\": \"uri (file URI), patternKey (pattern identifier)\",\n      \"outputs\": \"Set of PatternHandler objects\"\n    },\n    {\n      \"name\": \"shouldIgnoreFile\",\n      \"desc\": \"Determines if a file should be ignored based on configured ignore patterns\",\n      \"inputs\": \"filePath (string), ignorePatterns (array of glob patterns)\",\n      \"outputs\": \"boolean indicating whether to ignore the file\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all watchers and handlers, releasing system resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"This file consolidates file watching functionality that was previously duplicated across multiple files (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It provides a single, reusable service for monitoring file system changes, reducing code duplication and ensuring consistent file watching behavior throughout the extension. The service allows different parts of the extension to react to file changes without each implementing their own watcher logic, and it handles cleanup to prevent resource leaks.\"\n}\n```"
    },
    {
      "file": "src/domain/services/incrementalAnalysisService.ts",
      "role": "Core Logic",
      "purpose": "Handles iterative analysis where an LLM makes multiple requests for files or code searches until it has enough information to complete its task",
      "userVisibleActions": [
        "User receives analysis results that may require multiple rounds of file access and code searching",
        "User sees progress updates as the system iterates through analysis rounds",
        "User experiences automatic retrieval of additional file content when the LLM needs more context",
        "User gets grep search results automatically incorporated into analysis when patterns need to be found"
      ],
      "developerVisibleActions": [
        "Developer triggers incremental analysis that automatically handles LLM requests for more information",
        "Developer receives iteration callbacks showing progress through analysis rounds",
        "Developer gets structured results containing the final analysis, iteration count, and all requests made",
        "Developer can configure maximum iterations to prevent infinite loops",
        "Developer sees file read and grep search requests processed automatically up to 5 requests per iteration",
        "Developer receives conversation messages with assistant responses and user-provided additional information"
      ],
      "keyFunctions": [
        {
          "name": "processRequests",
          "desc": "Processes LLM requests for files and grep searches, returning formatted additional information and updated conversation messages",
          "inputs": "requests: LLMRequest[], currentResult: any, messages: conversation array",
          "outputs": "ProcessRequestsResult with additionalInfo string and updated messages array"
        },
        {
          "name": "IterationResult<T>",
          "desc": "Structure containing the final result, iteration count, all requests made, and whether to continue",
          "inputs": "Generic type T for result",
          "outputs": "result: T, iteration: number, maxIterations: number, requests: LLMRequest[], shouldContinue: boolean"
        },
        {
          "name": "IterationCallbacks<T>",
          "desc": "Optional callbacks for monitoring iteration progress",
          "inputs": "Generic type T for result",
          "outputs": "onIterationStart and onIterationComplete callback functions"
        }
      ],
      "dependencies": [
        "fileAccessHelper",
        "LLMRequest type definitions"
      ],
      "intent": "This file exists to eliminate code duplication and improve testability by extracting the iterative LLM analysis pattern into a reusable service. It solves the problem of LLMs needing multiple rounds of information gathering (file reads, grep searches) before completing an analysis, converting while-loop patterns into async iterator patterns that are easier to test and maintain.",
      "rawContent": "```json\n{\n  \"purpose\": \"Handles iterative analysis where an LLM makes multiple requests for files or code searches until it has enough information to complete its task\",\n  \"userVisibleActions\": [\n    \"User receives analysis results that may require multiple rounds of file access and code searching\",\n    \"User sees progress updates as the system iterates through analysis rounds\",\n    \"User experiences automatic retrieval of additional file content when the LLM needs more context\",\n    \"User gets grep search results automatically incorporated into analysis when patterns need to be found\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer triggers incremental analysis that automatically handles LLM requests for more information\",\n    \"Developer receives iteration callbacks showing progress through analysis rounds\",\n    \"Developer gets structured results containing the final analysis, iteration count, and all requests made\",\n    \"Developer can configure maximum iterations to prevent infinite loops\",\n    \"Developer sees file read and grep search requests processed automatically up to 5 requests per iteration\",\n    \"Developer receives conversation messages with assistant responses and user-provided additional information\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Processes LLM requests for files and grep searches, returning formatted additional information and updated conversation messages\",\n      \"inputs\": \"requests: LLMRequest[], currentResult: any, messages: conversation array\",\n      \"outputs\": \"ProcessRequestsResult with additionalInfo string and updated messages array\"\n    },\n    {\n      \"name\": \"IterationResult<T>\",\n      \"desc\": \"Structure containing the final result, iteration count, all requests made, and whether to continue\",\n      \"inputs\": \"Generic type T for result\",\n      \"outputs\": \"result: T, iteration: number, maxIterations: number, requests: LLMRequest[], shouldContinue: boolean\"\n    },\n    {\n      \"name\": \"IterationCallbacks<T>\",\n      \"desc\": \"Optional callbacks for monitoring iteration progress\",\n      \"inputs\": \"Generic type T for result\",\n      \"outputs\": \"onIterationStart and onIterationComplete callback functions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fileAccessHelper\",\n    \"LLMRequest type definitions\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication and improve testability by extracting the iterative LLM analysis pattern into a reusable service. It solves the problem of LLMs needing multiple rounds of information gathering (file reads, grep searches) before completing an analysis, converting while-loop patterns into async iterator patterns that are easier to test and maintain.\"\n}\n```"
    },
    {
      "file": "src/domain/services/testConfigurationService.ts",
      "role": "Core Logic",
      "purpose": "Automatically detects test framework configuration (Jest, Mocha, Vitest, Pytest) and identifies missing dependencies or setup requirements to ensure generated tests work without manual configuration.",
      "userVisibleActions": [
        "Automatically detects which test framework is being used in the workspace (Jest, Mocha, Vitest, or Pytest)",
        "Identifies missing test dependencies that need to be installed",
        "Shows configuration status indicating whether tests are ready to run",
        "Reports whether TypeScript support is properly configured for the test framework",
        "Indicates if test setup files or configuration files are missing"
      ],
      "developerVisibleActions": [
        "Scans package.json to detect test scripts and installed test framework dependencies",
        "Checks for framework-specific configuration files (jest.config.js, mocha.opts, vitest.config.ts, pytest.ini)",
        "Detects if TypeScript is used and validates TypeScript test support (ts-jest, @types packages)",
        "Returns detailed status including framework type, configuration state, and required setup actions",
        "Provides list of missing dependencies that need installation",
        "Determines if additional setup is required before tests can be generated"
      ],
      "keyFunctions": [
        {
          "name": "detectTestConfiguration",
          "desc": "Analyzes workspace to determine test framework, configuration status, and missing dependencies",
          "inputs": "workspaceRoot: string (path to workspace folder)",
          "outputs": "TestConfigStatus object with framework type, configuration state, missing dependencies, and setup actions"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "SWLogger"
      ],
      "intent": "Eliminates manual test configuration by automatically detecting the test framework and setup requirements, ensuring that AI-generated tests work immediately without requiring users to manually configure test environments or install missing dependencies.",
      "rawContent": "```json\n{\n  \"purpose\": \"Automatically detects test framework configuration (Jest, Mocha, Vitest, Pytest) and identifies missing dependencies or setup requirements to ensure generated tests work without manual configuration.\",\n  \"userVisibleActions\": [\n    \"Automatically detects which test framework is being used in the workspace (Jest, Mocha, Vitest, or Pytest)\",\n    \"Identifies missing test dependencies that need to be installed\",\n    \"Shows configuration status indicating whether tests are ready to run\",\n    \"Reports whether TypeScript support is properly configured for the test framework\",\n    \"Indicates if test setup files or configuration files are missing\"\n  ],\n  \"developerVisibleActions\": [\n    \"Scans package.json to detect test scripts and installed test framework dependencies\",\n    \"Checks for framework-specific configuration files (jest.config.js, mocha.opts, vitest.config.ts, pytest.ini)\",\n    \"Detects if TypeScript is used and validates TypeScript test support (ts-jest, @types packages)\",\n    \"Returns detailed status including framework type, configuration state, and required setup actions\",\n    \"Provides list of missing dependencies that need installation\",\n    \"Determines if additional setup is required before tests can be generated\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"detectTestConfiguration\",\n      \"desc\": \"Analyzes workspace to determine test framework, configuration status, and missing dependencies\",\n      \"inputs\": \"workspaceRoot: string (path to workspace folder)\",\n      \"outputs\": \"TestConfigStatus object with framework type, configuration state, missing dependencies, and setup actions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"SWLogger\"\n  ],\n  \"intent\": \"Eliminates manual test configuration by automatically detecting the test framework and setup requirements, ensuring that AI-generated tests work immediately without requiring users to manually configure test environments or install missing dependencies.\"\n}\n```"
    },
    {
      "file": "src/extension.ts",
      "role": "Core Logic",
      "purpose": "Main entry point that initializes and coordinates the code analysis extension, registering all commands and UI components.",
      "userVisibleActions": [
        "Click 'Analyze Code' command to scan current workspace and show insights",
        "View code analysis results in a tree view panel",
        "See diagnostic warnings/errors in the Problems panel",
        "Navigate through product features via Product Navigator tree view",
        "Browse analysis results in Analysis Viewer webview",
        "View AI-generated insights in Insights Viewer webview",
        "Explore static analysis findings in Static Analysis Viewer",
        "Access unit test information via Unit Tests Navigator",
        "See analysis status in status bar with loading indicator",
        "Open specific files by clicking items in tree views",
        "Auto-refresh analysis when files change in workspace",
        "Generate LLM-ready context from code analysis",
        "Copy formatted analysis to clipboard for AI assistants"
      ],
      "developerVisibleActions": [
        "Extension activates when VS Code starts or workspace opens",
        "Registers multiple tree view providers for different perspectives",
        "Initializes code analyzer to parse TypeScript/JavaScript files",
        "Sets up file watcher to detect code changes automatically",
        "Creates diagnostics provider to surface code issues",
        "Establishes cache layer for performance optimization",
        "Bootstraps all extension components and dependencies",
        "Registers command palette commands for analysis actions",
        "Manages configuration through VS Code settings",
        "Handles errors and logs them appropriately",
        "Disposes resources on extension deactivation"
      ],
      "keyFunctions": [
        {
          "name": "activate",
          "desc": "Entry point that initializes extension, creates all components, and registers commands",
          "inputs": "vscode.ExtensionContext",
          "outputs": "void"
        },
        {
          "name": "deactivate",
          "desc": "Cleanup function that disposes resources when extension shuts down",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "runAnalysis",
          "desc": "Executes code analysis on workspace and updates all views with results",
          "inputs": "workspace folder path",
          "outputs": "analysis results object"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "./analyzer",
        "./insightGenerator",
        "./llmFormatter",
        "./fileWatcher",
        "./insightsTreeView",
        "./diagnosticsProvider",
        "./cache",
        "./llmIntegration",
        "./productNavigator",
        "./analysisViewer",
        "./insightsViewer",
        "./staticAnalysisViewer",
        "./unitTestsNavigator",
        "./config/configurationManager",
        "./utils/errorHandler",
        "./ui/webview/webviewTemplateEngine",
        "./domain/bootstrap/extensionBootstrapper",
        "./domain/bootstrap/commandRegistry",
        "./domain/handlers/navigationHandler"
      ],
      "intent": "This file exists to orchestrate the entire code analysis extension by wiring together all components (analyzers, viewers, generators) and exposing them through VS Code's command palette and UI panels. It solves the problem of coordinating complex analysis workflows and presenting results through multiple specialized views.",
      "rawContent": "```json\n{\n  \"purpose\": \"Main entry point that initializes and coordinates the code analysis extension, registering all commands and UI components.\",\n  \"userVisibleActions\": [\n    \"Click 'Analyze Code' command to scan current workspace and show insights\",\n    \"View code analysis results in a tree view panel\",\n    \"See diagnostic warnings/errors in the Problems panel\",\n    \"Navigate through product features via Product Navigator tree view\",\n    \"Browse analysis results in Analysis Viewer webview\",\n    \"View AI-generated insights in Insights Viewer webview\",\n    \"Explore static analysis findings in Static Analysis Viewer\",\n    \"Access unit test information via Unit Tests Navigator\",\n    \"See analysis status in status bar with loading indicator\",\n    \"Open specific files by clicking items in tree views\",\n    \"Auto-refresh analysis when files change in workspace\",\n    \"Generate LLM-ready context from code analysis\",\n    \"Copy formatted analysis to clipboard for AI assistants\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extension activates when VS Code starts or workspace opens\",\n    \"Registers multiple tree view providers for different perspectives\",\n    \"Initializes code analyzer to parse TypeScript/JavaScript files\",\n    \"Sets up file watcher to detect code changes automatically\",\n    \"Creates diagnostics provider to surface code issues\",\n    \"Establishes cache layer for performance optimization\",\n    \"Bootstraps all extension components and dependencies\",\n    \"Registers command palette commands for analysis actions\",\n    \"Manages configuration through VS Code settings\",\n    \"Handles errors and logs them appropriately\",\n    \"Disposes resources on extension deactivation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"activate\",\n      \"desc\": \"Entry point that initializes extension, creates all components, and registers commands\",\n      \"inputs\": \"vscode.ExtensionContext\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"deactivate\",\n      \"desc\": \"Cleanup function that disposes resources when extension shuts down\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"runAnalysis\",\n      \"desc\": \"Executes code analysis on workspace and updates all views with results\",\n      \"inputs\": \"workspace folder path\",\n      \"outputs\": \"analysis results object\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./analyzer\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./fileWatcher\",\n    \"./insightsTreeView\",\n    \"./diagnosticsProvider\",\n    \"./cache\",\n    \"./llmIntegration\",\n    \"./productNavigator\",\n    \"./analysisViewer\",\n    \"./insightsViewer\",\n    \"./staticAnalysisViewer\",\n    \"./unitTestsNavigator\",\n    \"./config/configurationManager\",\n    \"./utils/errorHandler\",\n    \"./ui/webview/webviewTemplateEngine\",\n    \"./domain/bootstrap/extensionBootstrapper\",\n    \"./domain/bootstrap/commandRegistry\",\n    \"./domain/handlers/navigationHandler\"\n  ],\n  \"intent\": \"This file exists to orchestrate the entire code analysis extension by wiring together all components (analyzers, viewers, generators) and exposing them through VS Code's command palette and UI panels. It solves the problem of coordinating complex analysis workflows and presenting results through multiple specialized views.\"\n}\n```"
    },
    {
      "file": "src/fileAccessHelper.ts",
      "role": "Core Logic",
      "purpose": "Provides file reading and grep search functionality to enable iterative analysis of codebases by LLM agents",
      "userVisibleActions": [
        "LLM can request to read specific files from the workspace",
        "LLM can search for code patterns across multiple files using grep",
        "LLM receives file contents with line counts and existence status",
        "LLM receives search results with matching lines and context",
        "Search results are limited to prevent overwhelming the LLM with too many matches"
      ],
      "developerVisibleActions": [
        "Developer provides workspace root path to initialize file access",
        "Developer can request file contents by specifying file paths",
        "Developer can search codebase using regex patterns with optional file filters",
        "Developer receives structured responses with file metadata (lines, existence)",
        "Developer receives grep results with line numbers and surrounding context",
        "Developer can limit number of search results returned",
        "Developer can filter searches by file patterns (glob patterns like '*.ts')",
        "Developer receives organized file listings grouped by folder"
      ],
      "keyFunctions": [
        {
          "name": "getFileListing",
          "desc": "Organizes and formats a list of files grouped by their containing folders",
          "inputs": "Array of file objects with path, lines, and language",
          "outputs": "Formatted string with files organized by folder hierarchy"
        },
        {
          "name": "readFile",
          "desc": "Reads a file from the workspace and returns its content with metadata",
          "inputs": "File path relative to workspace root",
          "outputs": "FileResponse with content, line count, and existence status"
        },
        {
          "name": "grep",
          "desc": "Searches for a pattern across workspace files with optional filtering",
          "inputs": "Search pattern, optional file pattern filter, optional max results limit",
          "outputs": "GrepResponse with matches, line numbers, context, and limitation status"
        },
        {
          "name": "processRequest",
          "desc": "Routes and processes either file read or grep requests from LLM",
          "inputs": "LLMRequest (either FileRequest or GrepRequest)",
          "outputs": "Either FileResponse or GrepResponse depending on request type"
        }
      ],
      "dependencies": [
        "fs",
        "path"
      ],
      "intent": "This file exists to give LLM agents the ability to iteratively explore and analyze codebases by reading specific files and searching for patterns, enabling more thorough and targeted code understanding without loading entire codebases upfront",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides file reading and grep search functionality to enable iterative analysis of codebases by LLM agents\",\n  \"userVisibleActions\": [\n    \"LLM can request to read specific files from the workspace\",\n    \"LLM can search for code patterns across multiple files using grep\",\n    \"LLM receives file contents with line counts and existence status\",\n    \"LLM receives search results with matching lines and context\",\n    \"Search results are limited to prevent overwhelming the LLM with too many matches\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer provides workspace root path to initialize file access\",\n    \"Developer can request file contents by specifying file paths\",\n    \"Developer can search codebase using regex patterns with optional file filters\",\n    \"Developer receives structured responses with file metadata (lines, existence)\",\n    \"Developer receives grep results with line numbers and surrounding context\",\n    \"Developer can limit number of search results returned\",\n    \"Developer can filter searches by file patterns (glob patterns like '*.ts')\",\n    \"Developer receives organized file listings grouped by folder\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getFileListing\",\n      \"desc\": \"Organizes and formats a list of files grouped by their containing folders\",\n      \"inputs\": \"Array of file objects with path, lines, and language\",\n      \"outputs\": \"Formatted string with files organized by folder hierarchy\"\n    },\n    {\n      \"name\": \"readFile\",\n      \"desc\": \"Reads a file from the workspace and returns its content with metadata\",\n      \"inputs\": \"File path relative to workspace root\",\n      \"outputs\": \"FileResponse with content, line count, and existence status\"\n    },\n    {\n      \"name\": \"grep\",\n      \"desc\": \"Searches for a pattern across workspace files with optional filtering\",\n      \"inputs\": \"Search pattern, optional file pattern filter, optional max results limit\",\n      \"outputs\": \"GrepResponse with matches, line numbers, context, and limitation status\"\n    },\n    {\n      \"name\": \"processRequest\",\n      \"desc\": \"Routes and processes either file read or grep requests from LLM\",\n      \"inputs\": \"LLMRequest (either FileRequest or GrepRequest)\",\n      \"outputs\": \"Either FileResponse or GrepResponse depending on request type\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\"\n  ],\n  \"intent\": \"This file exists to give LLM agents the ability to iteratively explore and analyze codebases by reading specific files and searching for patterns, enabling more thorough and targeted code understanding without loading entire codebases upfront\"\n}\n```"
    },
    {
      "file": "src/fileDocumentation.ts",
      "role": "Core Logic",
      "purpose": "Defines the type system and data structures for organizing code documentation at file, module, and product levels.",
      "userVisibleActions": [
        "No direct user-visible actions - this file defines data structures used internally"
      ],
      "developerVisibleActions": [
        "Import and use TypeScript interfaces to structure documentation data",
        "Create FileSummary objects to document individual code files with role, purpose, and key functions",
        "Build ModuleSummary objects to organize files into logical modules with capabilities",
        "Generate EnhancedProductDocumentation with product overview, user perspectives, and architecture",
        "Access structured documentation data through well-defined TypeScript types",
        "Use these interfaces to ensure consistent documentation format across the codebase"
      ],
      "keyFunctions": [
        {
          "name": "FileSummary",
          "desc": "Interface defining how individual file documentation is structured",
          "inputs": "file path, role, purpose, actions, functions, dependencies",
          "outputs": "Structured file-level documentation object"
        },
        {
          "name": "ModuleSummary",
          "desc": "Interface defining how module-level documentation is structured",
          "inputs": "module path, type, capabilities, files, endpoints/commands/workers",
          "outputs": "Structured module-level documentation object"
        },
        {
          "name": "EnhancedProductDocumentation",
          "desc": "Interface defining complete product documentation structure",
          "inputs": "overview, user perspectives (GUI/CLI/API/CICD), architecture, workflows, problems solved",
          "outputs": "Comprehensive product documentation object"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./analyzer"
      ],
      "intent": "This file exists to establish a consistent, hierarchical documentation structure that organizes code documentation from individual files up to product-level summaries. It provides TypeScript type definitions that ensure all documentation follows the same format, making it easier to generate, aggregate, and consume documentation programmatically across the codebase.",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines the type system and data structures for organizing code documentation at file, module, and product levels.\",\n  \"userVisibleActions\": [\n    \"No direct user-visible actions - this file defines data structures used internally\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import and use TypeScript interfaces to structure documentation data\",\n    \"Create FileSummary objects to document individual code files with role, purpose, and key functions\",\n    \"Build ModuleSummary objects to organize files into logical modules with capabilities\",\n    \"Generate EnhancedProductDocumentation with product overview, user perspectives, and architecture\",\n    \"Access structured documentation data through well-defined TypeScript types\",\n    \"Use these interfaces to ensure consistent documentation format across the codebase\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"FileSummary\",\n      \"desc\": \"Interface defining how individual file documentation is structured\",\n      \"inputs\": \"file path, role, purpose, actions, functions, dependencies\",\n      \"outputs\": \"Structured file-level documentation object\"\n    },\n    {\n      \"name\": \"ModuleSummary\",\n      \"desc\": \"Interface defining how module-level documentation is structured\",\n      \"inputs\": \"module path, type, capabilities, files, endpoints/commands/workers\",\n      \"outputs\": \"Structured module-level documentation object\"\n    },\n    {\n      \"name\": \"EnhancedProductDocumentation\",\n      \"desc\": \"Interface defining complete product documentation structure\",\n      \"inputs\": \"overview, user perspectives (GUI/CLI/API/CICD), architecture, workflows, problems solved\",\n      \"outputs\": \"Comprehensive product documentation object\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to establish a consistent, hierarchical documentation structure that organizes code documentation from individual files up to product-level summaries. It provides TypeScript type definitions that ensure all documentation follows the same format, making it easier to generate, aggregate, and consume documentation programmatically across the codebase.\"\n}\n```"
    },
    {
      "file": "src/fileWatcher.ts",
      "role": "Core Logic",
      "purpose": "Monitors file saves and automatically triggers code analysis when TypeScript files are saved",
      "userVisibleActions": [
        "Code is automatically analyzed when you save a TypeScript file",
        "Analysis results appear in diagnostics and insights tree after file save",
        "Duplicate analyses are prevented when saving files rapidly",
        "Analysis can be throttled based on configuration settings"
      ],
      "developerVisibleActions": [
        "File watcher automatically starts when extension activates if 'analyzeOnSave' is enabled",
        "Debouncing mechanism prevents multiple analyses from running simultaneously",
        "File saves trigger analysis pipeline: analyzer → insight generator → diagnostics → tree view",
        "Analysis is skipped if already in progress or too soon after last analysis",
        "Watcher can be started and stopped programmatically",
        "Errors during analysis are handled and logged without crashing the extension"
      ],
      "keyFunctions": [
        {
          "name": "start",
          "desc": "Starts watching for file saves and sets up automatic analysis",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "stop",
          "desc": "Stops watching for file saves and cleans up resources",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "onFileSaved",
          "desc": "Handles file save events and triggers analysis after debounce delay",
          "inputs": "document: vscode.TextDocument",
          "outputs": "void"
        },
        {
          "name": "triggerAnalysis",
          "desc": "Executes the analysis pipeline when conditions are met",
          "inputs": "document: vscode.TextDocument",
          "outputs": "Promise<void>"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all resources and stops the file watcher",
          "inputs": "none",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "CodeAnalyzer",
        "InsightGenerator",
        "DiagnosticsProvider",
        "InsightsTreeProvider",
        "ConfigurationManager",
        "ErrorHandler",
        "FileWatcherService"
      ],
      "intent": "This file exists to provide automatic code analysis triggered by file saves, giving users immediate feedback on their code without manual intervention. It solves the problem of having to manually trigger analysis after every code change by implementing intelligent debouncing and state management to ensure efficient, non-blocking analysis workflow.",
      "rawContent": "```json\n{\n  \"purpose\": \"Monitors file saves and automatically triggers code analysis when TypeScript files are saved\",\n  \"userVisibleActions\": [\n    \"Code is automatically analyzed when you save a TypeScript file\",\n    \"Analysis results appear in diagnostics and insights tree after file save\",\n    \"Duplicate analyses are prevented when saving files rapidly\",\n    \"Analysis can be throttled based on configuration settings\"\n  ],\n  \"developerVisibleActions\": [\n    \"File watcher automatically starts when extension activates if 'analyzeOnSave' is enabled\",\n    \"Debouncing mechanism prevents multiple analyses from running simultaneously\",\n    \"File saves trigger analysis pipeline: analyzer → insight generator → diagnostics → tree view\",\n    \"Analysis is skipped if already in progress or too soon after last analysis\",\n    \"Watcher can be started and stopped programmatically\",\n    \"Errors during analysis are handled and logged without crashing the extension\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"start\",\n      \"desc\": \"Starts watching for file saves and sets up automatic analysis\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"stop\",\n      \"desc\": \"Stops watching for file saves and cleans up resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"onFileSaved\",\n      \"desc\": \"Handles file save events and triggers analysis after debounce delay\",\n      \"inputs\": \"document: vscode.TextDocument\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"triggerAnalysis\",\n      \"desc\": \"Executes the analysis pipeline when conditions are met\",\n      \"inputs\": \"document: vscode.TextDocument\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all resources and stops the file watcher\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"CodeAnalyzer\",\n    \"InsightGenerator\",\n    \"DiagnosticsProvider\",\n    \"InsightsTreeProvider\",\n    \"ConfigurationManager\",\n    \"ErrorHandler\",\n    \"FileWatcherService\"\n  ],\n  \"intent\": \"This file exists to provide automatic code analysis triggered by file saves, giving users immediate feedback on their code without manual intervention. It solves the problem of having to manually trigger analysis after every code change by implementing intelligent debouncing and state management to ensure efficient, non-blocking analysis workflow.\"\n}\n```"
    },
    {
      "file": "src/infrastructure/fileSystem/fileCache.ts",
      "role": "Core Logic",
      "purpose": "Caches file contents in memory to reduce redundant file system reads and improve performance across the extension.",
      "userVisibleActions": [
        "Faster file access when the same file is read multiple times",
        "Automatic refresh of cached content when files are modified on disk",
        "Improved extension responsiveness due to reduced disk I/O operations"
      ],
      "developerVisibleActions": [
        "Retrieve file content with automatic caching via getFile() method",
        "Cache automatically invalidates when files change on disk through file system watcher",
        "LRU (Least Recently Used) eviction policy maintains cache size limits",
        "Cache statistics available for monitoring hits, misses, and evictions",
        "Cache entries expire after a TTL (time-to-live) period to ensure freshness",
        "File hash verification ensures cached content matches current disk content"
      ],
      "keyFunctions": [
        {
          "name": "getFile",
          "desc": "Retrieves file content from cache if available and valid, otherwise reads from disk and caches it",
          "inputs": "filePath: string",
          "outputs": "Promise<string> - file content"
        },
        {
          "name": "constructor",
          "desc": "Initializes the cache with configurable size limit and TTL settings",
          "inputs": "maxSize: number (default 500), ttl: number (default 5000ms)",
          "outputs": "FileCache instance"
        },
        {
          "name": "setupWatcher",
          "desc": "Sets up file system watcher to automatically invalidate cache entries when files change",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "isStale",
          "desc": "Checks if a cached entry has exceeded its TTL",
          "inputs": "cached: CachedFile",
          "outputs": "boolean"
        },
        {
          "name": "evictIfNeeded",
          "desc": "Removes least recently used entries when cache size exceeds maximum",
          "inputs": "none",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "fs",
        "path"
      ],
      "intent": "This file exists to optimize file system operations by caching frequently accessed files in memory, reducing disk I/O and improving extension performance. It solves the problem of redundant file reads across multiple components by providing a centralized, automatically invalidating cache with size management and freshness guarantees.",
      "rawContent": "```json\n{\n  \"purpose\": \"Caches file contents in memory to reduce redundant file system reads and improve performance across the extension.\",\n  \"userVisibleActions\": [\n    \"Faster file access when the same file is read multiple times\",\n    \"Automatic refresh of cached content when files are modified on disk\",\n    \"Improved extension responsiveness due to reduced disk I/O operations\"\n  ],\n  \"developerVisibleActions\": [\n    \"Retrieve file content with automatic caching via getFile() method\",\n    \"Cache automatically invalidates when files change on disk through file system watcher\",\n    \"LRU (Least Recently Used) eviction policy maintains cache size limits\",\n    \"Cache statistics available for monitoring hits, misses, and evictions\",\n    \"Cache entries expire after a TTL (time-to-live) period to ensure freshness\",\n    \"File hash verification ensures cached content matches current disk content\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getFile\",\n      \"desc\": \"Retrieves file content from cache if available and valid, otherwise reads from disk and caches it\",\n      \"inputs\": \"filePath: string\",\n      \"outputs\": \"Promise<string> - file content\"\n    },\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes the cache with configurable size limit and TTL settings\",\n      \"inputs\": \"maxSize: number (default 500), ttl: number (default 5000ms)\",\n      \"outputs\": \"FileCache instance\"\n    },\n    {\n      \"name\": \"setupWatcher\",\n      \"desc\": \"Sets up file system watcher to automatically invalidate cache entries when files change\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"isStale\",\n      \"desc\": \"Checks if a cached entry has exceeded its TTL\",\n      \"inputs\": \"cached: CachedFile\",\n      \"outputs\": \"boolean\"\n    },\n    {\n      \"name\": \"evictIfNeeded\",\n      \"desc\": \"Removes least recently used entries when cache size exceeds maximum\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\"\n  ],\n  \"intent\": \"This file exists to optimize file system operations by caching frequently accessed files in memory, reducing disk I/O and improving extension performance. It solves the problem of redundant file reads across multiple components by providing a centralized, automatically invalidating cache with size management and freshness guarantees.\"\n}\n```"
    },
    {
      "file": "src/infrastructure/fileSystem/fileProcessor.ts",
      "role": "Core Logic",
      "purpose": "Provides a unified file processing system that filters, reads, and processes multiple files in parallel while handling errors consistently",
      "userVisibleActions": [
        "Files are automatically filtered to skip non-source directories (node_modules, .git, dist, build, etc.)",
        "Multiple files are processed simultaneously for faster operations",
        "Errors during file processing are caught and handled gracefully"
      ],
      "developerVisibleActions": [
        "Developer provides an array of file paths and a processing function",
        "System automatically filters out unwanted files based on patterns",
        "Files are read and processed in parallel batches",
        "Custom file filters can be provided to override default skip patterns",
        "Custom file readers can be injected for testing or alternate file sources",
        "Error context can be passed for better error tracking and debugging"
      ],
      "keyFunctions": [
        {
          "name": "shouldProcess",
          "desc": "Determines if a file should be processed based on filter patterns",
          "inputs": "filePath (string)",
          "outputs": "boolean indicating whether to process the file"
        },
        {
          "name": "readFile",
          "desc": "Reads file content from the filesystem",
          "inputs": "filePath (string)",
          "outputs": "Promise<string> containing file content"
        },
        {
          "name": "processFiles",
          "desc": "Processes multiple files in parallel with filtering, reading, and custom processing logic",
          "inputs": "files (string[]), processor function, optional error context",
          "outputs": "Promise<T[]> containing processed results for each file"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "../../utils/errorHandler"
      ],
      "intent": "This file exists to eliminate duplicate file processing patterns scattered across the codebase by providing a single, reusable system for filtering files, reading them, and processing them in parallel. It solves the problem of inconsistent file handling, reduces code duplication, and provides a standardized way to process multiple files with built-in error handling and customizable filtering.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a unified file processing system that filters, reads, and processes multiple files in parallel while handling errors consistently\",\n  \"userVisibleActions\": [\n    \"Files are automatically filtered to skip non-source directories (node_modules, .git, dist, build, etc.)\",\n    \"Multiple files are processed simultaneously for faster operations\",\n    \"Errors during file processing are caught and handled gracefully\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer provides an array of file paths and a processing function\",\n    \"System automatically filters out unwanted files based on patterns\",\n    \"Files are read and processed in parallel batches\",\n    \"Custom file filters can be provided to override default skip patterns\",\n    \"Custom file readers can be injected for testing or alternate file sources\",\n    \"Error context can be passed for better error tracking and debugging\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"shouldProcess\",\n      \"desc\": \"Determines if a file should be processed based on filter patterns\",\n      \"inputs\": \"filePath (string)\",\n      \"outputs\": \"boolean indicating whether to process the file\"\n    },\n    {\n      \"name\": \"readFile\",\n      \"desc\": \"Reads file content from the filesystem\",\n      \"inputs\": \"filePath (string)\",\n      \"outputs\": \"Promise<string> containing file content\"\n    },\n    {\n      \"name\": \"processFiles\",\n      \"desc\": \"Processes multiple files in parallel with filtering, reading, and custom processing logic\",\n      \"inputs\": \"files (string[]), processor function, optional error context\",\n      \"outputs\": \"Promise<T[]> containing processed results for each file\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"../../utils/errorHandler\"\n  ],\n  \"intent\": \"This file exists to eliminate duplicate file processing patterns scattered across the codebase by providing a single, reusable system for filtering files, reading them, and processing them in parallel. It solves the problem of inconsistent file handling, reduces code duplication, and provides a standardized way to process multiple files with built-in error handling and customizable filtering.\"\n}\n```"
    },
    {
      "file": "src/infrastructure/persistence/analysisResultRepository.ts",
      "role": "Core Logic",
      "purpose": "Manages saving and organizing analysis results (product documentation, architecture insights, summaries) to disk in timestamped directories",
      "userVisibleActions": [
        "Analysis results are automatically saved to .shadow/docs and .shadow/insights directories",
        "Each analysis run creates a new timestamped folder to preserve history",
        "Product documentation files are saved with formatted markdown content",
        "Architecture insights are saved as structured markdown reports",
        "Project summaries are saved in markdown format with metadata",
        "All saved files are accessible for later review and comparison"
      ],
      "developerVisibleActions": [
        "Initialize a product documentation run to prepare storage location",
        "Initialize an architecture insights run to prepare storage location",
        "Save individual product documentation files with enhanced metadata",
        "Save architecture insights with categorized findings",
        "Save project summaries with key metrics and information",
        "Finalize runs to complete storage operations",
        "Storage automatically creates timestamped directory structures",
        "Files are organized by analysis type and timestamp"
      ],
      "keyFunctions": [
        {
          "name": "initializeProductDocsRun",
          "desc": "Creates a new timestamped directory for storing product documentation",
          "inputs": "workspaceRoot (string)",
          "outputs": "runDir path (string)"
        },
        {
          "name": "initializeArchitectureInsightsRun",
          "desc": "Creates a new timestamped directory for storing architecture insights",
          "inputs": "workspaceRoot (string)",
          "outputs": "runDir path (string)"
        },
        {
          "name": "saveProductDocumentation",
          "desc": "Saves enhanced product documentation to a markdown file",
          "inputs": "relativePath (string), documentation (EnhancedProductDocumentation)",
          "outputs": "void"
        },
        {
          "name": "saveArchitectureInsights",
          "desc": "Saves architecture analysis insights to a markdown file",
          "inputs": "insights (LLMInsights)",
          "outputs": "void"
        },
        {
          "name": "saveSummary",
          "desc": "Saves project analysis summary to a markdown file",
          "inputs": "summary (object with title, description, keyFeatures, etc.)",
          "outputs": "void"
        },
        {
          "name": "finalizeProductDocsRun",
          "desc": "Completes the product documentation run and cleans up",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "finalizeArchitectureInsightsRun",
          "desc": "Completes the architecture insights run and cleans up",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getCurrentProductDocsRunDir",
          "desc": "Retrieves the current product documentation storage directory",
          "inputs": "none",
          "outputs": "runDir path (string or null)"
        },
        {
          "name": "getCurrentArchitectureInsightsRunDir",
          "desc": "Retrieves the current architecture insights storage directory",
          "inputs": "none",
          "outputs": "runDir path (string or null)"
        }
      ],
      "dependencies": [
        "vscode",
        "fs",
        "path",
        "../../fileDocumentation (EnhancedProductDocumentation)",
        "../../llmService (LLMInsights)",
        "../../domain/formatters/documentationFormatter (DocumentationFormatter)",
        "../../storage/incrementalStorage (createTimestampedStorage)"
      ],
      "intent": "This file exists to separate data persistence concerns from analysis logic, providing a clean interface for saving analysis results to disk while maintaining organized, timestamped storage that preserves historical analysis runs and makes results easily accessible for review.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages saving and organizing analysis results (product documentation, architecture insights, summaries) to disk in timestamped directories\",\n  \"userVisibleActions\": [\n    \"Analysis results are automatically saved to .shadow/docs and .shadow/insights directories\",\n    \"Each analysis run creates a new timestamped folder to preserve history\",\n    \"Product documentation files are saved with formatted markdown content\",\n    \"Architecture insights are saved as structured markdown reports\",\n    \"Project summaries are saved in markdown format with metadata\",\n    \"All saved files are accessible for later review and comparison\"\n  ],\n  \"developerVisibleActions\": [\n    \"Initialize a product documentation run to prepare storage location\",\n    \"Initialize an architecture insights run to prepare storage location\",\n    \"Save individual product documentation files with enhanced metadata\",\n    \"Save architecture insights with categorized findings\",\n    \"Save project summaries with key metrics and information\",\n    \"Finalize runs to complete storage operations\",\n    \"Storage automatically creates timestamped directory structures\",\n    \"Files are organized by analysis type and timestamp\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initializeProductDocsRun\",\n      \"desc\": \"Creates a new timestamped directory for storing product documentation\",\n      \"inputs\": \"workspaceRoot (string)\",\n      \"outputs\": \"runDir path (string)\"\n    },\n    {\n      \"name\": \"initializeArchitectureInsightsRun\",\n      \"desc\": \"Creates a new timestamped directory for storing architecture insights\",\n      \"inputs\": \"workspaceRoot (string)\",\n      \"outputs\": \"runDir path (string)\"\n    },\n    {\n      \"name\": \"saveProductDocumentation\",\n      \"desc\": \"Saves enhanced product documentation to a markdown file\",\n      \"inputs\": \"relativePath (string), documentation (EnhancedProductDocumentation)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"saveArchitectureInsights\",\n      \"desc\": \"Saves architecture analysis insights to a markdown file\",\n      \"inputs\": \"insights (LLMInsights)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"saveSummary\",\n      \"desc\": \"Saves project analysis summary to a markdown file\",\n      \"inputs\": \"summary (object with title, description, keyFeatures, etc.)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"finalizeProductDocsRun\",\n      \"desc\": \"Completes the product documentation run and cleans up\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"finalizeArchitectureInsightsRun\",\n      \"desc\": \"Completes the architecture insights run and cleans up\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getCurrentProductDocsRunDir\",\n      \"desc\": \"Retrieves the current product documentation storage directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"runDir path (string or null)\"\n    },\n    {\n      \"name\": \"getCurrentArchitectureInsightsRunDir\",\n      \"desc\": \"Retrieves the current architecture insights storage directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"runDir path (string or null)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"../../fileDocumentation (EnhancedProductDocumentation)\",\n    \"../../llmService (LLMInsights)\",\n    \"../../domain/formatters/documentationFormatter (DocumentationFormatter)\",\n    \"../../storage/incrementalStorage (createTimestampedStorage)\"\n  ],\n  \"intent\": \"This file exists to separate data persistence concerns from analysis logic, providing a clean interface for saving analysis results to disk while maintaining organized, timestamped storage that preserves historical analysis runs and makes results easily accessible for review.\"\n}\n```"
    },
    {
      "file": "src/infrastructure/progressService.ts",
      "role": "Core Logic",
      "purpose": "Provides a standardized service for displaying progress notifications to users during long-running operations.",
      "userVisibleActions": [
        "Shows progress notifications with title and optional message updates",
        "Displays cancellable progress indicators that users can dismiss",
        "Shows progress in different locations (notification, window status bar, etc.)"
      ],
      "developerVisibleActions": [
        "Developer wraps async operations with progress reporting using withProgress method",
        "Developer passes a title and optional configuration (cancellable, location)",
        "Developer receives a reporter object to update progress messages during execution",
        "Developer can check cancellation status via the cancellation token",
        "Developer receives the result of the wrapped async operation"
      ],
      "keyFunctions": [
        {
          "name": "withProgress",
          "desc": "Wraps an async task with progress reporting UI",
          "inputs": "options (title, cancellable flag, location) and an async task function that receives a ProgressReporter",
          "outputs": "Returns the result of the executed task"
        },
        {
          "name": "ProgressReporter.report",
          "desc": "Updates the progress message and optionally increments progress percentage",
          "inputs": "message string and optional increment number",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode"
      ],
      "intent": "This file exists to reduce boilerplate code and ensure consistent progress reporting across the extension by wrapping VSCode's native withProgress API in a simpler, standardized interface that developers can reuse throughout the codebase.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a standardized service for displaying progress notifications to users during long-running operations.\",\n  \"userVisibleActions\": [\n    \"Shows progress notifications with title and optional message updates\",\n    \"Displays cancellable progress indicators that users can dismiss\",\n    \"Shows progress in different locations (notification, window status bar, etc.)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer wraps async operations with progress reporting using withProgress method\",\n    \"Developer passes a title and optional configuration (cancellable, location)\",\n    \"Developer receives a reporter object to update progress messages during execution\",\n    \"Developer can check cancellation status via the cancellation token\",\n    \"Developer receives the result of the wrapped async operation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"withProgress\",\n      \"desc\": \"Wraps an async task with progress reporting UI\",\n      \"inputs\": \"options (title, cancellable flag, location) and an async task function that receives a ProgressReporter\",\n      \"outputs\": \"Returns the result of the executed task\"\n    },\n    {\n      \"name\": \"ProgressReporter.report\",\n      \"desc\": \"Updates the progress message and optionally increments progress percentage\",\n      \"inputs\": \"message string and optional increment number\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to reduce boilerplate code and ensure consistent progress reporting across the extension by wrapping VSCode's native withProgress API in a simpler, standardized interface that developers can reuse throughout the codebase.\"\n}\n```"
    },
    {
      "file": "src/insightGenerator.ts",
      "role": "Core Logic",
      "purpose": "Analyzes code structure and generates actionable insights about code quality, organization, and potential issues.",
      "userVisibleActions": [
        "Receives warnings about large files exceeding 500 lines of code",
        "Gets notified about orphaned files that aren't imported by other files",
        "Sees alerts for missing entry points in the codebase",
        "Receives warnings about potential circular dependencies between files",
        "Gets notified about 'god objects' (files with too many exports or responsibilities)",
        "Sees warnings about potential dead code that may not be used",
        "Receives suggestions about file organization issues",
        "Gets alerts about functions with high complexity",
        "Views severity levels (error, warning, info) for each insight",
        "Sees suggested fixes for each identified issue",
        "Views code snippets related to specific issues",
        "Gets file path and line number references for each problem"
      ],
      "developerVisibleActions": [
        "Calls generateInsights() with CodeAnalysis object to get all insights for entire codebase",
        "Calls generateInsightsForFile() with specific file path to get insights for single file",
        "Receives array of Insight objects with structured information (id, title, description, severity, category, suggestion)",
        "Uses severity levels to prioritize which insights to address first",
        "Follows suggestions to refactor or reorganize code",
        "Filters insights by category to focus on specific types of issues",
        "Uses file and line number information to navigate directly to problem areas"
      ],
      "keyFunctions": [
        {
          "name": "generateInsights",
          "desc": "Analyzes entire codebase and generates comprehensive list of code quality insights",
          "inputs": "CodeAnalysis object containing files, functions, and dependency information",
          "outputs": "Array of Insight objects with identified issues, warnings, and suggestions"
        },
        {
          "name": "generateInsightsForFile",
          "desc": "Generates insights specific to a single file in the codebase",
          "inputs": "CodeAnalysis object and specific file path string",
          "outputs": "Array of Insight objects relevant only to that file"
        },
        {
          "name": "checkLargeFiles",
          "desc": "Identifies files exceeding recommended line count threshold",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about oversized files"
        },
        {
          "name": "checkOrphanedFiles",
          "desc": "Finds files that aren't imported or used by other files",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about isolated files"
        },
        {
          "name": "checkEntryPoints",
          "desc": "Verifies presence of main entry points in codebase",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about missing entry points"
        },
        {
          "name": "checkCircularDependencies",
          "desc": "Detects potential circular import patterns between files",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about circular dependencies"
        },
        {
          "name": "checkGodObjects",
          "desc": "Identifies files with too many exports or responsibilities",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about files violating single responsibility principle"
        },
        {
          "name": "checkDeadCode",
          "desc": "Finds code that may not be used anywhere in the project",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about potentially unused code"
        },
        {
          "name": "checkFileOrganization",
          "desc": "Evaluates how files are structured and organized in the project",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about organizational improvements"
        },
        {
          "name": "checkFunctionComplexity",
          "desc": "Analyzes functions for excessive complexity or size",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about overly complex functions"
        }
      ],
      "dependencies": [
        "./analyzer"
      ],
      "intent": "This file exists to transform raw code analysis data into actionable, human-readable insights that help developers improve code quality, maintainability, and organization. It solves the problem of making sense of complex codebase metrics by categorizing issues, prioritizing them by severity, and providing specific suggestions for improvement.",
      "rawContent": "```json\n{\n  \"purpose\": \"Analyzes code structure and generates actionable insights about code quality, organization, and potential issues.\",\n  \"userVisibleActions\": [\n    \"Receives warnings about large files exceeding 500 lines of code\",\n    \"Gets notified about orphaned files that aren't imported by other files\",\n    \"Sees alerts for missing entry points in the codebase\",\n    \"Receives warnings about potential circular dependencies between files\",\n    \"Gets notified about 'god objects' (files with too many exports or responsibilities)\",\n    \"Sees warnings about potential dead code that may not be used\",\n    \"Receives suggestions about file organization issues\",\n    \"Gets alerts about functions with high complexity\",\n    \"Views severity levels (error, warning, info) for each insight\",\n    \"Sees suggested fixes for each identified issue\",\n    \"Views code snippets related to specific issues\",\n    \"Gets file path and line number references for each problem\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls generateInsights() with CodeAnalysis object to get all insights for entire codebase\",\n    \"Calls generateInsightsForFile() with specific file path to get insights for single file\",\n    \"Receives array of Insight objects with structured information (id, title, description, severity, category, suggestion)\",\n    \"Uses severity levels to prioritize which insights to address first\",\n    \"Follows suggestions to refactor or reorganize code\",\n    \"Filters insights by category to focus on specific types of issues\",\n    \"Uses file and line number information to navigate directly to problem areas\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"generateInsights\",\n      \"desc\": \"Analyzes entire codebase and generates comprehensive list of code quality insights\",\n      \"inputs\": \"CodeAnalysis object containing files, functions, and dependency information\",\n      \"outputs\": \"Array of Insight objects with identified issues, warnings, and suggestions\"\n    },\n    {\n      \"name\": \"generateInsightsForFile\",\n      \"desc\": \"Generates insights specific to a single file in the codebase\",\n      \"inputs\": \"CodeAnalysis object and specific file path string\",\n      \"outputs\": \"Array of Insight objects relevant only to that file\"\n    },\n    {\n      \"name\": \"checkLargeFiles\",\n      \"desc\": \"Identifies files exceeding recommended line count threshold\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about oversized files\"\n    },\n    {\n      \"name\": \"checkOrphanedFiles\",\n      \"desc\": \"Finds files that aren't imported or used by other files\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about isolated files\"\n    },\n    {\n      \"name\": \"checkEntryPoints\",\n      \"desc\": \"Verifies presence of main entry points in codebase\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about missing entry points\"\n    },\n    {\n      \"name\": \"checkCircularDependencies\",\n      \"desc\": \"Detects potential circular import patterns between files\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about circular dependencies\"\n    },\n    {\n      \"name\": \"checkGodObjects\",\n      \"desc\": \"Identifies files with too many exports or responsibilities\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about files violating single responsibility principle\"\n    },\n    {\n      \"name\": \"checkDeadCode\",\n      \"desc\": \"Finds code that may not be used anywhere in the project\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about potentially unused code\"\n    },\n    {\n      \"name\": \"checkFileOrganization\",\n      \"desc\": \"Evaluates how files are structured and organized in the project\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about organizational improvements\"\n    },\n    {\n      \"name\": \"checkFunctionComplexity\",\n      \"desc\": \"Analyzes functions for excessive complexity or size\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about overly complex functions\"\n    }\n  ],\n  \"dependencies\": [\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to transform raw code analysis data into actionable, human-readable insights that help developers improve code quality, maintainability, and organization. It solves the problem of making sense of complex codebase metrics by categorizing issues, prioritizing them by severity, and providing specific suggestions for improvement.\"\n}\n```"
    },
    {
      "file": "src/insightsTreeView.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view UI in VSCode that displays code analysis insights, documentation status, and generated reports with actions to regenerate or view content.",
      "userVisibleActions": [
        "View a tree hierarchy showing product documentation, insights, unit tests, and analysis reports",
        "See status indicators (idle, generating, complete) for different analysis types",
        "Click to regenerate product documentation for the codebase",
        "Click to regenerate insights about the code",
        "Click to regenerate unit tests",
        "Click to regenerate various types of reports (workspace, product, architecture, unit test)",
        "View timestamps showing when each analysis was last generated",
        "Open generated reports in the editor by clicking on them",
        "Copy insights text to clipboard",
        "See progress indicators while content is being generated",
        "Receive notifications when generation completes or fails",
        "Configure LLM settings through the tree view",
        "Search within insights using a search command"
      ],
      "developerVisibleActions": [
        "Maintains state of all analysis artifacts (documentation, insights, reports)",
        "Persists timestamps and file paths across VSCode sessions",
        "Coordinates with LLMService to generate AI-powered content",
        "Triggers tree view refresh when data changes",
        "Handles user clicks on tree items to execute appropriate commands",
        "Validates existence of generated files before displaying them",
        "Provides context menu actions for regenerating content",
        "Integrates with workspace state to remember generation history",
        "Emits events when tree data changes to update the UI",
        "Manages multiple report types (workspace, product, architecture, unit test)",
        "Handles asynchronous generation workflows with status tracking"
      ],
      "keyFunctions": [
        {
          "name": "getTreeItem",
          "desc": "Converts a TreeItem into a vscode.TreeItem for display in the tree view",
          "inputs": "element: TreeItem",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child nodes for the tree structure, creating the hierarchy of insights, docs, and reports",
          "inputs": "element?: TreeItem",
          "outputs": "TreeItem[] or Promise<TreeItem[]>"
        },
        {
          "name": "setInsights",
          "desc": "Updates the insights data and refreshes the tree view",
          "inputs": "insights: Insight[]",
          "outputs": "void"
        },
        {
          "name": "setProductDocsStatus",
          "desc": "Updates the status of product documentation generation and refreshes the view",
          "inputs": "status: 'idle' | 'generating' | 'complete', timestamp?: number",
          "outputs": "void"
        },
        {
          "name": "setLLMInsights",
          "desc": "Stores LLM-generated insights and updates the view",
          "inputs": "insights: LLMInsights",
          "outputs": "void"
        },
        {
          "name": "setReportPath",
          "desc": "Sets the path to a generated report file and updates the view",
          "inputs": "path: string, timestamp: number",
          "outputs": "void"
        },
        {
          "name": "refresh",
          "desc": "Triggers a refresh of the entire tree view UI",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "loadPersistedState",
          "desc": "Loads previously saved timestamps and file paths from workspace storage",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "cleanupMissingFiles",
          "desc": "Verifies that stored file paths still exist and clears invalid entries",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "getUnitTestStatus",
          "desc": "Returns the current status of unit test generation",
          "inputs": "none",
          "outputs": "'idle' | 'generating' | 'complete'"
        }
      ],
      "dependencies": [
        "vscode",
        "./insightGenerator",
        "./llmFormatter",
        "./llmService"
      ],
      "intent": "This file exists to create an interactive sidebar panel in VSCode where users can view, manage, and regenerate AI-generated code analysis artifacts including documentation, insights, unit tests, and various reports, while maintaining state persistence across sessions.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view UI in VSCode that displays code analysis insights, documentation status, and generated reports with actions to regenerate or view content.\",\n  \"userVisibleActions\": [\n    \"View a tree hierarchy showing product documentation, insights, unit tests, and analysis reports\",\n    \"See status indicators (idle, generating, complete) for different analysis types\",\n    \"Click to regenerate product documentation for the codebase\",\n    \"Click to regenerate insights about the code\",\n    \"Click to regenerate unit tests\",\n    \"Click to regenerate various types of reports (workspace, product, architecture, unit test)\",\n    \"View timestamps showing when each analysis was last generated\",\n    \"Open generated reports in the editor by clicking on them\",\n    \"Copy insights text to clipboard\",\n    \"See progress indicators while content is being generated\",\n    \"Receive notifications when generation completes or fails\",\n    \"Configure LLM settings through the tree view\",\n    \"Search within insights using a search command\"\n  ],\n  \"developerVisibleActions\": [\n    \"Maintains state of all analysis artifacts (documentation, insights, reports)\",\n    \"Persists timestamps and file paths across VSCode sessions\",\n    \"Coordinates with LLMService to generate AI-powered content\",\n    \"Triggers tree view refresh when data changes\",\n    \"Handles user clicks on tree items to execute appropriate commands\",\n    \"Validates existence of generated files before displaying them\",\n    \"Provides context menu actions for regenerating content\",\n    \"Integrates with workspace state to remember generation history\",\n    \"Emits events when tree data changes to update the UI\",\n    \"Manages multiple report types (workspace, product, architecture, unit test)\",\n    \"Handles asynchronous generation workflows with status tracking\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts a TreeItem into a vscode.TreeItem for display in the tree view\",\n      \"inputs\": \"element: TreeItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child nodes for the tree structure, creating the hierarchy of insights, docs, and reports\",\n      \"inputs\": \"element?: TreeItem\",\n      \"outputs\": \"TreeItem[] or Promise<TreeItem[]>\"\n    },\n    {\n      \"name\": \"setInsights\",\n      \"desc\": \"Updates the insights data and refreshes the tree view\",\n      \"inputs\": \"insights: Insight[]\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setProductDocsStatus\",\n      \"desc\": \"Updates the status of product documentation generation and refreshes the view\",\n      \"inputs\": \"status: 'idle' | 'generating' | 'complete', timestamp?: number\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setLLMInsights\",\n      \"desc\": \"Stores LLM-generated insights and updates the view\",\n      \"inputs\": \"insights: LLMInsights\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setReportPath\",\n      \"desc\": \"Sets the path to a generated report file and updates the view\",\n      \"inputs\": \"path: string, timestamp: number\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Triggers a refresh of the entire tree view UI\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"loadPersistedState\",\n      \"desc\": \"Loads previously saved timestamps and file paths from workspace storage\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"cleanupMissingFiles\",\n      \"desc\": \"Verifies that stored file paths still exist and clears invalid entries\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"getUnitTestStatus\",\n      \"desc\": \"Returns the current status of unit test generation\",\n      \"inputs\": \"none\",\n      \"outputs\": \"'idle' | 'generating' | 'complete'\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./llmService\"\n  ],\n  \"intent\": \"This file exists to create an interactive sidebar panel in VSCode where users can view, manage, and regenerate AI-generated code analysis artifacts including documentation, insights, unit tests, and various reports, while maintaining state persistence across sessions.\"\n}\n```"
    },
    {
      "file": "src/insightsViewer.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, automatically updating when insight files change.",
      "userVisibleActions": [
        "View architecture insights in a tree structure in the sidebar",
        "Browse different categories of insights (Components, Data Flow, Architecture Patterns, etc.)",
        "Click on insight items to see detailed descriptions",
        "Open related source code files by clicking on file references",
        "See real-time updates when AI generates new insights",
        "Refresh the insights view manually",
        "Navigate to specific code locations from insight items",
        "View purpose statements for individual files",
        "See grouped insights by category and type"
      ],
      "developerVisibleActions": [
        "Tree view automatically refreshes when .shadow/docs/ai-architecture-insights.json file changes",
        "Tree view updates when .shadow/docs/purpose.json file changes",
        "Clicking on file paths opens the corresponding source file in the editor",
        "Tree provides hierarchical navigation of AI-generated insights",
        "Insights are loaded from JSON files in the .shadow/docs directory",
        "File watchers monitor for changes and trigger automatic updates",
        "Purpose statements are displayed as additional insight items"
      ],
      "keyFunctions": [
        {
          "name": "refresh",
          "desc": "Reloads insights from disk and updates the tree view display",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getTreeItem",
          "desc": "Converts an insight item into a VS Code tree item for display",
          "inputs": "InsightItem",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child items for the tree hierarchy (categories, subcategories, and individual insights)",
          "inputs": "optional parent InsightItem",
          "outputs": "Promise<InsightItem[]>"
        },
        {
          "name": "loadInsights",
          "desc": "Reads AI insights from the JSON file in .shadow/docs directory",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "loadPurposeStatements",
          "desc": "Reads file purpose statements from purpose.json file",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "setupFileWatcher",
          "desc": "Creates file system watchers to detect changes in insight files",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "openFile",
          "desc": "Opens a source code file in the editor at a specific location",
          "inputs": "file path and optional line number",
          "outputs": "Promise<void>"
        }
      ],
      "dependencies": [
        "vscode",
        "llmService",
        "path",
        "fs",
        "fileWatcherService"
      ],
      "intent": "This file exists to provide developers with an interactive, always-updated view of AI-generated architecture insights about their codebase. It solves the problem of making AI analysis results easily accessible and navigable within the VS Code interface, with automatic updates as the AI discovers new patterns or the code changes. It bridges the gap between AI analysis (stored in JSON files) and developer interaction (tree view UI).",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, automatically updating when insight files change.\",\n  \"userVisibleActions\": [\n    \"View architecture insights in a tree structure in the sidebar\",\n    \"Browse different categories of insights (Components, Data Flow, Architecture Patterns, etc.)\",\n    \"Click on insight items to see detailed descriptions\",\n    \"Open related source code files by clicking on file references\",\n    \"See real-time updates when AI generates new insights\",\n    \"Refresh the insights view manually\",\n    \"Navigate to specific code locations from insight items\",\n    \"View purpose statements for individual files\",\n    \"See grouped insights by category and type\"\n  ],\n  \"developerVisibleActions\": [\n    \"Tree view automatically refreshes when .shadow/docs/ai-architecture-insights.json file changes\",\n    \"Tree view updates when .shadow/docs/purpose.json file changes\",\n    \"Clicking on file paths opens the corresponding source file in the editor\",\n    \"Tree provides hierarchical navigation of AI-generated insights\",\n    \"Insights are loaded from JSON files in the .shadow/docs directory\",\n    \"File watchers monitor for changes and trigger automatic updates\",\n    \"Purpose statements are displayed as additional insight items\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Reloads insights from disk and updates the tree view display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts an insight item into a VS Code tree item for display\",\n      \"inputs\": \"InsightItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for the tree hierarchy (categories, subcategories, and individual insights)\",\n      \"inputs\": \"optional parent InsightItem\",\n      \"outputs\": \"Promise<InsightItem[]>\"\n    },\n    {\n      \"name\": \"loadInsights\",\n      \"desc\": \"Reads AI insights from the JSON file in .shadow/docs directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"loadPurposeStatements\",\n      \"desc\": \"Reads file purpose statements from purpose.json file\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setupFileWatcher\",\n      \"desc\": \"Creates file system watchers to detect changes in insight files\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"openFile\",\n      \"desc\": \"Opens a source code file in the editor at a specific location\",\n      \"inputs\": \"file path and optional line number\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"llmService\",\n    \"path\",\n    \"fs\",\n    \"fileWatcherService\"\n  ],\n  \"intent\": \"This file exists to provide developers with an interactive, always-updated view of AI-generated architecture insights about their codebase. It solves the problem of making AI analysis results easily accessible and navigable within the VS Code interface, with automatic updates as the AI discovers new patterns or the code changes. It bridges the gap between AI analysis (stored in JSON files) and developer interaction (tree view UI).\"\n}\n```"
    },
    {
      "file": "src/llmFormatter.ts",
      "role": "Core Logic",
      "purpose": "Formats code architecture insights into different LLM-friendly output formats for use with various AI assistants",
      "userVisibleActions": [
        "Receives formatted architecture issues grouped by severity (errors, warnings, info)",
        "Gets structured prompts asking for help prioritizing and addressing issues",
        "Sees architecture insights in different styles optimized for Cursor, ChatGPT, or generic LLMs",
        "Views compact summaries showing issue counts by type and severity"
      ],
      "developerVisibleActions": [
        "Calls formatInsights() with insights array and format type to get formatted output",
        "Chooses between 'cursor', 'chatgpt', 'compact', or 'generic' format styles",
        "Receives markdown-formatted text ready to paste into AI assistants",
        "Gets insights automatically grouped and sorted by severity level",
        "Receives actionable prompts requesting specific refactoring guidance from LLMs"
      ],
      "keyFunctions": [
        {
          "name": "formatInsights",
          "desc": "Main entry point that routes to appropriate formatter based on specified format",
          "inputs": "insights array and format string ('cursor', 'chatgpt', 'compact', 'generic')",
          "outputs": "Formatted markdown string ready for LLM consumption"
        },
        {
          "name": "formatForCursor",
          "desc": "Formats insights specifically for Cursor AI with severity groups and actionable prompts",
          "inputs": "Array of Insight objects",
          "outputs": "Markdown text with emoji-decorated sections and specific requests for help"
        },
        {
          "name": "formatForChatGPT",
          "desc": "Formats insights for ChatGPT with conversational tone and context",
          "inputs": "Array of Insight objects",
          "outputs": "Markdown text optimized for ChatGPT's interaction style"
        },
        {
          "name": "formatCompact",
          "desc": "Creates brief summary format showing counts and key statistics",
          "inputs": "Array of Insight objects",
          "outputs": "Condensed markdown summary of issues"
        },
        {
          "name": "formatGeneric",
          "desc": "Produces neutral format suitable for any LLM without specific optimizations",
          "inputs": "Array of Insight objects",
          "outputs": "Standard markdown listing of insights"
        }
      ],
      "dependencies": [
        "./insightGenerator"
      ],
      "intent": "Bridges the gap between raw code analysis insights and AI assistant prompts by transforming technical findings into well-structured, actionable requests that guide LLMs to provide specific refactoring advice and architectural guidance",
      "rawContent": "```json\n{\n  \"purpose\": \"Formats code architecture insights into different LLM-friendly output formats for use with various AI assistants\",\n  \"userVisibleActions\": [\n    \"Receives formatted architecture issues grouped by severity (errors, warnings, info)\",\n    \"Gets structured prompts asking for help prioritizing and addressing issues\",\n    \"Sees architecture insights in different styles optimized for Cursor, ChatGPT, or generic LLMs\",\n    \"Views compact summaries showing issue counts by type and severity\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls formatInsights() with insights array and format type to get formatted output\",\n    \"Chooses between 'cursor', 'chatgpt', 'compact', or 'generic' format styles\",\n    \"Receives markdown-formatted text ready to paste into AI assistants\",\n    \"Gets insights automatically grouped and sorted by severity level\",\n    \"Receives actionable prompts requesting specific refactoring guidance from LLMs\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"formatInsights\",\n      \"desc\": \"Main entry point that routes to appropriate formatter based on specified format\",\n      \"inputs\": \"insights array and format string ('cursor', 'chatgpt', 'compact', 'generic')\",\n      \"outputs\": \"Formatted markdown string ready for LLM consumption\"\n    },\n    {\n      \"name\": \"formatForCursor\",\n      \"desc\": \"Formats insights specifically for Cursor AI with severity groups and actionable prompts\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Markdown text with emoji-decorated sections and specific requests for help\"\n    },\n    {\n      \"name\": \"formatForChatGPT\",\n      \"desc\": \"Formats insights for ChatGPT with conversational tone and context\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Markdown text optimized for ChatGPT's interaction style\"\n    },\n    {\n      \"name\": \"formatCompact\",\n      \"desc\": \"Creates brief summary format showing counts and key statistics\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Condensed markdown summary of issues\"\n    },\n    {\n      \"name\": \"formatGeneric\",\n      \"desc\": \"Produces neutral format suitable for any LLM without specific optimizations\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Standard markdown listing of insights\"\n    }\n  ],\n  \"dependencies\": [\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"Bridges the gap between raw code analysis insights and AI assistant prompts by transforming technical findings into well-structured, actionable requests that guide LLMs to provide specific refactoring advice and architectural guidance\"\n}\n```"
    },
    {
      "file": "src/llmIntegration.ts",
      "role": "Core Logic",
      "purpose": "Manages LLM-powered code analysis features including insights generation, documentation, and navigation tree views in VS Code.",
      "userVisibleActions": [
        "View AI-generated code insights in a tree view panel",
        "See analysis results for entry points, unit tests, and product documentation",
        "Get real-time updates when API key configuration changes",
        "View formatted documentation in an output channel",
        "Navigate through analyzed code structure via tree providers",
        "Access saved analysis results that persist across sessions",
        "Receive notifications about analysis progress and completion",
        "See error messages when LLM operations fail"
      ],
      "developerVisibleActions": [
        "Initialize LLM service with API configuration",
        "Trigger code analysis on workspace files",
        "Generate insights from code analysis results",
        "Save and load analysis contexts for reuse",
        "Refresh tree views when analysis updates",
        "Execute shell commands for analysis operations",
        "Access state management for LLM operations",
        "Convert code analysis to LLM context format",
        "Persist analysis results to storage",
        "Format documentation for display"
      ],
      "keyFunctions": [
        {
          "name": "initializeLLMService",
          "desc": "Sets up the LLM service, output channels, and tree view refresh handlers",
          "inputs": "none",
          "outputs": "void - initializes global state"
        },
        {
          "name": "convertCodeAnalysisToContext",
          "desc": "Transforms code analysis data into format suitable for LLM processing",
          "inputs": "CodeAnalysis object",
          "outputs": "AnalysisContext object"
        },
        {
          "name": "saveCodeAnalysis",
          "desc": "Persists code analysis results to storage",
          "inputs": "CodeAnalysis data",
          "outputs": "Promise indicating save completion"
        },
        {
          "name": "loadSavedCodeAnalysisFromFile",
          "desc": "Retrieves previously saved code analysis from storage",
          "inputs": "file path or identifier",
          "outputs": "Promise<CodeAnalysis>"
        }
      ],
      "dependencies": [
        "vscode",
        "fs",
        "path",
        "child_process",
        "util",
        "./llmService",
        "./insightsTreeView",
        "./fileDocumentation",
        "./analyzer",
        "./productNavigator",
        "./analysisViewer",
        "./insightsViewer",
        "./unitTestsNavigator",
        "./logger",
        "./state/llmStateManager",
        "./context/analysisContextBuilder",
        "./domain/formatters/documentationFormatter",
        "./infrastructure/persistence/analysisResultRepository"
      ],
      "intent": "This file exists to orchestrate LLM-powered code understanding features in VS Code. It solves the problem of making large codebases understandable by connecting AI analysis with VS Code's UI components (tree views, output channels, navigation). It manages the lifecycle of analysis operations, state persistence, and user-facing visualization of AI-generated insights.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages LLM-powered code analysis features including insights generation, documentation, and navigation tree views in VS Code.\",\n  \"userVisibleActions\": [\n    \"View AI-generated code insights in a tree view panel\",\n    \"See analysis results for entry points, unit tests, and product documentation\",\n    \"Get real-time updates when API key configuration changes\",\n    \"View formatted documentation in an output channel\",\n    \"Navigate through analyzed code structure via tree providers\",\n    \"Access saved analysis results that persist across sessions\",\n    \"Receive notifications about analysis progress and completion\",\n    \"See error messages when LLM operations fail\"\n  ],\n  \"developerVisibleActions\": [\n    \"Initialize LLM service with API configuration\",\n    \"Trigger code analysis on workspace files\",\n    \"Generate insights from code analysis results\",\n    \"Save and load analysis contexts for reuse\",\n    \"Refresh tree views when analysis updates\",\n    \"Execute shell commands for analysis operations\",\n    \"Access state management for LLM operations\",\n    \"Convert code analysis to LLM context format\",\n    \"Persist analysis results to storage\",\n    \"Format documentation for display\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initializeLLMService\",\n      \"desc\": \"Sets up the LLM service, output channels, and tree view refresh handlers\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void - initializes global state\"\n    },\n    {\n      \"name\": \"convertCodeAnalysisToContext\",\n      \"desc\": \"Transforms code analysis data into format suitable for LLM processing\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"AnalysisContext object\"\n    },\n    {\n      \"name\": \"saveCodeAnalysis\",\n      \"desc\": \"Persists code analysis results to storage\",\n      \"inputs\": \"CodeAnalysis data\",\n      \"outputs\": \"Promise indicating save completion\"\n    },\n    {\n      \"name\": \"loadSavedCodeAnalysisFromFile\",\n      \"desc\": \"Retrieves previously saved code analysis from storage\",\n      \"inputs\": \"file path or identifier\",\n      \"outputs\": \"Promise<CodeAnalysis>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"child_process\",\n    \"util\",\n    \"./llmService\",\n    \"./insightsTreeView\",\n    \"./fileDocumentation\",\n    \"./analyzer\",\n    \"./productNavigator\",\n    \"./analysisViewer\",\n    \"./insightsViewer\",\n    \"./unitTestsNavigator\",\n    \"./logger\",\n    \"./state/llmStateManager\",\n    \"./context/analysisContextBuilder\",\n    \"./domain/formatters/documentationFormatter\",\n    \"./infrastructure/persistence/analysisResultRepository\"\n  ],\n  \"intent\": \"This file exists to orchestrate LLM-powered code understanding features in VS Code. It solves the problem of making large codebases understandable by connecting AI analysis with VS Code's UI components (tree views, output channels, navigation). It manages the lifecycle of analysis operations, state persistence, and user-facing visualization of AI-generated insights.\"\n}\n```"
    },
    {
      "file": "src/llmSchemas.ts",
      "role": "Core Logic",
      "purpose": "Defines JSON schemas for Claude AI to generate structured, type-safe responses for code analysis tasks",
      "userVisibleActions": [
        "Product purpose analysis results appear in structured format",
        "Code issues are categorized and prioritized automatically",
        "Architectural explanations follow consistent structure",
        "Code behavior summaries use standardized format",
        "File relationships are visualized with clear connections"
      ],
      "developerVisibleActions": [
        "Import schema definitions to ensure Claude returns parseable JSON responses",
        "Use productPurposeAnalysisSchema to get structured product insights",
        "Use issueItemSchema to receive categorized code issues with severity levels",
        "Use fileBehaviorSchema to extract user-facing and developer-facing actions from code",
        "Use relationshipSchema to understand file dependencies and connections",
        "Schemas guarantee valid JSON output without manual parsing or error handling",
        "All schemas include required fields validation and type enforcement"
      ],
      "keyFunctions": [],
      "dependencies": [],
      "intent": "Ensures Claude AI returns consistent, structured responses that can be programmatically processed without parsing errors. Eliminates the need for manual JSON extraction, regex parsing, or error handling when analyzing code. Each schema defines the exact shape of data needed for different analysis types (product purpose, code issues, file behavior, relationships).",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines JSON schemas for Claude AI to generate structured, type-safe responses for code analysis tasks\",\n  \"userVisibleActions\": [\n    \"Product purpose analysis results appear in structured format\",\n    \"Code issues are categorized and prioritized automatically\",\n    \"Architectural explanations follow consistent structure\",\n    \"Code behavior summaries use standardized format\",\n    \"File relationships are visualized with clear connections\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import schema definitions to ensure Claude returns parseable JSON responses\",\n    \"Use productPurposeAnalysisSchema to get structured product insights\",\n    \"Use issueItemSchema to receive categorized code issues with severity levels\",\n    \"Use fileBehaviorSchema to extract user-facing and developer-facing actions from code\",\n    \"Use relationshipSchema to understand file dependencies and connections\",\n    \"Schemas guarantee valid JSON output without manual parsing or error handling\",\n    \"All schemas include required fields validation and type enforcement\"\n  ],\n  \"keyFunctions\": [],\n  \"dependencies\": [],\n  \"intent\": \"Ensures Claude AI returns consistent, structured responses that can be programmatically processed without parsing errors. Eliminates the need for manual JSON extraction, regex parsing, or error handling when analyzing code. Each schema defines the exact shape of data needed for different analysis types (product purpose, code issues, file behavior, relationships).\"\n}\n```"
    },
    {
      "file": "src/llmService.ts",
      "role": "Core Logic",
      "purpose": "Orchestrates AI-powered code analysis by connecting to LLM providers (OpenAI/Claude) to generate intelligent insights, documentation, and test plans from codebase analysis.",
      "userVisibleActions": [
        "Receives AI-generated explanations of what the codebase does and why it exists",
        "Gets intelligent insights about code architecture, patterns, and technical decisions",
        "Views automatically generated product documentation describing the software's purpose",
        "Sees AI-created unit test plans for code coverage",
        "Receives refactoring suggestions with code improvements",
        "Gets analysis of product purpose and architecture rationale"
      ],
      "developerVisibleActions": [
        "Calls analyzeProductPurpose() to get AI analysis of what the product does and its architecture decisions",
        "Invokes generateLLMInsights() to receive intelligent observations about code quality, patterns, and concerns",
        "Uses generateProductDocumentation() to create comprehensive product documentation from file summaries",
        "Triggers generateUnitTestPlan() to get AI-generated test strategies for specific files",
        "Calls generateRefactoringSuggestions() to receive code improvement recommendations",
        "Configures LLM provider settings (OpenAI, Claude, Ollama, OpenRouter) through configuration manager",
        "Handles rate limiting, retries, and error recovery automatically during LLM interactions",
        "Receives structured JSON responses parsed from LLM outputs",
        "Triggers incremental analysis to update insights as code changes"
      ],
      "keyFunctions": [
        {
          "name": "analyzeProductPurpose",
          "desc": "Analyzes the entire codebase to determine what the product does, its architecture rationale, user problems it solves, and technical approach",
          "inputs": "analysisContext (file metadata, imports, entry points)",
          "outputs": "ProductPurposeAnalysis with purpose, rationale, user problems, and technical approach"
        },
        {
          "name": "generateLLMInsights",
          "desc": "Generates intelligent insights about code patterns, architecture decisions, potential issues, and recommendations",
          "inputs": "analysisContext, optional productPurpose",
          "outputs": "Array of categorized insights (architecture, patterns, performance, maintenance, concerns)"
        },
        {
          "name": "generateProductDocumentation",
          "desc": "Creates comprehensive product documentation by analyzing file summaries and module organization",
          "inputs": "fileSummaries array, moduleSummaries array",
          "outputs": "EnhancedProductDocumentation with overview, features, architecture, and module details"
        },
        {
          "name": "generateUnitTestPlan",
          "desc": "Creates a detailed test plan for a specific file including test cases, edge cases, and mocking strategies",
          "inputs": "filePath, fileContent, codeAnalysis",
          "outputs": "UnitTestPlan with test cases, coverage areas, dependencies, and recommendations"
        },
        {
          "name": "generateRefactoringSuggestions",
          "desc": "Analyzes functions and provides AI-powered refactoring recommendations with code examples",
          "inputs": "filePath, fileContent, functions metadata, optional context",
          "outputs": "Array of refactoring suggestions with priority, rationale, and code snippets"
        },
        {
          "name": "callLLM",
          "desc": "Central method that sends requests to configured LLM provider with rate limiting and retry logic",
          "inputs": "prompt, systemMessage, schema, optional config",
          "outputs": "Parsed JSON response from LLM"
        },
        {
          "name": "getProviderInstance",
          "desc": "Creates and configures the appropriate LLM provider based on user settings",
          "inputs": "none (reads from configuration)",
          "outputs": "Configured LLMProvider instance (OpenAI, Claude, Ollama, or OpenRouter)"
        }
      ],
      "dependencies": [
        "vscode",
        "./fileDocumentation",
        "./analyzer",
        "./analysis/enhancedAnalyzer",
        "./llmSchemas",
        "./fileAccessHelper",
        "./logger",
        "./config/configurationManager",
        "./ai/providers/providerFactory",
        "./ai/llmResponseParser",
        "./ai/llmRateLimiter",
        "./ai/llmRetryHandler",
        "./domain/prompts/promptBuilder",
        "./domain/services/incrementalAnalysisService",
        "./domain/prompts/refactoringPromptBuilder",
        "./analysis/functionAnalyzer"
      ],
      "intent": "This file exists to bridge the gap between raw code analysis and human-understandable insights by leveraging Large Language Models. It solves the problem of developers needing to manually understand complex codebases by automatically generating intelligent documentation, architectural insights, test plans, and refactoring suggestions. It abstracts away the complexity of working with multiple LLM providers and handles the orchestration of prompts, responses, rate limiting, and error handling.",
      "rawContent": "```json\n{\n  \"purpose\": \"Orchestrates AI-powered code analysis by connecting to LLM providers (OpenAI/Claude) to generate intelligent insights, documentation, and test plans from codebase analysis.\",\n  \"userVisibleActions\": [\n    \"Receives AI-generated explanations of what the codebase does and why it exists\",\n    \"Gets intelligent insights about code architecture, patterns, and technical decisions\",\n    \"Views automatically generated product documentation describing the software's purpose\",\n    \"Sees AI-created unit test plans for code coverage\",\n    \"Receives refactoring suggestions with code improvements\",\n    \"Gets analysis of product purpose and architecture rationale\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls analyzeProductPurpose() to get AI analysis of what the product does and its architecture decisions\",\n    \"Invokes generateLLMInsights() to receive intelligent observations about code quality, patterns, and concerns\",\n    \"Uses generateProductDocumentation() to create comprehensive product documentation from file summaries\",\n    \"Triggers generateUnitTestPlan() to get AI-generated test strategies for specific files\",\n    \"Calls generateRefactoringSuggestions() to receive code improvement recommendations\",\n    \"Configures LLM provider settings (OpenAI, Claude, Ollama, OpenRouter) through configuration manager\",\n    \"Handles rate limiting, retries, and error recovery automatically during LLM interactions\",\n    \"Receives structured JSON responses parsed from LLM outputs\",\n    \"Triggers incremental analysis to update insights as code changes\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeProductPurpose\",\n      \"desc\": \"Analyzes the entire codebase to determine what the product does, its architecture rationale, user problems it solves, and technical approach\",\n      \"inputs\": \"analysisContext (file metadata, imports, entry points)\",\n      \"outputs\": \"ProductPurposeAnalysis with purpose, rationale, user problems, and technical approach\"\n    },\n    {\n      \"name\": \"generateLLMInsights\",\n      \"desc\": \"Generates intelligent insights about code patterns, architecture decisions, potential issues, and recommendations\",\n      \"inputs\": \"analysisContext, optional productPurpose\",\n      \"outputs\": \"Array of categorized insights (architecture, patterns, performance, maintenance, concerns)\"\n    },\n    {\n      \"name\": \"generateProductDocumentation\",\n      \"desc\": \"Creates comprehensive product documentation by analyzing file summaries and module organization\",\n      \"inputs\": \"fileSummaries array, moduleSummaries array\",\n      \"outputs\": \"EnhancedProductDocumentation with overview, features, architecture, and module details\"\n    },\n    {\n      \"name\": \"generateUnitTestPlan\",\n      \"desc\": \"Creates a detailed test plan for a specific file including test cases, edge cases, and mocking strategies\",\n      \"inputs\": \"filePath, fileContent, codeAnalysis\",\n      \"outputs\": \"UnitTestPlan with test cases, coverage areas, dependencies, and recommendations\"\n    },\n    {\n      \"name\": \"generateRefactoringSuggestions\",\n      \"desc\": \"Analyzes functions and provides AI-powered refactoring recommendations with code examples\",\n      \"inputs\": \"filePath, fileContent, functions metadata, optional context\",\n      \"outputs\": \"Array of refactoring suggestions with priority, rationale, and code snippets\"\n    },\n    {\n      \"name\": \"callLLM\",\n      \"desc\": \"Central method that sends requests to configured LLM provider with rate limiting and retry logic\",\n      \"inputs\": \"prompt, systemMessage, schema, optional config\",\n      \"outputs\": \"Parsed JSON response from LLM\"\n    },\n    {\n      \"name\": \"getProviderInstance\",\n      \"desc\": \"Creates and configures the appropriate LLM provider based on user settings\",\n      \"inputs\": \"none (reads from configuration)\",\n      \"outputs\": \"Configured LLMProvider instance (OpenAI, Claude, Ollama, or OpenRouter)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./fileDocumentation\",\n    \"./analyzer\",\n    \"./analysis/enhancedAnalyzer\",\n    \"./llmSchemas\",\n    \"./fileAccessHelper\",\n    \"./logger\",\n    \"./config/configurationManager\",\n    \"./ai/providers/providerFactory\",\n    \"./ai/llmResponseParser\",\n    \"./ai/llmRateLimiter\",\n    \"./ai/llmRetryHandler\",\n    \"./domain/prompts/promptBuilder\",\n    \"./domain/services/incrementalAnalysisService\",\n    \"./domain/prompts/refactoringPromptBuilder\",\n    \"./analysis/functionAnalyzer\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between raw code analysis and human-understandable insights by leveraging Large Language Models. It solves the problem of developers needing to manually understand complex codebases by automatically generating intelligent documentation, architectural insights, test plans, and refactoring suggestions. It abstracts away the complexity of working with multiple LLM providers and handles the orchestration of prompts, responses, rate limiting, and error handling.\"\n}\n```"
    },
    {
      "file": "src/logger.ts",
      "role": "Core Logic",
      "purpose": "Provides a logging utility that writes timestamped messages to a log file in the workspace's .shadow/logs directory",
      "userVisibleActions": [
        "Log files are created in the .shadow/logs folder at the workspace root",
        "Log entries appear with timestamps in shadow-watch.log file",
        "Section headers with visual separators appear in log file for organizing log output"
      ],
      "developerVisibleActions": [
        "Developer calls SWLogger.log() to write timestamped messages to the log file",
        "Developer calls SWLogger.section() to create visually separated sections in logs",
        "Logging silently fails if workspace is not available or errors occur, preventing crashes",
        "Log directory .shadow/logs is automatically created if it doesn't exist"
      ],
      "keyFunctions": [
        {
          "name": "log",
          "desc": "Writes a timestamped message to the log file",
          "inputs": "message: string - the text to log",
          "outputs": "void - writes to file system"
        },
        {
          "name": "section",
          "desc": "Creates a visually separated section header in the log file",
          "inputs": "title: string - the section title",
          "outputs": "void - writes formatted section header to file"
        },
        {
          "name": "getLogPath",
          "desc": "Determines the file path for the log file in the workspace",
          "inputs": "none",
          "outputs": "string | null - path to log file or null if no workspace"
        },
        {
          "name": "ensureDir",
          "desc": "Creates a directory and parent directories if they don't exist",
          "inputs": "dir: string - directory path to create",
          "outputs": "void - creates directories on file system"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "vscode"
      ],
      "intent": "Provides centralized logging functionality for the extension to track operations and debugging information in a persistent file within the workspace, making it easier to troubleshoot issues and understand extension behavior over time",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a logging utility that writes timestamped messages to a log file in the workspace's .shadow/logs directory\",\n  \"userVisibleActions\": [\n    \"Log files are created in the .shadow/logs folder at the workspace root\",\n    \"Log entries appear with timestamps in shadow-watch.log file\",\n    \"Section headers with visual separators appear in log file for organizing log output\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer calls SWLogger.log() to write timestamped messages to the log file\",\n    \"Developer calls SWLogger.section() to create visually separated sections in logs\",\n    \"Logging silently fails if workspace is not available or errors occur, preventing crashes\",\n    \"Log directory .shadow/logs is automatically created if it doesn't exist\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"log\",\n      \"desc\": \"Writes a timestamped message to the log file\",\n      \"inputs\": \"message: string - the text to log\",\n      \"outputs\": \"void - writes to file system\"\n    },\n    {\n      \"name\": \"section\",\n      \"desc\": \"Creates a visually separated section header in the log file\",\n      \"inputs\": \"title: string - the section title\",\n      \"outputs\": \"void - writes formatted section header to file\"\n    },\n    {\n      \"name\": \"getLogPath\",\n      \"desc\": \"Determines the file path for the log file in the workspace\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string | null - path to log file or null if no workspace\"\n    },\n    {\n      \"name\": \"ensureDir\",\n      \"desc\": \"Creates a directory and parent directories if they don't exist\",\n      \"inputs\": \"dir: string - directory path to create\",\n      \"outputs\": \"void - creates directories on file system\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"vscode\"\n  ],\n  \"intent\": \"Provides centralized logging functionality for the extension to track operations and debugging information in a persistent file within the workspace, making it easier to troubleshoot issues and understand extension behavior over time\"\n}\n```"
    },
    {
      "file": "src/productNavigator.ts",
      "role": "Core Logic",
      "purpose": "Provides a product-centric navigation view that organizes code by functionality instead of file structure, allowing users to browse the codebase by features and capabilities.",
      "userVisibleActions": [
        "View codebase organized by product features and functionality instead of file structure",
        "Navigate to code files by clicking on feature categories and subcategories",
        "See real-time updates to the product navigation tree when code documentation changes",
        "Expand and collapse feature groups to explore different areas of the product",
        "Click on file items to open and view source code files",
        "See visual indicators (icons and labels) for different types of product features",
        "Browse features grouped by user-facing categories, developer tools, and architectural components"
      ],
      "developerVisibleActions": [
        "Registers a custom tree view provider that organizes code by product functionality",
        "Monitors file system for changes to product documentation and updates the navigation tree automatically",
        "Loads enhanced product documentation from .shadow/docs directory to build the navigation structure",
        "Provides tree data through VSCode's TreeDataProvider interface for rendering in the sidebar",
        "Handles file watchers for both aggregate documentation and incremental file updates",
        "Manages workspace state and product documentation lifecycle",
        "Triggers tree refresh when documentation files are created, changed, or deleted",
        "Integrates with FileWatcherService for centralized file monitoring"
      ],
      "keyFunctions": [
        {
          "name": "getTreeItem",
          "desc": "Returns the visual representation (label, icon, collapsible state) for a navigation item",
          "inputs": "ProductNavItem element",
          "outputs": "TreeItem with display properties"
        },
        {
          "name": "getChildren",
          "desc": "Returns child navigation items for a given parent, building the hierarchical product navigation structure",
          "inputs": "Optional parent ProductNavItem",
          "outputs": "Array of child ProductNavItem objects"
        },
        {
          "name": "refresh",
          "desc": "Reloads product documentation and updates the navigation tree view",
          "inputs": "None",
          "outputs": "Promise that resolves when refresh is complete"
        },
        {
          "name": "loadProductDocumentation",
          "desc": "Loads enhanced product documentation from the workspace's shadow directory",
          "inputs": "None",
          "outputs": "EnhancedProductDocumentation object or null"
        },
        {
          "name": "setupFileWatcher",
          "desc": "Configures file system watchers to detect changes to product documentation files",
          "inputs": "None",
          "outputs": "None (side effect: sets up file watchers)"
        },
        {
          "name": "openFile",
          "desc": "Opens a source code file in the editor when user clicks on a navigation item",
          "inputs": "ProductNavItem representing a file",
          "outputs": "Promise that resolves when file is opened"
        },
        {
          "name": "buildFeatureTree",
          "desc": "Constructs the hierarchical navigation tree from product documentation features",
          "inputs": "EnhancedProductDocumentation",
          "outputs": "Array of top-level ProductNavItem objects"
        }
      ],
      "dependencies": [
        "vscode",
        "fileDocumentation (EnhancedProductDocumentation, FileSummary, ModuleSummary)",
        "path",
        "fs",
        "domain/services/fileWatcherService"
      ],
      "intent": "This file exists to replace traditional file-based navigation with a product-centric approach that organizes code by what it does rather than where it lives. It solves the problem of developers and users struggling to understand a codebase's functionality when navigating through arbitrary file/folder structures. By presenting code through the lens of features and capabilities, it makes codebases more discoverable and understandable, especially for new team members or when working with unfamiliar code.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a product-centric navigation view that organizes code by functionality instead of file structure, allowing users to browse the codebase by features and capabilities.\",\n  \"userVisibleActions\": [\n    \"View codebase organized by product features and functionality instead of file structure\",\n    \"Navigate to code files by clicking on feature categories and subcategories\",\n    \"See real-time updates to the product navigation tree when code documentation changes\",\n    \"Expand and collapse feature groups to explore different areas of the product\",\n    \"Click on file items to open and view source code files\",\n    \"See visual indicators (icons and labels) for different types of product features\",\n    \"Browse features grouped by user-facing categories, developer tools, and architectural components\"\n  ],\n  \"developerVisibleActions\": [\n    \"Registers a custom tree view provider that organizes code by product functionality\",\n    \"Monitors file system for changes to product documentation and updates the navigation tree automatically\",\n    \"Loads enhanced product documentation from .shadow/docs directory to build the navigation structure\",\n    \"Provides tree data through VSCode's TreeDataProvider interface for rendering in the sidebar\",\n    \"Handles file watchers for both aggregate documentation and incremental file updates\",\n    \"Manages workspace state and product documentation lifecycle\",\n    \"Triggers tree refresh when documentation files are created, changed, or deleted\",\n    \"Integrates with FileWatcherService for centralized file monitoring\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the visual representation (label, icon, collapsible state) for a navigation item\",\n      \"inputs\": \"ProductNavItem element\",\n      \"outputs\": \"TreeItem with display properties\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child navigation items for a given parent, building the hierarchical product navigation structure\",\n      \"inputs\": \"Optional parent ProductNavItem\",\n      \"outputs\": \"Array of child ProductNavItem objects\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Reloads product documentation and updates the navigation tree view\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Promise that resolves when refresh is complete\"\n    },\n    {\n      \"name\": \"loadProductDocumentation\",\n      \"desc\": \"Loads enhanced product documentation from the workspace's shadow directory\",\n      \"inputs\": \"None\",\n      \"outputs\": \"EnhancedProductDocumentation object or null\"\n    },\n    {\n      \"name\": \"setupFileWatcher\",\n      \"desc\": \"Configures file system watchers to detect changes to product documentation files\",\n      \"inputs\": \"None\",\n      \"outputs\": \"None (side effect: sets up file watchers)\"\n    },\n    {\n      \"name\": \"openFile\",\n      \"desc\": \"Opens a source code file in the editor when user clicks on a navigation item\",\n      \"inputs\": \"ProductNavItem representing a file\",\n      \"outputs\": \"Promise that resolves when file is opened\"\n    },\n    {\n      \"name\": \"buildFeatureTree\",\n      \"desc\": \"Constructs the hierarchical navigation tree from product documentation features\",\n      \"inputs\": \"EnhancedProductDocumentation\",\n      \"outputs\": \"Array of top-level ProductNavItem objects\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fileDocumentation (EnhancedProductDocumentation, FileSummary, ModuleSummary)\",\n    \"path\",\n    \"fs\",\n    \"domain/services/fileWatcherService\"\n  ],\n  \"intent\": \"This file exists to replace traditional file-based navigation with a product-centric approach that organizes code by what it does rather than where it lives. It solves the problem of developers and users struggling to understand a codebase's functionality when navigating through arbitrary file/folder structures. By presenting code through the lens of features and capabilities, it makes codebases more discoverable and understandable, especially for new team members or when working with unfamiliar code.\"\n}\n```"
    },
    {
      "file": "src/reportsTreeProvider.ts",
      "role": "Core Logic",
      "purpose": "Provides a tree view sidebar that displays all available Shadow Watch reports with their generation status and allows users to open them.",
      "userVisibleActions": [
        "View a tree list of all Shadow Watch report types in the sidebar",
        "See which reports have been generated (green file icon) and which haven't (gray slash icon)",
        "See when each report was last generated in the tooltip",
        "Click on a generated report to open it in the editor",
        "See descriptive tooltips explaining what each report type contains",
        "View report file paths and timestamps on hover"
      ],
      "developerVisibleActions": [
        "Register report generation events to update the tree view",
        "Track five report types: workspace, product, architecture, refactoring, and unit-test",
        "Refresh the tree view automatically when reports are generated or deleted",
        "Handle report metadata including path, timestamp, and description",
        "Provide context values for available/unavailable reports to enable different menu actions",
        "Emit tree data change events to trigger UI updates"
      ],
      "keyFunctions": [
        {
          "name": "ReportTreeItem.constructor",
          "desc": "Creates a tree item representing a report with visual indicators for availability status",
          "inputs": "label, reportType, filePath, description, timestamp",
          "outputs": "TreeItem with icon, tooltip, command, and context value"
        },
        {
          "name": "getChildren",
          "desc": "Returns the list of all report types to display in the tree view",
          "inputs": "element (optional parent item)",
          "outputs": "Array of ReportTreeItem objects"
        },
        {
          "name": "refresh",
          "desc": "Triggers a refresh of the tree view to show updated report statuses",
          "inputs": "none",
          "outputs": "void (fires onDidChangeTreeData event)"
        },
        {
          "name": "updateReport",
          "desc": "Updates the metadata for a specific report type when it's generated or modified",
          "inputs": "reportInfo (type, path, timestamp, label, description)",
          "outputs": "void (updates internal map and refreshes tree)"
        },
        {
          "name": "deleteReport",
          "desc": "Marks a report as unavailable when it's deleted",
          "inputs": "reportType",
          "outputs": "void (removes from map and refreshes tree)"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "Replaces the old webview-based report viewer with a permanent sidebar pane that gives users a centralized location to see all report types, their availability status, and quick access to open them. Solves the problem of users not knowing which reports exist, whether they've been generated, and how to access them.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view sidebar that displays all available Shadow Watch reports with their generation status and allows users to open them.\",\n  \"userVisibleActions\": [\n    \"View a tree list of all Shadow Watch report types in the sidebar\",\n    \"See which reports have been generated (green file icon) and which haven't (gray slash icon)\",\n    \"See when each report was last generated in the tooltip\",\n    \"Click on a generated report to open it in the editor\",\n    \"See descriptive tooltips explaining what each report type contains\",\n    \"View report file paths and timestamps on hover\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register report generation events to update the tree view\",\n    \"Track five report types: workspace, product, architecture, refactoring, and unit-test\",\n    \"Refresh the tree view automatically when reports are generated or deleted\",\n    \"Handle report metadata including path, timestamp, and description\",\n    \"Provide context values for available/unavailable reports to enable different menu actions\",\n    \"Emit tree data change events to trigger UI updates\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"ReportTreeItem.constructor\",\n      \"desc\": \"Creates a tree item representing a report with visual indicators for availability status\",\n      \"inputs\": \"label, reportType, filePath, description, timestamp\",\n      \"outputs\": \"TreeItem with icon, tooltip, command, and context value\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns the list of all report types to display in the tree view\",\n      \"inputs\": \"element (optional parent item)\",\n      \"outputs\": \"Array of ReportTreeItem objects\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Triggers a refresh of the tree view to show updated report statuses\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void (fires onDidChangeTreeData event)\"\n    },\n    {\n      \"name\": \"updateReport\",\n      \"desc\": \"Updates the metadata for a specific report type when it's generated or modified\",\n      \"inputs\": \"reportInfo (type, path, timestamp, label, description)\",\n      \"outputs\": \"void (updates internal map and refreshes tree)\"\n    },\n    {\n      \"name\": \"deleteReport\",\n      \"desc\": \"Marks a report as unavailable when it's deleted\",\n      \"inputs\": \"reportType\",\n      \"outputs\": \"void (removes from map and refreshes tree)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"Replaces the old webview-based report viewer with a permanent sidebar pane that gives users a centralized location to see all report types, their availability status, and quick access to open them. Solves the problem of users not knowing which reports exist, whether they've been generated, and how to access them.\"\n}\n```"
    },
    {
      "file": "src/state/baseStateManager.ts",
      "role": "Core Logic",
      "purpose": "Provides a reusable base class for managing persistent state in VS Code extensions with automatic storage, validation, and change notifications",
      "userVisibleActions": [
        "State persists across VS Code sessions (user's data is saved and restored when reopening VS Code)",
        "User's settings and preferences are automatically remembered",
        "Changes to state are applied immediately and saved persistently"
      ],
      "developerVisibleActions": [
        "Extend this base class to create type-safe state managers for specific features",
        "Subscribe to state changes to react to updates in real-time",
        "Update state using either direct setState or functional updates",
        "State is automatically loaded from VS Code's global storage on initialization",
        "State changes trigger notifications to all subscribers",
        "Defensive copies prevent external mutation of state",
        "Validation runs automatically before state changes are applied",
        "Failed persistence operations are logged without crashing the extension"
      ],
      "keyFunctions": [
        {
          "name": "setState",
          "desc": "Sets new state, validates it, persists to storage, and notifies all subscribers",
          "inputs": "newState: T (the new state object)",
          "outputs": "void"
        },
        {
          "name": "getState",
          "desc": "Returns a defensive copy of the current state to prevent external mutations",
          "inputs": "none",
          "outputs": "T (deep copy of current state)"
        },
        {
          "name": "updateState",
          "desc": "Updates state using a transformation function applied to current state",
          "inputs": "updater: (current: T) => T (function that transforms current state)",
          "outputs": "void"
        },
        {
          "name": "subscribe",
          "desc": "Registers a listener function to be called whenever state changes",
          "inputs": "listener: (state: T) => void (callback function)",
          "outputs": "function (unsubscribe function to stop listening)"
        },
        {
          "name": "loadState",
          "desc": "Loads state from VS Code's global storage or returns default state if none exists",
          "inputs": "none",
          "outputs": "T (loaded or default state)"
        },
        {
          "name": "getDefaultState",
          "desc": "Abstract method that subclasses must implement to provide initial default state",
          "inputs": "none",
          "outputs": "T (default state object)"
        }
      ],
      "dependencies": [
        "vscode"
      ],
      "intent": "This file exists to eliminate duplicate state management code across the extension by providing a single, robust, reusable foundation for managing persistent state. It solves the problem of manually handling storage, validation, subscriptions, and notifications for every feature that needs to track state, ensuring consistency and reducing bugs.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a reusable base class for managing persistent state in VS Code extensions with automatic storage, validation, and change notifications\",\n  \"userVisibleActions\": [\n    \"State persists across VS Code sessions (user's data is saved and restored when reopening VS Code)\",\n    \"User's settings and preferences are automatically remembered\",\n    \"Changes to state are applied immediately and saved persistently\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extend this base class to create type-safe state managers for specific features\",\n    \"Subscribe to state changes to react to updates in real-time\",\n    \"Update state using either direct setState or functional updates\",\n    \"State is automatically loaded from VS Code's global storage on initialization\",\n    \"State changes trigger notifications to all subscribers\",\n    \"Defensive copies prevent external mutation of state\",\n    \"Validation runs automatically before state changes are applied\",\n    \"Failed persistence operations are logged without crashing the extension\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setState\",\n      \"desc\": \"Sets new state, validates it, persists to storage, and notifies all subscribers\",\n      \"inputs\": \"newState: T (the new state object)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getState\",\n      \"desc\": \"Returns a defensive copy of the current state to prevent external mutations\",\n      \"inputs\": \"none\",\n      \"outputs\": \"T (deep copy of current state)\"\n    },\n    {\n      \"name\": \"updateState\",\n      \"desc\": \"Updates state using a transformation function applied to current state\",\n      \"inputs\": \"updater: (current: T) => T (function that transforms current state)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"subscribe\",\n      \"desc\": \"Registers a listener function to be called whenever state changes\",\n      \"inputs\": \"listener: (state: T) => void (callback function)\",\n      \"outputs\": \"function (unsubscribe function to stop listening)\"\n    },\n    {\n      \"name\": \"loadState\",\n      \"desc\": \"Loads state from VS Code's global storage or returns default state if none exists\",\n      \"inputs\": \"none\",\n      \"outputs\": \"T (loaded or default state)\"\n    },\n    {\n      \"name\": \"getDefaultState\",\n      \"desc\": \"Abstract method that subclasses must implement to provide initial default state\",\n      \"inputs\": \"none\",\n      \"outputs\": \"T (default state object)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to eliminate duplicate state management code across the extension by providing a single, robust, reusable foundation for managing persistent state. It solves the problem of manually handling storage, validation, subscriptions, and notifications for every feature that needs to track state, ensuring consistency and reducing bugs.\"\n}\n```"
    },
    {
      "file": "src/state/llmStateManager.ts",
      "role": "Core Logic",
      "purpose": "Centralizes and manages all state for LLM-powered features, UI providers, and analysis results throughout the extension's lifecycle.",
      "userVisibleActions": [
        "View LLM-generated insights in the insights tree view",
        "Navigate product documentation through the product navigator",
        "See analysis results in the analysis viewer",
        "Browse unit test information in the unit tests navigator",
        "View generated reports through the reports viewer",
        "See output messages in the LLM output channel"
      ],
      "developerVisibleActions": [
        "Store and retrieve the current LLM service instance for making AI requests",
        "Cache analysis context to avoid redundant processing",
        "Store enhanced product documentation for later retrieval",
        "Maintain LLM insights between operations",
        "Store code analysis results for access by multiple components",
        "Manage references to all UI tree providers and viewers",
        "Update all registered UI providers when state changes",
        "Access output channel for logging LLM operations",
        "Clear all cached state when needed",
        "Check if LLM service is available before making requests"
      ],
      "keyFunctions": [
        {
          "name": "getLLMService",
          "desc": "Retrieves the initialized LLM service or throws error if not available",
          "inputs": "none",
          "outputs": "LLMService instance"
        },
        {
          "name": "setLLMService",
          "desc": "Stores the LLM service instance for extension-wide access",
          "inputs": "service: LLMService",
          "outputs": "void"
        },
        {
          "name": "getAnalysisContext",
          "desc": "Retrieves the last stored analysis context",
          "inputs": "none",
          "outputs": "AnalysisContext or null"
        },
        {
          "name": "setAnalysisContext",
          "desc": "Stores analysis context for later retrieval",
          "inputs": "context: AnalysisContext",
          "outputs": "void"
        },
        {
          "name": "getEnhancedProductDocs",
          "desc": "Retrieves cached enhanced product documentation",
          "inputs": "none",
          "outputs": "EnhancedProductDocumentation or null"
        },
        {
          "name": "setEnhancedProductDocs",
          "desc": "Stores enhanced product documentation",
          "inputs": "docs: EnhancedProductDocumentation",
          "outputs": "void"
        },
        {
          "name": "getLLMInsights",
          "desc": "Retrieves cached LLM-generated insights",
          "inputs": "none",
          "outputs": "LLMInsights or null"
        },
        {
          "name": "setLLMInsights",
          "desc": "Stores LLM insights and updates all registered UI providers",
          "inputs": "insights: LLMInsights",
          "outputs": "void"
        },
        {
          "name": "getCodeAnalysis",
          "desc": "Retrieves cached code analysis results",
          "inputs": "none",
          "outputs": "CodeAnalysis or null"
        },
        {
          "name": "setCodeAnalysis",
          "desc": "Stores code analysis results",
          "inputs": "analysis: CodeAnalysis",
          "outputs": "void"
        },
        {
          "name": "registerTreeProvider",
          "desc": "Registers the insights tree provider for state updates",
          "inputs": "provider: InsightsTreeProvider",
          "outputs": "void"
        },
        {
          "name": "registerProductNavigator",
          "desc": "Registers the product navigator for state updates",
          "inputs": "navigator: ProductNavigatorProvider",
          "outputs": "void"
        },
        {
          "name": "registerInsightsViewer",
          "desc": "Registers the insights viewer for state updates",
          "inputs": "viewer: InsightsViewerProvider",
          "outputs": "void"
        },
        {
          "name": "registerAnalysisViewer",
          "desc": "Registers the analysis viewer for state updates",
          "inputs": "viewer: AnalysisViewerProvider",
          "outputs": "void"
        },
        {
          "name": "registerUnitTestsNavigator",
          "desc": "Registers the unit tests navigator for state updates",
          "inputs": "navigator: UnitTestsNavigatorProvider",
          "outputs": "void"
        },
        {
          "name": "registerReportsViewer",
          "desc": "Registers the reports viewer for state updates",
          "inputs": "viewer: ReportsViewer",
          "outputs": "void"
        },
        {
          "name": "registerReportsTreeProvider",
          "desc": "Registers the reports tree provider for state updates",
          "inputs": "provider: ReportsTreeProvider",
          "outputs": "void"
        },
        {
          "name": "setOutputChannel",
          "desc": "Stores the output channel for logging LLM operations",
          "inputs": "channel: vscode.OutputChannel",
          "outputs": "void"
        },
        {
          "name": "getOutputChannel",
          "desc": "Retrieves the output channel for displaying LLM messages",
          "inputs": "none",
          "outputs": "vscode.OutputChannel or null"
        },
        {
          "name": "updateAllProviders",
          "desc": "Refreshes all registered UI providers with current state",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "clearState",
          "desc": "Clears all cached analysis data and state",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "hasLLMService",
          "desc": "Checks if LLM service is initialized and available",
          "inputs": "none",
          "outputs": "boolean"
        }
      ],
      "dependencies": [
        "vscode",
        "llmService",
        "fileDocumentation",
        "analyzer",
        "insightsTreeView",
        "productNavigator",
        "insightsViewer",
        "analysisViewer",
        "unitTestsNavigator",
        "ui/reportsViewer",
        "reportsTreeProvider"
      ],
      "intent": "Provides a single source of truth for all LLM-related state across the extension. Eliminates the need to pass state between components by centralizing storage and retrieval of LLM services, analysis results, documentation, and UI provider references. Ensures all UI components stay synchronized when state changes by automatically updating registered providers.",
      "rawContent": "```json\n{\n  \"purpose\": \"Centralizes and manages all state for LLM-powered features, UI providers, and analysis results throughout the extension's lifecycle.\",\n  \"userVisibleActions\": [\n    \"View LLM-generated insights in the insights tree view\",\n    \"Navigate product documentation through the product navigator\",\n    \"See analysis results in the analysis viewer\",\n    \"Browse unit test information in the unit tests navigator\",\n    \"View generated reports through the reports viewer\",\n    \"See output messages in the LLM output channel\"\n  ],\n  \"developerVisibleActions\": [\n    \"Store and retrieve the current LLM service instance for making AI requests\",\n    \"Cache analysis context to avoid redundant processing\",\n    \"Store enhanced product documentation for later retrieval\",\n    \"Maintain LLM insights between operations\",\n    \"Store code analysis results for access by multiple components\",\n    \"Manage references to all UI tree providers and viewers\",\n    \"Update all registered UI providers when state changes\",\n    \"Access output channel for logging LLM operations\",\n    \"Clear all cached state when needed\",\n    \"Check if LLM service is available before making requests\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getLLMService\",\n      \"desc\": \"Retrieves the initialized LLM service or throws error if not available\",\n      \"inputs\": \"none\",\n      \"outputs\": \"LLMService instance\"\n    },\n    {\n      \"name\": \"setLLMService\",\n      \"desc\": \"Stores the LLM service instance for extension-wide access\",\n      \"inputs\": \"service: LLMService\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getAnalysisContext\",\n      \"desc\": \"Retrieves the last stored analysis context\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisContext or null\"\n    },\n    {\n      \"name\": \"setAnalysisContext\",\n      \"desc\": \"Stores analysis context for later retrieval\",\n      \"inputs\": \"context: AnalysisContext\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getEnhancedProductDocs\",\n      \"desc\": \"Retrieves cached enhanced product documentation\",\n      \"inputs\": \"none\",\n      \"outputs\": \"EnhancedProductDocumentation or null\"\n    },\n    {\n      \"name\": \"setEnhancedProductDocs\",\n      \"desc\": \"Stores enhanced product documentation\",\n      \"inputs\": \"docs: EnhancedProductDocumentation\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getLLMInsights\",\n      \"desc\": \"Retrieves cached LLM-generated insights\",\n      \"inputs\": \"none\",\n      \"outputs\": \"LLMInsights or null\"\n    },\n    {\n      \"name\": \"setLLMInsights\",\n      \"desc\": \"Stores LLM insights and updates all registered UI providers\",\n      \"inputs\": \"insights: LLMInsights\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getCodeAnalysis\",\n      \"desc\": \"Retrieves cached code analysis results\",\n      \"inputs\": \"none\",\n      \"outputs\": \"CodeAnalysis or null\"\n    },\n    {\n      \"name\": \"setCodeAnalysis\",\n      \"desc\": \"Stores code analysis results\",\n      \"inputs\": \"analysis: CodeAnalysis\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerTreeProvider\",\n      \"desc\": \"Registers the insights tree provider for state updates\",\n      \"inputs\": \"provider: InsightsTreeProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerProductNavigator\",\n      \"desc\": \"Registers the product navigator for state updates\",\n      \"inputs\": \"navigator: ProductNavigatorProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerInsightsViewer\",\n      \"desc\": \"Registers the insights viewer for state updates\",\n      \"inputs\": \"viewer: InsightsViewerProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerAnalysisViewer\",\n      \"desc\": \"Registers the analysis viewer for state updates\",\n      \"inputs\": \"viewer: AnalysisViewerProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerUnitTestsNavigator\",\n      \"desc\": \"Registers the unit tests navigator for state updates\",\n      \"inputs\": \"navigator: UnitTestsNavigatorProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerReportsViewer\",\n      \"desc\": \"Registers the reports viewer for state updates\",\n      \"inputs\": \"viewer: ReportsViewer\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"registerReportsTreeProvider\",\n      \"desc\": \"Registers the reports tree provider for state updates\",\n      \"inputs\": \"provider: ReportsTreeProvider\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setOutputChannel\",\n      \"desc\": \"Stores the output channel for logging LLM operations\",\n      \"inputs\": \"channel: vscode.OutputChannel\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getOutputChannel\",\n      \"desc\": \"Retrieves the output channel for displaying LLM messages\",\n      \"inputs\": \"none\",\n      \"outputs\": \"vscode.OutputChannel or null\"\n    },\n    {\n      \"name\": \"updateAllProviders\",\n      \"desc\": \"Refreshes all registered UI providers with current state\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"clearState\",\n      \"desc\": \"Clears all cached analysis data and state\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"hasLLMService\",\n      \"desc\": \"Checks if LLM service is initialized and available\",\n      \"inputs\": \"none\",\n      \"outputs\": \"boolean\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"llmService\",\n    \"fileDocumentation\",\n    \"analyzer\",\n    \"insightsTreeView\",\n    \"productNavigator\",\n    \"insightsViewer\",\n    \"analysisViewer\",\n    \"unitTestsNavigator\",\n    \"ui/reportsViewer\",\n    \"reportsTreeProvider\"\n  ],\n  \"intent\": \"Provides a single source of truth for all LLM-related state across the extension. Eliminates the need to pass state between components by centralizing storage and retrieval of LLM services, analysis results, documentation, and UI provider references. Ensures all UI components stay synchronized when state changes by automatically updating registered providers.\"\n}\n```"
    },
    {
      "file": "src/staticAnalysisViewer.ts",
      "role": "GUI View",
      "purpose": "Displays a tree view of static code analysis issues organized by severity (errors, warnings, info) for users to browse and navigate to problem locations.",
      "userVisibleActions": [
        "View static analysis issues organized by severity categories (errors, warnings, info)",
        "See a summary count of total issues found",
        "Click on an issue to navigate to the file and line where it was detected",
        "See 'No static issues found' message when analysis finds no problems",
        "View issue descriptions and affected file locations in the tree view",
        "Expand/collapse severity categories to show/hide issues",
        "See icons indicating issue severity (error, warning, info)"
      ],
      "developerVisibleActions": [
        "Set insights data from analysis results to populate the tree view",
        "Refresh the tree view to update displayed issues",
        "Trigger 'Analyze Workspace' command to check for issues",
        "Navigate to specific file locations when issues are selected",
        "Organize issues into error, warning, and info severity categories",
        "Display formatted file paths and line numbers for each issue"
      ],
      "keyFunctions": [
        {
          "name": "setInsights",
          "desc": "Updates the tree view with new static analysis results",
          "inputs": "Array of Insight objects containing issue data",
          "outputs": "void (triggers tree refresh)"
        },
        {
          "name": "refresh",
          "desc": "Refreshes the tree view display to show current insights",
          "inputs": "none",
          "outputs": "void (fires tree data change event)"
        },
        {
          "name": "getTreeItem",
          "desc": "Returns the visual representation of a tree item",
          "inputs": "StaticAnalysisItem element",
          "outputs": "vscode.TreeItem for display"
        },
        {
          "name": "getChildren",
          "desc": "Provides child items for tree hierarchy (categories and issues)",
          "inputs": "Optional parent StaticAnalysisItem",
          "outputs": "Promise of StaticAnalysisItem array"
        },
        {
          "name": "getRootItems",
          "desc": "Generates top-level tree items including summary and severity categories",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for root level"
        },
        {
          "name": "getErrorItems",
          "desc": "Retrieves all error-severity issues for display",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for errors"
        },
        {
          "name": "getWarningItems",
          "desc": "Retrieves all warning-severity issues for display",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for warnings"
        },
        {
          "name": "getInfoItems",
          "desc": "Retrieves all info-severity issues for display",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for info items"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "./insightGenerator"
      ],
      "intent": "Provides a structured, browsable tree view interface for developers to review static code analysis results, organized by severity level, with quick navigation to problem locations in the codebase.",
      "rawContent": "```json\n{\n  \"purpose\": \"Displays a tree view of static code analysis issues organized by severity (errors, warnings, info) for users to browse and navigate to problem locations.\",\n  \"userVisibleActions\": [\n    \"View static analysis issues organized by severity categories (errors, warnings, info)\",\n    \"See a summary count of total issues found\",\n    \"Click on an issue to navigate to the file and line where it was detected\",\n    \"See 'No static issues found' message when analysis finds no problems\",\n    \"View issue descriptions and affected file locations in the tree view\",\n    \"Expand/collapse severity categories to show/hide issues\",\n    \"See icons indicating issue severity (error, warning, info)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Set insights data from analysis results to populate the tree view\",\n    \"Refresh the tree view to update displayed issues\",\n    \"Trigger 'Analyze Workspace' command to check for issues\",\n    \"Navigate to specific file locations when issues are selected\",\n    \"Organize issues into error, warning, and info severity categories\",\n    \"Display formatted file paths and line numbers for each issue\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setInsights\",\n      \"desc\": \"Updates the tree view with new static analysis results\",\n      \"inputs\": \"Array of Insight objects containing issue data\",\n      \"outputs\": \"void (triggers tree refresh)\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Refreshes the tree view display to show current insights\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void (fires tree data change event)\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the visual representation of a tree item\",\n      \"inputs\": \"StaticAnalysisItem element\",\n      \"outputs\": \"vscode.TreeItem for display\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Provides child items for tree hierarchy (categories and issues)\",\n      \"inputs\": \"Optional parent StaticAnalysisItem\",\n      \"outputs\": \"Promise of StaticAnalysisItem array\"\n    },\n    {\n      \"name\": \"getRootItems\",\n      \"desc\": \"Generates top-level tree items including summary and severity categories\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for root level\"\n    },\n    {\n      \"name\": \"getErrorItems\",\n      \"desc\": \"Retrieves all error-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for errors\"\n    },\n    {\n      \"name\": \"getWarningItems\",\n      \"desc\": \"Retrieves all warning-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for warnings\"\n    },\n    {\n      \"name\": \"getInfoItems\",\n      \"desc\": \"Retrieves all info-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for info items\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"Provides a structured, browsable tree view interface for developers to review static code analysis results, organized by severity level, with quick navigation to problem locations in the codebase.\"\n}\n```"
    },
    {
      "file": "src/storage/incrementalStorage.ts",
      "role": "Core Logic",
      "purpose": "Provides a generic storage system for saving and loading timestamped data incrementally to disk in JSON and optionally Markdown formats.",
      "userVisibleActions": [
        "Data is automatically saved to disk with timestamps for tracking when it was generated",
        "Multiple versions of data can be saved incrementally with iteration numbers",
        "Data can be retrieved from the most recent saved version",
        "Previously saved data is preserved in timestamped files for historical tracking"
      ],
      "developerVisibleActions": [
        "Create a storage instance configured for specific data types with custom prefixes and directories",
        "Save typed data objects with optional metadata like iteration number, run ID, and timestamps",
        "Load the most recent saved data automatically based on filename patterns",
        "Store data in both JSON and Markdown formats simultaneously when configured",
        "Organize saved files into subdirectories with customizable naming patterns",
        "Access saved file paths and metadata for debugging or reporting",
        "Handle storage errors through the ErrorHandler utility"
      ],
      "keyFunctions": [
        {
          "name": "save",
          "desc": "Saves data to disk with metadata, creating timestamped files with optional iteration numbers",
          "inputs": "data: T (generic typed data), metadata?: StorageMetadata (timestamps, iteration, runId, etc.)",
          "outputs": "Promise<void>"
        },
        {
          "name": "load",
          "desc": "Loads the most recently saved data from disk based on file patterns",
          "inputs": "None",
          "outputs": "Promise<{data: T, metadata: StorageMetadata} | null>"
        },
        {
          "name": "getFilePath",
          "desc": "Generates the file path for saving data based on metadata and configuration",
          "inputs": "metadata?: StorageMetadata",
          "outputs": "string (file path)"
        },
        {
          "name": "getLatestFile",
          "desc": "Finds the most recent file matching the storage pattern in the directory",
          "inputs": "None",
          "outputs": "string | null (file path)"
        },
        {
          "name": "ensureDirectory",
          "desc": "Creates the storage directory structure if it doesn't exist",
          "inputs": "None",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "ErrorHandler"
      ],
      "intent": "This file exists to eliminate code duplication across different storage operations by providing a reusable, type-safe storage system. It solves the problem of consistently saving and retrieving timestamped data with metadata, supporting incremental workflows where multiple versions of data need to be preserved and tracked over time. It standardizes file naming, directory organization, and metadata handling across the application.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a generic storage system for saving and loading timestamped data incrementally to disk in JSON and optionally Markdown formats.\",\n  \"userVisibleActions\": [\n    \"Data is automatically saved to disk with timestamps for tracking when it was generated\",\n    \"Multiple versions of data can be saved incrementally with iteration numbers\",\n    \"Data can be retrieved from the most recent saved version\",\n    \"Previously saved data is preserved in timestamped files for historical tracking\"\n  ],\n  \"developerVisibleActions\": [\n    \"Create a storage instance configured for specific data types with custom prefixes and directories\",\n    \"Save typed data objects with optional metadata like iteration number, run ID, and timestamps\",\n    \"Load the most recent saved data automatically based on filename patterns\",\n    \"Store data in both JSON and Markdown formats simultaneously when configured\",\n    \"Organize saved files into subdirectories with customizable naming patterns\",\n    \"Access saved file paths and metadata for debugging or reporting\",\n    \"Handle storage errors through the ErrorHandler utility\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"save\",\n      \"desc\": \"Saves data to disk with metadata, creating timestamped files with optional iteration numbers\",\n      \"inputs\": \"data: T (generic typed data), metadata?: StorageMetadata (timestamps, iteration, runId, etc.)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"load\",\n      \"desc\": \"Loads the most recently saved data from disk based on file patterns\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Promise<{data: T, metadata: StorageMetadata} | null>\"\n    },\n    {\n      \"name\": \"getFilePath\",\n      \"desc\": \"Generates the file path for saving data based on metadata and configuration\",\n      \"inputs\": \"metadata?: StorageMetadata\",\n      \"outputs\": \"string (file path)\"\n    },\n    {\n      \"name\": \"getLatestFile\",\n      \"desc\": \"Finds the most recent file matching the storage pattern in the directory\",\n      \"inputs\": \"None\",\n      \"outputs\": \"string | null (file path)\"\n    },\n    {\n      \"name\": \"ensureDirectory\",\n      \"desc\": \"Creates the storage directory structure if it doesn't exist\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"ErrorHandler\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication across different storage operations by providing a reusable, type-safe storage system. It solves the problem of consistently saving and retrieving timestamped data with metadata, supporting incremental workflows where multiple versions of data need to be preserved and tracked over time. It standardizes file naming, directory organization, and metadata handling across the application.\"\n}\n```"
    },
    {
      "file": "src/test/__mocks__/vscode.ts",
      "role": "Core Logic",
      "purpose": "Provides mock implementations of VS Code API objects and functions for Jest unit testing without requiring the actual VS Code extension host.",
      "userVisibleActions": [
        "No direct user-visible actions - this file only affects test execution and doesn't run in the actual extension"
      ],
      "developerVisibleActions": [
        "Enables Jest tests to run without VS Code by providing fake implementations of window.showInformationMessage, showErrorMessage, and other VS Code APIs",
        "Allows developers to write unit tests that call VS Code APIs without starting the full extension host",
        "Provides mockable functions that can be configured in tests to return specific values or simulate behaviors",
        "Simulates file URIs, workspace configurations, commands, and output channels for isolated testing",
        "Tracks mock function calls and results for test assertions"
      ],
      "keyFunctions": [
        {
          "name": "createMockFn",
          "desc": "Creates a mock function that can be configured to return values, resolve promises, or execute custom implementations in tests",
          "inputs": "None",
          "outputs": "A mock function object with methods like mockReturnValue, mockResolvedValue, mockRejectedValue, and mockImplementation"
        },
        {
          "name": "window.showInformationMessage",
          "desc": "Mock for displaying information messages to users",
          "inputs": "Message text and optional actions",
          "outputs": "Configurable mock return value"
        },
        {
          "name": "window.createOutputChannel",
          "desc": "Mock for creating output channels with methods to append lines, clear, show, and dispose",
          "inputs": "Channel name",
          "outputs": "Mock output channel object with appendLine, clear, dispose, and show methods"
        },
        {
          "name": "workspace.getConfiguration",
          "desc": "Mock for retrieving workspace configuration settings",
          "inputs": "Configuration section name",
          "outputs": "Mock configuration object with get, has, update, and inspect methods"
        },
        {
          "name": "Uri.file",
          "desc": "Mock for creating file URIs from file system paths",
          "inputs": "File system path string",
          "outputs": "Mock URI object with fsPath, scheme, and path properties"
        },
        {
          "name": "commands.registerCommand",
          "desc": "Mock for registering VS Code commands",
          "inputs": "Command identifier and callback function",
          "outputs": "Configurable mock return value"
        }
      ],
      "dependencies": [],
      "intent": "This file exists to enable unit testing of VS Code extension code without requiring the full VS Code environment. It solves the problem of testing extension logic in isolation by providing lightweight mock implementations of VS Code APIs that can be configured and monitored during tests, allowing developers to write fast, reliable unit tests without the overhead of the extension host.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides mock implementations of VS Code API objects and functions for Jest unit testing without requiring the actual VS Code extension host.\",\n  \"userVisibleActions\": [\n    \"No direct user-visible actions - this file only affects test execution and doesn't run in the actual extension\"\n  ],\n  \"developerVisibleActions\": [\n    \"Enables Jest tests to run without VS Code by providing fake implementations of window.showInformationMessage, showErrorMessage, and other VS Code APIs\",\n    \"Allows developers to write unit tests that call VS Code APIs without starting the full extension host\",\n    \"Provides mockable functions that can be configured in tests to return specific values or simulate behaviors\",\n    \"Simulates file URIs, workspace configurations, commands, and output channels for isolated testing\",\n    \"Tracks mock function calls and results for test assertions\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"createMockFn\",\n      \"desc\": \"Creates a mock function that can be configured to return values, resolve promises, or execute custom implementations in tests\",\n      \"inputs\": \"None\",\n      \"outputs\": \"A mock function object with methods like mockReturnValue, mockResolvedValue, mockRejectedValue, and mockImplementation\"\n    },\n    {\n      \"name\": \"window.showInformationMessage\",\n      \"desc\": \"Mock for displaying information messages to users\",\n      \"inputs\": \"Message text and optional actions\",\n      \"outputs\": \"Configurable mock return value\"\n    },\n    {\n      \"name\": \"window.createOutputChannel\",\n      \"desc\": \"Mock for creating output channels with methods to append lines, clear, show, and dispose\",\n      \"inputs\": \"Channel name\",\n      \"outputs\": \"Mock output channel object with appendLine, clear, dispose, and show methods\"\n    },\n    {\n      \"name\": \"workspace.getConfiguration\",\n      \"desc\": \"Mock for retrieving workspace configuration settings\",\n      \"inputs\": \"Configuration section name\",\n      \"outputs\": \"Mock configuration object with get, has, update, and inspect methods\"\n    },\n    {\n      \"name\": \"Uri.file\",\n      \"desc\": \"Mock for creating file URIs from file system paths\",\n      \"inputs\": \"File system path string\",\n      \"outputs\": \"Mock URI object with fsPath, scheme, and path properties\"\n    },\n    {\n      \"name\": \"commands.registerCommand\",\n      \"desc\": \"Mock for registering VS Code commands\",\n      \"inputs\": \"Command identifier and callback function\",\n      \"outputs\": \"Configurable mock return value\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"This file exists to enable unit testing of VS Code extension code without requiring the full VS Code environment. It solves the problem of testing extension logic in isolation by providing lightweight mock implementations of VS Code APIs that can be configured and monitored during tests, allowing developers to write fast, reliable unit tests without the overhead of the extension host.\"\n}\n```"
    },
    {
      "file": "src/ui/reportsViewer.ts",
      "role": "GUI View",
      "purpose": "Displays a unified webview panel showing links to all generated reports (workspace, product, architecture, refactoring, unit-test) in the VS Code extension",
      "userVisibleActions": [
        "View a centralized Reports pane with links to all available reports",
        "Click on report cards to open HTML reports in default browser",
        "See which reports are available vs. not yet generated",
        "View timestamps showing when each report was last generated",
        "See descriptive labels and descriptions for each report type",
        "Refresh the Reports pane to see updated report availability",
        "Close the Reports pane when finished viewing"
      ],
      "developerVisibleActions": [
        "Register a new report by calling updateReport() with report type and file path",
        "Show the Reports pane by calling show() method",
        "Update report information including path and timestamp for each report type",
        "Clear a specific report by calling updateReport() with null path",
        "Handle webview messages for report opening actions",
        "Track five report types: workspace, product, architecture, refactoring, and unit-test",
        "Dispose of the Reports viewer to clean up resources"
      ],
      "keyFunctions": [
        {
          "name": "show",
          "desc": "Shows or reveals the Reports webview panel to the user",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "updateReport",
          "desc": "Updates the path, timestamp, and availability status of a specific report type",
          "inputs": "type (report type), path (file path or null)",
          "outputs": "void"
        },
        {
          "name": "updateContent",
          "desc": "Refreshes the webview content with current report information",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getReportLabel",
          "desc": "Returns user-friendly display label for a report type",
          "inputs": "type (report type)",
          "outputs": "string label"
        },
        {
          "name": "getReportDescription",
          "desc": "Returns descriptive text explaining what each report type contains",
          "inputs": "type (report type)",
          "outputs": "string description"
        },
        {
          "name": "handleOpenReport",
          "desc": "Opens a report HTML file in the default external browser",
          "inputs": "reportType (string)",
          "outputs": "Promise<void>"
        },
        {
          "name": "generateHtmlContent",
          "desc": "Generates the HTML content for the Reports webview panel",
          "inputs": "none",
          "outputs": "string (HTML content)"
        },
        {
          "name": "dispose",
          "desc": "Cleans up and disposes of the webview panel",
          "inputs": "none",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "./webview/baseWebviewProvider",
        "./webview/webviewTemplateEngine"
      ],
      "intent": "This file exists to replace individual webview panels for each report type with a single unified Reports pane. It solves the problem of managing multiple report viewers by providing a centralized dashboard where users can access all generated reports (workspace analysis, product requirements, architecture documentation, refactoring suggestions, and unit test reports) from one location. It tracks report availability, timestamps, and provides easy access to open reports in the browser.",
      "rawContent": "```json\n{\n  \"purpose\": \"Displays a unified webview panel showing links to all generated reports (workspace, product, architecture, refactoring, unit-test) in the VS Code extension\",\n  \"userVisibleActions\": [\n    \"View a centralized Reports pane with links to all available reports\",\n    \"Click on report cards to open HTML reports in default browser\",\n    \"See which reports are available vs. not yet generated\",\n    \"View timestamps showing when each report was last generated\",\n    \"See descriptive labels and descriptions for each report type\",\n    \"Refresh the Reports pane to see updated report availability\",\n    \"Close the Reports pane when finished viewing\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register a new report by calling updateReport() with report type and file path\",\n    \"Show the Reports pane by calling show() method\",\n    \"Update report information including path and timestamp for each report type\",\n    \"Clear a specific report by calling updateReport() with null path\",\n    \"Handle webview messages for report opening actions\",\n    \"Track five report types: workspace, product, architecture, refactoring, and unit-test\",\n    \"Dispose of the Reports viewer to clean up resources\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"show\",\n      \"desc\": \"Shows or reveals the Reports webview panel to the user\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"updateReport\",\n      \"desc\": \"Updates the path, timestamp, and availability status of a specific report type\",\n      \"inputs\": \"type (report type), path (file path or null)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"updateContent\",\n      \"desc\": \"Refreshes the webview content with current report information\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getReportLabel\",\n      \"desc\": \"Returns user-friendly display label for a report type\",\n      \"inputs\": \"type (report type)\",\n      \"outputs\": \"string label\"\n    },\n    {\n      \"name\": \"getReportDescription\",\n      \"desc\": \"Returns descriptive text explaining what each report type contains\",\n      \"inputs\": \"type (report type)\",\n      \"outputs\": \"string description\"\n    },\n    {\n      \"name\": \"handleOpenReport\",\n      \"desc\": \"Opens a report HTML file in the default external browser\",\n      \"inputs\": \"reportType (string)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"generateHtmlContent\",\n      \"desc\": \"Generates the HTML content for the Reports webview panel\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string (HTML content)\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up and disposes of the webview panel\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./webview/baseWebviewProvider\",\n    \"./webview/webviewTemplateEngine\"\n  ],\n  \"intent\": \"This file exists to replace individual webview panels for each report type with a single unified Reports pane. It solves the problem of managing multiple report viewers by providing a centralized dashboard where users can access all generated reports (workspace analysis, product requirements, architecture documentation, refactoring suggestions, and unit test reports) from one location. It tracks report availability, timestamps, and provides easy access to open reports in the browser.\"\n}\n```"
    },
    {
      "file": "src/ui/webview/baseWebviewProvider.ts",
      "role": "GUI View",
      "purpose": "Provides a base class for creating and managing webview panels in VSCode with shared functionality to reduce code duplication",
      "userVisibleActions": [
        "User sees webview panels appear or come to front when activated",
        "User sees webview panels close and disappear when disposed",
        "User sees webview content rendered with HTML through a template system"
      ],
      "developerVisibleActions": [
        "Developer creates reusable webview panels with consistent configuration",
        "Developer reveals existing panels instead of creating duplicates",
        "Developer sets HTML content using template engine with options",
        "Developer disposes webview panels programmatically by ID",
        "Developer configures panel behavior (scripts, column placement, context retention)"
      ],
      "keyFunctions": [
        {
          "name": "createOrRevealPanel",
          "desc": "Creates a new webview panel or reveals an existing one if it already exists",
          "inputs": "id (string), title (string), options (BaseWebviewOptions with viewColumn, enableScripts, retainContextWhenHidden)",
          "outputs": "vscode.WebviewPanel instance"
        },
        {
          "name": "setPanelHtml",
          "desc": "Sets the HTML content of a webview panel using the template engine",
          "inputs": "panel (vscode.WebviewPanel), options (WebviewTemplateOptions)",
          "outputs": "void"
        },
        {
          "name": "disposePanel",
          "desc": "Closes and removes a webview panel by its ID",
          "inputs": "id (string)",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "./webviewTemplateEngine"
      ],
      "intent": "This file exists to eliminate code duplication across different webview implementations by providing common functionality for creating, managing, and disposing webview panels with consistent behavior and configuration",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a base class for creating and managing webview panels in VSCode with shared functionality to reduce code duplication\",\n  \"userVisibleActions\": [\n    \"User sees webview panels appear or come to front when activated\",\n    \"User sees webview panels close and disappear when disposed\",\n    \"User sees webview content rendered with HTML through a template system\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer creates reusable webview panels with consistent configuration\",\n    \"Developer reveals existing panels instead of creating duplicates\",\n    \"Developer sets HTML content using template engine with options\",\n    \"Developer disposes webview panels programmatically by ID\",\n    \"Developer configures panel behavior (scripts, column placement, context retention)\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"createOrRevealPanel\",\n      \"desc\": \"Creates a new webview panel or reveals an existing one if it already exists\",\n      \"inputs\": \"id (string), title (string), options (BaseWebviewOptions with viewColumn, enableScripts, retainContextWhenHidden)\",\n      \"outputs\": \"vscode.WebviewPanel instance\"\n    },\n    {\n      \"name\": \"setPanelHtml\",\n      \"desc\": \"Sets the HTML content of a webview panel using the template engine\",\n      \"inputs\": \"panel (vscode.WebviewPanel), options (WebviewTemplateOptions)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"disposePanel\",\n      \"desc\": \"Closes and removes a webview panel by its ID\",\n      \"inputs\": \"id (string)\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./webviewTemplateEngine\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication across different webview implementations by providing common functionality for creating, managing, and disposing webview panels with consistent behavior and configuration\"\n}\n```"
    }
  ],
  "rawContent": "{\"overview\":\"Shadow Watch is a VS Code extension that provides AI-powered code intelligence and documentation capabilities for TypeScript and JavaScript projects. It analyzes your codebase to understand its structure, patterns, and quality, then generates comprehensive human-readable documentation automatically. The extension integrates with OpenAI GPT and Anthropic Claude models to transform raw code analysis into architectural insights, product documentation, and actionable recommendations. Users interact with Shadow Watch through multiple sidebar views, commands, and automated workflows that make understanding and documenting large codebases effortless.\\n\\nThe extension continuously monitors your workspace and can automatically analyze code as you save files, providing real-time feedback through VS Code's Problems panel. It identifies issues like orphaned files, circular dependencies, untested functions, code duplication, and complexity hotspots. All findings are presented with clickable diagnostics that navigate directly to problem locations. Shadow Watch also maintains a persistent cache of analysis results, so reopening your workspace provides instant access to previous insights without re-running expensive AI operations.\\n\\nBeyond analysis, Shadow Watch transforms how developers navigate and understand codebases. Instead of browsing by file structure, users can explore code through a product-centric view organized by features and capabilities. The extension generates multiple report types including workspace summaries, architecture diagrams, refactoring guides, and test documentation, all accessible through a unified reports dashboard. For teams working with AI coding assistants, Shadow Watch provides specialized context generation that helps LLMs understand your codebase structure and make better recommendations.\",\"whatItDoes\":[\"Automatically analyzes TypeScript and JavaScript codebases to identify quality issues, architectural patterns, and complexity metrics\",\"Generates AI-powered documentation including product overviews, architecture insights, and feature descriptions\",\"Provides multiple sidebar views for browsing code by functionality rather than file structure\",\"Displays real-time diagnostics in VS Code's Problems panel with clickable navigation to issues\",\"Creates comprehensive reports including workspace summaries, refactoring guides, and test documentation\",\"Monitors file changes and can automatically re-analyze code on save for continuous feedback\",\"Caches analysis results for 24 hours to provide instant access when reopening workspaces\",\"Identifies code quality issues like orphaned files, circular dependencies, duplicate code, and untested functions\",\"Generates structured context for AI coding assistants to improve their understanding of your codebase\",\"Supports both manual on-demand analysis and automatic analysis triggered by file saves\"],\"userPerspective\":{\"gui\":[\"Multiple tree view sidebars display analysis results, insights, product navigation, static analysis issues, and available reports\",\"Analysis Viewer shows codebase statistics, file classifications, function listings, and entry points in an expandable tree structure\",\"Insights Viewer displays AI-generated architectural analysis and documentation with automatic updates when files change\",\"Product Navigator organizes code by features and capabilities instead of file structure, allowing functional exploration\",\"Static Analysis Viewer categorizes issues by severity (errors, warnings, info) for easy browsing and navigation\",\"Reports Viewer shows a dashboard of all generated reports with generation timestamps and clickable cards to open reports in browser\",\"Status bar indicator displays current analysis state and provides quick access to commands\",\"Problems panel integration shows all detected issues with clickable diagnostics that jump to source locations\",\"Webview panels display rich HTML reports with formatted documentation, tables, and visual organization\",\"Context menus on sidebar items provide actions like regenerating content, opening files, copying to clipboard, and navigating to code\"],\"cli\":[],\"api\":[],\"cicd\":[]},\"workflowIntegration\":[\"Automatic code analysis workflow: Save TypeScript files → Extension analyzes changes → Updates diagnostics and views → Displays new insights\",\"Documentation generation workflow: Trigger analysis command → Extension scans codebase → AI generates documentation → Reports saved and displayed\",\"Code exploration workflow: Open Product Navigator → Browse features/modules → Click items → Navigate to source code → View function details\",\"Issue investigation workflow: View problems in Problems panel → Click diagnostic → Navigate to issue location → Review context and recommendations\",\"Report generation workflow: Trigger report command → AI analyzes codebase → Multiple report types generated → Access via Reports Viewer dashboard\",\"Refactoring planning workflow: Analyze large files → Review refactoring suggestions → View extraction plans → Access step-by-step migration guides\",\"Test documentation workflow: Analyze test files → Generate test plans → Review coverage gaps → Access recommendations for missing tests\",\"AI assistant integration workflow: Export analysis context → Provide to AI coding assistant → Receive codebase-aware suggestions\",\"Workspace initialization workflow: Open project → Load cached analysis → Display previous insights → Optionally trigger fresh analysis\"],\"problemsSolved\":[\"Eliminates manual effort required to understand large, unfamiliar codebases by automatically generating comprehensive documentation\",\"Reduces time spent searching for specific functionality by providing product-centric navigation instead of file-based browsing\",\"Identifies code quality issues and technical debt that might otherwise go unnoticed until they cause problems\",\"Provides actionable refactoring guidance for large, complex files that need to be split or reorganized\",\"Reveals gaps in test coverage by mapping functions to their tests and identifying untested code paths\",\"Detects architectural problems like circular dependencies and orphaned files that impact maintainability\",\"Creates documentation that stays synchronized with code through automatic regeneration workflows\",\"Helps AI coding assistants understand project structure by generating structured context from code analysis\",\"Eliminates need to read through thousands of lines of code to understand what an application does\",\"Provides historical tracking of code insights and documentation through timestamped report preservation\"],\"architecture\":\"Shadow Watch is built as a VS Code extension with a modular architecture centered around code analysis, AI integration, and persistent state management. The core analysis engine examines TypeScript and JavaScript code using Abstract Syntax Tree (AST) parsing to extract detailed metadata about functions, dependencies, complexity metrics, and relationships. This analysis feeds into an insight generation system that identifies patterns, issues, and opportunities for improvement. All analysis results are cached in memory with automatic expiration and persisted to disk in the .shadow directory for historical tracking.\\n\\nThe AI integration layer connects to either OpenAI GPT or Anthropic Claude models through a provider abstraction that handles rate limiting, retry logic, and response parsing. Prompts are constructed through specialized builders that format analysis results into LLM-optimized inputs, ensuring consistent, high-quality documentation generation. The AI responses are parsed into structured formats and transformed into markdown documentation through formatters that organize content by section and category.\\n\\nThe user interface consists of multiple tree view providers that display different perspectives on the codebase: analysis results, AI insights, product navigation, static analysis issues, test structure, and available reports. A diagnostics provider integrates with VS Code's Problems panel to surface issues with clickable navigation. State management coordinates data flow between components, persisting user preferences and generated content across sessions. A file watcher service monitors changes and triggers automatic re-analysis, while an incremental analysis service supports iterative workflows where the system makes multiple rounds of file access and code searches until sufficient context is gathered.\",\"titles\":[\"Shadow Watch Extension\",\"Analysis Viewer\",\"Insights Viewer\",\"Product Navigator\",\"Static Analysis Viewer\",\"Reports Viewer\",\"Unit Tests Navigator\",\"AI-Powered Documentation Generation\",\"Automatic Code Analysis\",\"Code Quality Diagnostics\",\"Refactoring Guidance\",\"Test Coverage Analysis\",\"LLM Integration\",\"Codebase Context Generation\",\"Product-Centric Navigation\",\"Workspace Summary Reports\",\"Architecture Insights\",\"Function-Level Analysis\",\"Dependency Mapping\",\"Circular Dependency Detection\",\"Orphaned File Detection\",\"Duplicate Code Detection\",\"Complexity Metrics\",\"Iterative Analysis\",\"Rate-Limited API Access\",\"Retry Handling\",\"Response Parsing\",\"Progress Notifications\",\"File System Monitoring\",\"Incremental Storage\",\"Analysis Result Caching\"],\"descriptions\":[{\"title\":\"Shadow Watch Extension\",\"description\":\"A VS Code extension that provides AI-powered code intelligence, automated documentation generation, and quality analysis for TypeScript and JavaScript projects. It transforms code analysis into human-readable insights and enables product-centric navigation of codebases.\",\"category\":\"feature\"},{\"title\":\"Analysis Viewer\",\"description\":\"A sidebar tree view that displays comprehensive codebase statistics, file classifications, function listings, and entry points. Users can browse the analyzed code structure and click items to navigate to source locations.\",\"category\":\"feature\"},{\"title\":\"Insights Viewer\",\"description\":\"A sidebar tree view that displays AI-generated architectural insights and documentation with automatic updates when insight files change. Shows the current state of documentation and provides actions to regenerate content.\",\"category\":\"feature\"},{\"title\":\"Product Navigator\",\"description\":\"A sidebar view that organizes code by features and capabilities instead of file structure, allowing users to explore the codebase from a product perspective. Users can click on features, modules, or components to navigate to their implementations.\",\"category\":\"feature\"},{\"title\":\"Static Analysis Viewer\",\"description\":\"A sidebar tree view that categorizes code quality issues by severity level (errors, warnings, info). Users can browse issues and click them to navigate directly to problem locations in the source code.\",\"category\":\"feature\"},{\"title\":\"Reports Viewer\",\"description\":\"A unified dashboard that displays all generated reports with their availability status and generation timestamps. Users can click report cards to open HTML reports in their default browser.\",\"category\":\"feature\"},{\"title\":\"AI-Powered Documentation Generation\",\"description\":\"Automatically generates comprehensive product documentation, architecture insights, and refactoring guides by analyzing code and using LLM models to create human-readable narratives about what the application does and how it's organized.\",\"category\":\"feature\"},{\"title\":\"Automatic Code Analysis\",\"description\":\"Monitors file saves and automatically triggers code analysis when TypeScript files are modified, providing continuous feedback without manual intervention. Users can also trigger analysis on-demand through commands.\",\"category\":\"feature\"},{\"title\":\"Code Quality Diagnostics\",\"description\":\"Integrates with VS Code's Problems panel to display detected issues like orphaned files, circular dependencies, untested functions, and code duplication. All diagnostics are clickable and navigate to the relevant source code location.\",\"category\":\"feature\"},{\"title\":\"Refactoring Guidance\",\"description\":\"Analyzes large, complex files and generates detailed refactoring recommendations including extraction plans, step-by-step migration instructions, and before-and-after code examples to help developers improve code organization.\",\"category\":\"feature\"},{\"title\":\"Test Coverage Analysis\",\"description\":\"Maps functions to their corresponding tests and identifies gaps in test coverage. Generates test documentation and recommendations for missing tests to improve code quality.\",\"category\":\"feature\"},{\"title\":\"LLM Integration\",\"description\":\"Connects to OpenAI GPT or Anthropic Claude models through a flexible provider system that handles API communication, rate limiting, and response parsing. Supports switching between providers based on user configuration.\",\"category\":\"component\"},{\"title\":\"Codebase Context Generation\",\"description\":\"Creates structured context from code analysis that's optimized for consumption by AI coding assistants, helping them understand project structure and make better recommendations.\",\"category\":\"feature\"},{\"title\":\"Product-Centric Navigation\",\"description\":\"Organizes and displays code by what it does (features, capabilities, workflows) rather than how it's structured (files, folders), making it easier to understand application functionality.\",\"category\":\"workflow\"},{\"title\":\"Iterative Analysis\",\"description\":\"Supports multi-round analysis workflows where the system automatically requests additional files and performs code searches across multiple iterations until sufficient context is gathered to complete documentation tasks.\",\"category\":\"workflow\"},{\"title\":\"Analysis Result Caching\",\"description\":\"Stores analysis results in memory and on disk with automatic 24-hour expiration, providing instant access to previous insights when reopening workspaces without re-running expensive AI operations.\",\"category\":\"component\"},{\"title\":\"File System Monitoring\",\"description\":\"Watches for file changes, creations, and deletions across the workspace, automatically updating views and triggering re-analysis when relevant files are modified.\",\"category\":\"component\"},{\"title\":\"Rate-Limited API Access\",\"description\":\"Manages LLM API requests to prevent exceeding provider quotas by implementing intelligent throttling and request queuing based on provider-specific rate limits.\",\"category\":\"component\"},{\"title\":\"Progress Notifications\",\"description\":\"Displays informative progress indicators during long-running operations like analysis and documentation generation, with support for cancellation and dynamic status updates.\",\"category\":\"component\"},{\"title\":\"Incremental Storage\",\"description\":\"Saves analysis results and generated documentation with timestamps and version tracking, preserving historical data for audit trails and comparison over time.\",\"category\":\"component\"}],\"relevantFunctions\":[{\"name\":\"activate\",\"description\":\"Main extension entry point that initializes all components, registers commands, and sets up UI elements when the extension is activated in VS Code\",\"file\":\"src/extension.ts\"},{\"name\":\"analyzeWorkspace\",\"description\":\"Triggers comprehensive analysis of the entire workspace, scanning all TypeScript and JavaScript files to generate insights and documentation\",\"file\":\"src/extension.ts\"},{\"name\":\"generateArchitectureInsights\",\"description\":\"Uses AI to analyze code structure and generate architectural documentation describing what the application does, its components, and how they relate\",\"file\":\"src/llmService.ts\"},{\"name\":\"generateProductDocumentation\",\"description\":\"Creates user-facing product documentation from code analysis, describing features, capabilities, and workflows in human-readable format\",\"file\":\"src/llmService.ts\"},{\"name\":\"navigateToLocation\",\"description\":\"Opens a file at a specific line and column position, highlights the relevant code section, and brings it into focus for the user\",\"file\":\"src/domain/handlers/navigationHandler.ts\"},{\"name\":\"performIncrementalAnalysis\",\"description\":\"Executes multi-round analysis where the system iteratively requests files and performs searches until it has sufficient context to complete the task\",\"file\":\"src/domain/services/incrementalAnalysisService.ts\"},{\"name\":\"parseProductDocumentation\",\"description\":\"Extracts structured product documentation from AI responses, handling both well-formed JSON and malformed text responses with fallback extraction\",\"file\":\"src/ai/llmResponseParser.ts\"},{\"name\":\"updateDiagnostics\",\"description\":\"Updates the VS Code Problems panel with detected code quality issues, creating clickable diagnostics that navigate to problem locations\",\"file\":\"src/diagnosticsProvider.ts\"},{\"name\":\"generateRefactoringReport\",\"description\":\"Analyzes large files and produces detailed refactoring guidance including extraction plans and step-by-step migration instructions\",\"file\":\"src/llmService.ts\"},{\"name\":\"getFileContent\",\"description\":\"Reads and returns the content of a specified file, supporting iterative analysis workflows where AI agents request additional files to examine\",\"file\":\"src/fileAccessHelper.ts\"},{\"name\":\"performGrepSearch\",\"description\":\"Executes regex-based code searches across the workspace, returning matching lines and locations to help AI agents explore and understand the codebase\",\"file\":\"src/fileAccessHelper.ts\"}],\"relevantDataStructures\":[{\"name\":\"AnalysisResult\",\"description\":\"Comprehensive structure containing all code analysis data including files, functions, dependencies, test mappings, duplications, and quality metrics\",\"type\":\"interface\",\"file\":\"src/analyzer.ts\"},{\"name\":\"ProductDocumentation\",\"description\":\"Structured documentation describing what the application does from a user perspective, including features, workflows, and problems solved\",\"type\":\"interface\",\"file\":\"src/fileDocumentation.ts\"},{\"name\":\"ArchitectureInsights\",\"description\":\"AI-generated insights about code architecture including high-level components, relationships, patterns, and recommendations\",\"type\":\"interface\"},{\"name\":\"InsightData\",\"description\":\"Container for various types of insights including code quality issues, architectural patterns, complexity metrics, and refactoring opportunities\",\"type\":\"interface\"},{\"name\":\"FunctionMetadata\",\"description\":\"Detailed information about a function including its signature, complexity, dependencies, state changes, and behavioral characteristics\",\"type\":\"interface\",\"file\":\"src/analyzer.ts\"},{\"name\":\"RefactoringReport\",\"description\":\"Comprehensive refactoring guidance for large files including extraction plans, migration steps, and code examples\",\"type\":\"interface\"},{\"name\":\"TestCoverageData\",\"description\":\"Mapping between functions and their corresponding tests, identifying which functions lack test coverage\",\"type\":\"interface\"},{\"name\":\"DiagnosticInfo\",\"description\":\"Structure representing a code quality issue with severity, location, message, and navigation information for display in Problems panel\",\"type\":\"interface\"},{\"name\":\"LLMProviderConfig\",\"description\":\"Configuration for AI provider connections including API keys, model selection, and provider-specific settings\",\"type\":\"interface\"},{\"name\":\"NavigationItem\",\"description\":\"Tree view item representing a navigable code element like a file, function, feature, or module with associated metadata and actions\",\"type\":\"class\"}],\"relevantCodeFiles\":[{\"path\":\"src/extension.ts\",\"description\":\"Main extension entry point that initializes Shadow Watch, registers all commands, and coordinates between analysis, AI services, and UI components\",\"purpose\":\"Serves as the extension's activation point and orchestrates the initialization of all features and services\",\"role\":\"Entry point and coordinator\"},{\"path\":\"src/llmService.ts\",\"description\":\"Orchestrates AI-powered analysis features including insights generation, documentation creation, and refactoring guidance by connecting to LLM providers\",\"purpose\":\"Manages all AI-powered features that transform code analysis into human-readable documentation and insights\",\"role\":\"AI orchestration service\"},{\"path\":\"src/analyzer.ts\",\"description\":\"Defines core data structures for code analysis results and provides interfaces for representing files, functions, dependencies, and quality metrics\",\"purpose\":\"Establishes the type system and data models for representing analyzed code structure and metadata\",\"role\":\"Data model definitions\"},{\"path\":\"src/insightsTreeView.ts\",\"description\":\"Implements the Insights Viewer sidebar that displays AI-generated documentation status with actions to regenerate or view content\",\"purpose\":\"Provides the UI for viewing and managing AI-generated documentation and insights within VS Code\",\"role\":\"UI component\"},{\"path\":\"src/productNavigator.ts\",\"description\":\"Implements the Product Navigator sidebar that organizes code by features and capabilities instead of file structure\",\"purpose\":\"Enables product-centric code exploration where users browse by what the code does rather than where files are located\",\"role\":\"UI component\"},{\"path\":\"src/diagnosticsProvider.ts\",\"description\":\"Manages the integration with VS Code's Problems panel, creating and updating diagnostics for detected code quality issues\",\"purpose\":\"Surfaces code quality issues in VS Code's native Problems panel with clickable navigation to source locations\",\"role\":\"Diagnostics integration\"},{\"path\":\"src/domain/handlers/navigationHandler.ts\",\"description\":\"Handles user navigation requests from tree views to source code, including opening files, jumping to functions, and highlighting code sections\",\"purpose\":\"Implements all navigation workflows that allow users to jump from analysis views to source code locations\",\"role\":\"Navigation logic\"},{\"path\":\"src/ai/llmResponseParser.ts\",\"description\":\"Parses AI responses into structured data formats, handling both well-formed JSON and malformed responses with fallback extraction\",\"purpose\":\"Ensures reliable extraction of structured documentation from AI responses even when formats are inconsistent\",\"role\":\"Response parsing\"},{\"path\":\"src/domain/prompts/promptBuilder.ts\",\"description\":\"Constructs specialized prompts for different AI analysis tasks including architecture documentation, product features, and code understanding\",\"purpose\":\"Centralizes prompt generation to ensure consistent, high-quality inputs to AI models for all analysis tasks\",\"role\":\"Prompt construction\"},{\"path\":\"src/cache.ts\",\"description\":\"Manages persistent storage and retrieval of analysis results with automatic 24-hour expiration to improve performance\",\"purpose\":\"Provides fast access to previous analysis results without re-running expensive operations\",\"role\":\"Caching layer\"},{\"path\":\"src/domain/services/incrementalAnalysisService.ts\",\"description\":\"Supports iterative analysis workflows where the system makes multiple rounds of file requests and code searches until sufficient context is gathered\",\"purpose\":\"Enables AI agents to explore codebases incrementally by requesting files and performing searches across multiple iterations\",\"role\":\"Iterative workflow support\"}],\"exampleInput\":{\"description\":\"Example configuration and analysis request showing how users configure the extension and trigger analysis\",\"json\":\"{\\\"configuration\\\":{\\\"llmProvider\\\":\\\"openai\\\",\\\"openaiApiKey\\\":\\\"sk-...\\\",\\\"model\\\":\\\"gpt-4\\\",\\\"autoAnalyzeOnSave\\\":true,\\\"severityThresholds\\\":{\\\"error\\\":8,\\\"warning\\\":5,\\\"info\\\":3}},\\\"analysisRequest\\\":{\\\"type\\\":\\\"workspace\\\",\\\"includeTests\\\":true,\\\"generateDocumentation\\\":true,\\\"documentationTypes\\\":[\\\"product\\\",\\\"architecture\\\",\\\"refactoring\\\"]}}\"},\"exampleOutput\":{\"description\":\"Example analysis result showing detected issues, generated insights, and documentation structure\",\"json\":\"{\\\"analysisResult\\\":{\\\"totalFiles\\\":127,\\\"totalFunctions\\\":843,\\\"issuesFound\\\":{\\\"errors\\\":3,\\\"warnings\\\":12,\\\"info\\\":8},\\\"insights\\\":[{\\\"type\\\":\\\"circular_dependency\\\",\\\"severity\\\":\\\"error\\\",\\\"message\\\":\\\"Circular dependency detected between UserService and AuthService\\\",\\\"locations\\\":[{\\\"file\\\":\\\"src/services/UserService.ts\\\",\\\"line\\\":15},{\\\"file\\\":\\\"src/services/AuthService.ts\\\",\\\"line\\\":23}]},{\\\"type\\\":\\\"untested_function\\\",\\\"severity\\\":\\\"warning\\\",\\\"message\\\":\\\"Function calculateDiscount has no test coverage\\\",\\\"location\\\":{\\\"file\\\":\\\"src/utils/pricing.ts\\\",\\\"line\\\":45}}],\\\"documentation\\\":{\\\"product\\\":{\\\"overview\\\":\\\"E-commerce platform that enables users to browse products, manage shopping carts, and complete purchases with integrated payment processing\\\",\\\"features\\\":[\\\"Product search and filtering\\\",\\\"Shopping cart management\\\",\\\"Secure checkout and payment\\\",\\\"Order tracking\\\"],\\\"generatedAt\\\":\\\"2024-01-15T14:30:00Z\\\"},\\\"architecture\\\":{\\\"components\\\":[{\\\"name\\\":\\\"API Layer\\\",\\\"purpose\\\":\\\"Handles HTTP requests and routes them to appropriate services\\\"},{\\\"name\\\":\\\"Service Layer\\\",\\\"purpose\\\":\\\"Contains business logic for cart management, orders, and payments\\\"}],\\\"generatedAt\\\":\\\"2024-01-15T14:32:00Z\\\"}},\\\"reports\\\":{\\\"workspace\\\":{\\\"available\\\":true,\\\"path\\\":\\\".shadow/reports/workspace-summary.html\\\",\\\"generatedAt\\\":\\\"2024-01-15T14:30:00Z\\\"},\\\"refactoring\\\":{\\\"available\\\":true,\\\"path\\\":\\\".shadow/reports/refactoring-guide.html\\\",\\\"generatedAt\\\":\\\"2024-01-15T14:35:00Z\\\"}}},\\\"cacheStatus\\\":{\\\"cached\\\":true,\\\"expiresAt\\\":\\\"2024-01-16T14:30:00Z\\\"}}\"}}",
  "_metadata": {
    "generatedAt": "2025-11-19T21:29:53.921Z",
    "generatedAtLocal": "11/19/2025, 1:29:53 PM",
    "runId": "product-docs-2025-11-19T21-12-36-003Z"
  }
}