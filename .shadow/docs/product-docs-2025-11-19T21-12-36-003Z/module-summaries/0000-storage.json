{
  "module": "src/storage",
  "moduleType": "other",
  "capabilities": [
    "Automatically save data to disk with timestamps for version tracking",
    "Incrementally save multiple versions of data with iteration numbers",
    "Preserve historical data across saves with timestamped file naming",
    "Store data in both JSON and optional Markdown formats",
    "Retrieve the most recent saved version of data",
    "Track when data was generated through automatic timestamping"
  ],
  "summary": "The storage module provides a generic incremental storage system that automatically manages versioned data persistence to disk. It handles the complexity of saving data with timestamps and iteration numbers, ensuring that all historical versions are preserved for audit trails and recovery purposes.\n\nUsers can save data incrementally without worrying about overwriting previous versions - each save creates a new timestamped file while maintaining the previous versions. The module supports both JSON format for structured data and optional Markdown format for human-readable documentation. When retrieving data, users automatically get the most recent version, but all historical versions remain accessible through their timestamped filenames.\n\nThis module is ideal for workflows that require data versioning, audit trails, or the ability to track changes over time. Common use cases include saving analysis results, configuration snapshots, or any data that needs to be preserved across multiple iterations with automatic timestamp tracking.",
  "files": [
    {
      "file": "src/storage/incrementalStorage.ts",
      "role": "Core Logic",
      "purpose": "Provides a generic storage system for saving and loading timestamped data incrementally to disk in JSON and optionally Markdown formats.",
      "userVisibleActions": [
        "Data is automatically saved to disk with timestamps for tracking when it was generated",
        "Multiple versions of data can be saved incrementally with iteration numbers",
        "Data can be retrieved from the most recent saved version",
        "Previously saved data is preserved in timestamped files for historical tracking"
      ],
      "developerVisibleActions": [
        "Create a storage instance configured for specific data types with custom prefixes and directories",
        "Save typed data objects with optional metadata like iteration number, run ID, and timestamps",
        "Load the most recent saved data automatically based on filename patterns",
        "Store data in both JSON and Markdown formats simultaneously when configured",
        "Organize saved files into subdirectories with customizable naming patterns",
        "Access saved file paths and metadata for debugging or reporting",
        "Handle storage errors through the ErrorHandler utility"
      ],
      "keyFunctions": [
        {
          "name": "save",
          "desc": "Saves data to disk with metadata, creating timestamped files with optional iteration numbers",
          "inputs": "data: T (generic typed data), metadata?: StorageMetadata (timestamps, iteration, runId, etc.)",
          "outputs": "Promise<void>"
        },
        {
          "name": "load",
          "desc": "Loads the most recently saved data from disk based on file patterns",
          "inputs": "None",
          "outputs": "Promise<{data: T, metadata: StorageMetadata} | null>"
        },
        {
          "name": "getFilePath",
          "desc": "Generates the file path for saving data based on metadata and configuration",
          "inputs": "metadata?: StorageMetadata",
          "outputs": "string (file path)"
        },
        {
          "name": "getLatestFile",
          "desc": "Finds the most recent file matching the storage pattern in the directory",
          "inputs": "None",
          "outputs": "string | null (file path)"
        },
        {
          "name": "ensureDirectory",
          "desc": "Creates the storage directory structure if it doesn't exist",
          "inputs": "None",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "ErrorHandler"
      ],
      "intent": "This file exists to eliminate code duplication across different storage operations by providing a reusable, type-safe storage system. It solves the problem of consistently saving and retrieving timestamped data with metadata, supporting incremental workflows where multiple versions of data need to be preserved and tracked over time. It standardizes file naming, directory organization, and metadata handling across the application.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a generic storage system for saving and loading timestamped data incrementally to disk in JSON and optionally Markdown formats.\",\n  \"userVisibleActions\": [\n    \"Data is automatically saved to disk with timestamps for tracking when it was generated\",\n    \"Multiple versions of data can be saved incrementally with iteration numbers\",\n    \"Data can be retrieved from the most recent saved version\",\n    \"Previously saved data is preserved in timestamped files for historical tracking\"\n  ],\n  \"developerVisibleActions\": [\n    \"Create a storage instance configured for specific data types with custom prefixes and directories\",\n    \"Save typed data objects with optional metadata like iteration number, run ID, and timestamps\",\n    \"Load the most recent saved data automatically based on filename patterns\",\n    \"Store data in both JSON and Markdown formats simultaneously when configured\",\n    \"Organize saved files into subdirectories with customizable naming patterns\",\n    \"Access saved file paths and metadata for debugging or reporting\",\n    \"Handle storage errors through the ErrorHandler utility\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"save\",\n      \"desc\": \"Saves data to disk with metadata, creating timestamped files with optional iteration numbers\",\n      \"inputs\": \"data: T (generic typed data), metadata?: StorageMetadata (timestamps, iteration, runId, etc.)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"load\",\n      \"desc\": \"Loads the most recently saved data from disk based on file patterns\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Promise<{data: T, metadata: StorageMetadata} | null>\"\n    },\n    {\n      \"name\": \"getFilePath\",\n      \"desc\": \"Generates the file path for saving data based on metadata and configuration\",\n      \"inputs\": \"metadata?: StorageMetadata\",\n      \"outputs\": \"string (file path)\"\n    },\n    {\n      \"name\": \"getLatestFile\",\n      \"desc\": \"Finds the most recent file matching the storage pattern in the directory\",\n      \"inputs\": \"None\",\n      \"outputs\": \"string | null (file path)\"\n    },\n    {\n      \"name\": \"ensureDirectory\",\n      \"desc\": \"Creates the storage directory structure if it doesn't exist\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"ErrorHandler\"\n  ],\n  \"intent\": \"This file exists to eliminate code duplication across different storage operations by providing a reusable, type-safe storage system. It solves the problem of consistently saving and retrieving timestamped data with metadata, supporting incremental workflows where multiple versions of data need to be preserved and tracked over time. It standardizes file naming, directory organization, and metadata handling across the application.\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-19T21:27:33.236Z"
  }
}