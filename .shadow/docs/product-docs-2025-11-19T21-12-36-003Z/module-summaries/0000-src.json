{
  "module": "src",
  "moduleType": "other",
  "capabilities": [
    "Automated code analysis and insights generation for TypeScript/JavaScript codebases",
    "AI-powered documentation generation using LLM integration (OpenAI/Claude)",
    "Real-time diagnostic reporting in VS Code's Problems panel",
    "Multiple specialized tree views for browsing code structure, insights, and reports",
    "Product-centric navigation organizing code by features instead of file structure",
    "Static analysis issue detection and reporting",
    "Code complexity and quality metrics tracking",
    "Duplicate code detection across files",
    "Test coverage gap identification",
    "Cached analysis results with automatic expiration",
    "File system monitoring with auto-analysis on save",
    "LLM-ready context generation for AI assistants"
  ],
  "summary": "Shadow Watch is a comprehensive VS Code extension that provides intelligent code analysis and documentation capabilities for TypeScript/JavaScript projects. It analyzes your codebase to identify code quality issues, architectural patterns, complexity metrics, and potential problems like orphaned files, circular dependencies, and untested functions. The extension integrates with AI services (OpenAI/Claude) to generate human-readable documentation, architectural insights, and refactoring suggestions based on the analysis results.\n\nThe extension provides multiple specialized views within VS Code's sidebar, including an Analysis Viewer showing statistics and code structure, an Insights Viewer displaying AI-generated architectural analysis, a Product Navigator organizing code by functionality rather than file structure, a Static Analysis Viewer for browsing issues by severity, and a Reports tree for accessing generated documentation. All findings are also surfaced through VS Code's native Problems panel with clickable diagnostics that navigate directly to problem locations.\n\nShadow Watch supports both manual and automatic analysis workflows. Users can trigger analysis on-demand through commands, or enable automatic analysis on file save for continuous feedback. Analysis results are cached for 24 hours to provide instant access when reopening workspaces. The extension also provides specialized features for LLM agents, including file reading capabilities and grep search functionality, enabling AI assistants to iteratively explore and understand codebases.",
  "files": [
    {
      "file": "src/analysisViewer.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view panel that displays code analysis results including statistics, files, functions, and entry points in a browsable hierarchical structure",
      "userVisibleActions": [
        "View a tree structure showing code analysis results in the sidebar",
        "Browse statistics about the analyzed codebase (file count, line count, function count)",
        "Navigate through files and directories in the analysis",
        "See file details including line count, function count, import/export count, and complexity",
        "Browse all functions with their metadata (lines of code, complexity, parameters)",
        "View entry points (main functions, exported items, test files)",
        "Click on items to jump to their location in the source code",
        "See grouped views of files by directory structure",
        "See message 'No analysis available' when no analysis has been run yet",
        "Refresh the tree view to see updated analysis results"
      ],
      "developerVisibleActions": [
        "Set analysis data by calling setAnalysis() to populate the tree view",
        "Manually refresh the tree view by calling refresh()",
        "Receive click events when users select items in the tree",
        "Display hierarchical analysis data organized by categories (statistics, files, functions, entry points)",
        "Show tooltips with additional information on hover",
        "Handle navigation to specific file locations when items are clicked",
        "Display icons for different item types (files, functions, directories, statistics)",
        "Organize files by directory structure for easier navigation"
      ],
      "keyFunctions": [
        {
          "name": "setAnalysis",
          "desc": "Sets the code analysis data to display in the tree view and triggers a refresh",
          "inputs": "analysis: CodeAnalysis | null",
          "outputs": "void"
        },
        {
          "name": "refresh",
          "desc": "Refreshes the tree view to update displayed data",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getTreeItem",
          "desc": "Returns the tree item representation for display in VS Code",
          "inputs": "element: AnalysisItem",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child items for a given tree node to build the hierarchy",
          "inputs": "element?: AnalysisItem",
          "outputs": "Thenable<AnalysisItem[]>"
        },
        {
          "name": "getRootItems",
          "desc": "Returns top-level categories shown in the tree (statistics, files, functions, entry points)",
          "inputs": "none",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getStatisticsItems",
          "desc": "Returns statistical summary items (total files, lines, functions, etc.)",
          "inputs": "none",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getFilesItems",
          "desc": "Returns all analyzed files organized by directory structure",
          "inputs": "none",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getFileDetails",
          "desc": "Returns detailed information about a specific file (line count, functions, imports, exports)",
          "inputs": "element: AnalysisItem",
          "outputs": "AnalysisItem[]"
        },
        {
          "name": "getDirectoryFiles",
          "desc": "Returns all files within a specific directory",
          "inputs": "element: AnalysisItem",
          "outputs": "AnalysisItem[]"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "./analyzer (CodeAnalysis, FileInfo, FunctionInfo, EntryPoint types)"
      ],
      "intent": "This file exists to provide developers with an interactive, browsable view of their codebase analysis results directly in VS Code's sidebar, making it easy to explore code metrics, navigate to specific functions or files, and understand the structure and complexity of their project at a glance",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view panel that displays code analysis results including statistics, files, functions, and entry points in a browsable hierarchical structure\",\n  \"userVisibleActions\": [\n    \"View a tree structure showing code analysis results in the sidebar\",\n    \"Browse statistics about the analyzed codebase (file count, line count, function count)\",\n    \"Navigate through files and directories in the analysis\",\n    \"See file details including line count, function count, import/export count, and complexity\",\n    \"Browse all functions with their metadata (lines of code, complexity, parameters)\",\n    \"View entry points (main functions, exported items, test files)\",\n    \"Click on items to jump to their location in the source code\",\n    \"See grouped views of files by directory structure\",\n    \"See message 'No analysis available' when no analysis has been run yet\",\n    \"Refresh the tree view to see updated analysis results\"\n  ],\n  \"developerVisibleActions\": [\n    \"Set analysis data by calling setAnalysis() to populate the tree view\",\n    \"Manually refresh the tree view by calling refresh()\",\n    \"Receive click events when users select items in the tree\",\n    \"Display hierarchical analysis data organized by categories (statistics, files, functions, entry points)\",\n    \"Show tooltips with additional information on hover\",\n    \"Handle navigation to specific file locations when items are clicked\",\n    \"Display icons for different item types (files, functions, directories, statistics)\",\n    \"Organize files by directory structure for easier navigation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setAnalysis\",\n      \"desc\": \"Sets the code analysis data to display in the tree view and triggers a refresh\",\n      \"inputs\": \"analysis: CodeAnalysis | null\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Refreshes the tree view to update displayed data\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the tree item representation for display in VS Code\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for a given tree node to build the hierarchy\",\n      \"inputs\": \"element?: AnalysisItem\",\n      \"outputs\": \"Thenable<AnalysisItem[]>\"\n    },\n    {\n      \"name\": \"getRootItems\",\n      \"desc\": \"Returns top-level categories shown in the tree (statistics, files, functions, entry points)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getStatisticsItems\",\n      \"desc\": \"Returns statistical summary items (total files, lines, functions, etc.)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getFilesItems\",\n      \"desc\": \"Returns all analyzed files organized by directory structure\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getFileDetails\",\n      \"desc\": \"Returns detailed information about a specific file (line count, functions, imports, exports)\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"AnalysisItem[]\"\n    },\n    {\n      \"name\": \"getDirectoryFiles\",\n      \"desc\": \"Returns all files within a specific directory\",\n      \"inputs\": \"element: AnalysisItem\",\n      \"outputs\": \"AnalysisItem[]\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./analyzer (CodeAnalysis, FileInfo, FunctionInfo, EntryPoint types)\"\n  ],\n  \"intent\": \"This file exists to provide developers with an interactive, browsable view of their codebase analysis results directly in VS Code's sidebar, making it easy to explore code metrics, navigate to specific functions or files, and understand the structure and complexity of their project at a glance\"\n}\n```"
    },
    {
      "file": "src/analyzer.ts",
      "role": "Core Logic",
      "purpose": "Defines the core data structures and interfaces for code analysis results, including file metadata, function signatures, dependencies, test mappings, and code duplication detection.",
      "userVisibleActions": [
        "See analysis results showing total files, lines, and functions in their codebase",
        "View list of large files that may need refactoring",
        "Identify orphaned files that are not imported anywhere",
        "Discover entry points (main functions) in the codebase",
        "Find duplicate code blocks across files",
        "See which functions are not covered by tests",
        "View function complexity and risk levels (high/medium/low)",
        "Understand function dependencies on databases, HTTP, filesystem, and other external resources"
      ],
      "developerVisibleActions": [
        "Import and use CodeAnalysis interface to structure analysis results",
        "Access file information including path, lines of code, complexity metrics, and roles",
        "Query function metadata including parameters, return types, visibility, and documentation",
        "Retrieve import relationships between files to understand module dependencies",
        "Access test mapping data to see which tests cover which source files and functions",
        "Use FunctionMetadata to get detailed function signatures, branches, and state mutations",
        "Access duplicate code detection results grouped by similarity hash",
        "Query dependency information to identify external service integrations",
        "Use AnalysisCache for caching and retrieving analysis results"
      ],
      "keyFunctions": [
        {
          "name": "CodeAnalysis",
          "desc": "Primary interface containing complete codebase analysis results",
          "inputs": "None (interface definition)",
          "outputs": "Structured data with file counts, function lists, imports, orphaned files, entry points, duplicates, and optional enhanced metadata"
        },
        {
          "name": "FunctionMetadata",
          "desc": "Detailed metadata for a single function including signature, documentation, control flow, and dependencies",
          "inputs": "None (interface definition)",
          "outputs": "Function name, parameters, return type, visibility, branches, dependencies, state mutations, risk level, and line numbers"
        },
        {
          "name": "TestMapping",
          "desc": "Maps source files and functions to their corresponding test coverage",
          "inputs": "None (interface definition)",
          "outputs": "Source-to-test file mappings, function-to-test mappings, and list of uncovered functions"
        },
        {
          "name": "DependencyInfo",
          "desc": "Describes external and internal dependencies used by functions",
          "inputs": "None (interface definition)",
          "outputs": "Dependency name, type (db/http/filesystem/etc), whether it's internal, and line number"
        },
        {
          "name": "BranchInfo",
          "desc": "Represents control flow branches in code (if/else/loop/try/catch)",
          "inputs": "None (interface definition)",
          "outputs": "Branch type, human-readable condition description, and line number"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./cache"
      ],
      "intent": "This file exists to establish a standardized schema for code analysis results across the entire application. It solves the problem of consistently representing complex code structure information (functions, dependencies, tests, duplicates) in a way that different parts of the system can understand and use, enabling features like test coverage visualization, dependency tracking, code quality assessment, and duplicate detection.",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines the core data structures and interfaces for code analysis results, including file metadata, function signatures, dependencies, test mappings, and code duplication detection.\",\n  \"userVisibleActions\": [\n    \"See analysis results showing total files, lines, and functions in their codebase\",\n    \"View list of large files that may need refactoring\",\n    \"Identify orphaned files that are not imported anywhere\",\n    \"Discover entry points (main functions) in the codebase\",\n    \"Find duplicate code blocks across files\",\n    \"See which functions are not covered by tests\",\n    \"View function complexity and risk levels (high/medium/low)\",\n    \"Understand function dependencies on databases, HTTP, filesystem, and other external resources\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import and use CodeAnalysis interface to structure analysis results\",\n    \"Access file information including path, lines of code, complexity metrics, and roles\",\n    \"Query function metadata including parameters, return types, visibility, and documentation\",\n    \"Retrieve import relationships between files to understand module dependencies\",\n    \"Access test mapping data to see which tests cover which source files and functions\",\n    \"Use FunctionMetadata to get detailed function signatures, branches, and state mutations\",\n    \"Access duplicate code detection results grouped by similarity hash\",\n    \"Query dependency information to identify external service integrations\",\n    \"Use AnalysisCache for caching and retrieving analysis results\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"CodeAnalysis\",\n      \"desc\": \"Primary interface containing complete codebase analysis results\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Structured data with file counts, function lists, imports, orphaned files, entry points, duplicates, and optional enhanced metadata\"\n    },\n    {\n      \"name\": \"FunctionMetadata\",\n      \"desc\": \"Detailed metadata for a single function including signature, documentation, control flow, and dependencies\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Function name, parameters, return type, visibility, branches, dependencies, state mutations, risk level, and line numbers\"\n    },\n    {\n      \"name\": \"TestMapping\",\n      \"desc\": \"Maps source files and functions to their corresponding test coverage\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Source-to-test file mappings, function-to-test mappings, and list of uncovered functions\"\n    },\n    {\n      \"name\": \"DependencyInfo\",\n      \"desc\": \"Describes external and internal dependencies used by functions\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Dependency name, type (db/http/filesystem/etc), whether it's internal, and line number\"\n    },\n    {\n      \"name\": \"BranchInfo\",\n      \"desc\": \"Represents control flow branches in code (if/else/loop/try/catch)\",\n      \"inputs\": \"None (interface definition)\",\n      \"outputs\": \"Branch type, human-readable condition description, and line number\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./cache\"\n  ],\n  \"intent\": \"This file exists to establish a standardized schema for code analysis results across the entire application. It solves the problem of consistently representing complex code structure information (functions, dependencies, tests, duplicates) in a way that different parts of the system can understand and use, enabling features like test coverage visualization, dependency tracking, code quality assessment, and duplicate detection.\"\n}\n```"
    },
    {
      "file": "src/cache.ts",
      "role": "Core Logic",
      "purpose": "Manages persistent storage and retrieval of code analysis results with automatic expiration",
      "userVisibleActions": [
        "Analysis results load instantly when reopening a workspace (if cached within 24 hours)",
        "Analysis cache automatically expires after 24 hours, triggering fresh analysis",
        "Cache can be manually cleared to force fresh analysis"
      ],
      "developerVisibleActions": [
        "Cache directory (.shadowwatch-cache) is created in the specified storage path",
        "Analysis results are automatically saved after each analysis completes",
        "Cache files are named using base64-encoded workspace paths",
        "Stale cache entries (older than 24 hours) are automatically ignored",
        "Cache read/write errors are logged to console but don't block operations"
      ],
      "keyFunctions": [
        {
          "name": "constructor",
          "desc": "Initializes cache with storage location and creates cache directory",
          "inputs": "storagePath: string",
          "outputs": "AnalysisCache instance"
        },
        {
          "name": "getCacheKey",
          "desc": "Generates safe filename from workspace path for cache storage",
          "inputs": "workspaceRoot: string",
          "outputs": "base64-encoded string suitable for filename"
        },
        {
          "name": "get",
          "desc": "Retrieves cached analysis for workspace if exists and not expired",
          "inputs": "workspaceRoot: string",
          "outputs": "Promise<CodeAnalysis | null> - cached data or null if missing/expired"
        },
        {
          "name": "set",
          "desc": "Saves analysis results to cache with current timestamp",
          "inputs": "workspaceRoot: string, data: CodeAnalysis",
          "outputs": "Promise<void>"
        },
        {
          "name": "clear",
          "desc": "Removes all cached analysis files from cache directory",
          "inputs": "none",
          "outputs": "Promise<void>"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./analyzer (CodeAnalysis type)"
      ],
      "intent": "Improves extension performance by caching expensive code analysis results, avoiding redundant analysis when reopening workspaces while ensuring cached data doesn't become stale through time-based expiration",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages persistent storage and retrieval of code analysis results with automatic expiration\",\n  \"userVisibleActions\": [\n    \"Analysis results load instantly when reopening a workspace (if cached within 24 hours)\",\n    \"Analysis cache automatically expires after 24 hours, triggering fresh analysis\",\n    \"Cache can be manually cleared to force fresh analysis\"\n  ],\n  \"developerVisibleActions\": [\n    \"Cache directory (.shadowwatch-cache) is created in the specified storage path\",\n    \"Analysis results are automatically saved after each analysis completes\",\n    \"Cache files are named using base64-encoded workspace paths\",\n    \"Stale cache entries (older than 24 hours) are automatically ignored\",\n    \"Cache read/write errors are logged to console but don't block operations\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes cache with storage location and creates cache directory\",\n      \"inputs\": \"storagePath: string\",\n      \"outputs\": \"AnalysisCache instance\"\n    },\n    {\n      \"name\": \"getCacheKey\",\n      \"desc\": \"Generates safe filename from workspace path for cache storage\",\n      \"inputs\": \"workspaceRoot: string\",\n      \"outputs\": \"base64-encoded string suitable for filename\"\n    },\n    {\n      \"name\": \"get\",\n      \"desc\": \"Retrieves cached analysis for workspace if exists and not expired\",\n      \"inputs\": \"workspaceRoot: string\",\n      \"outputs\": \"Promise<CodeAnalysis | null> - cached data or null if missing/expired\"\n    },\n    {\n      \"name\": \"set\",\n      \"desc\": \"Saves analysis results to cache with current timestamp\",\n      \"inputs\": \"workspaceRoot: string, data: CodeAnalysis\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all cached analysis files from cache directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer (CodeAnalysis type)\"\n  ],\n  \"intent\": \"Improves extension performance by caching expensive code analysis results, avoiding redundant analysis when reopening workspaces while ensuring cached data doesn't become stale through time-based expiration\"\n}\n```"
    },
    {
      "file": "src/diagnosticsProvider.ts",
      "role": "Core Logic",
      "purpose": "Manages and displays code diagnostics (warnings, errors, info messages) in the VS Code Problems panel based on insights generated from code analysis",
      "userVisibleActions": [
        "Shows diagnostic messages (warnings, errors, info) in the Problems panel for issues found in code files",
        "Displays colored underlines or squiggles in code editor at specific line numbers where issues are detected",
        "Groups diagnostic messages by file in the Problems panel",
        "Shows 'Shadow Watch' as the source of diagnostic messages",
        "Clears all diagnostic messages when requested",
        "Updates diagnostics in real-time as insights are generated"
      ],
      "developerVisibleActions": [
        "Creates a diagnostic collection named 'shadowWatch' that appears in the Problems panel",
        "Converts Insight objects into VS Code Diagnostic objects that integrate with the editor",
        "Updates diagnostics for all files or for a specific file based on insight data",
        "Maps insight severity levels to VS Code diagnostic severity (Error, Warning, Information, Hint)",
        "Positions diagnostics at specific line numbers extracted from insights",
        "Clears diagnostics when analysis is reset or updated",
        "Provides cleanup through dispose method for proper resource management"
      ],
      "keyFunctions": [
        {
          "name": "updateDiagnostics",
          "desc": "Updates diagnostics for all files based on an array of insights",
          "inputs": "insights: Insight[] - Array of insight objects containing file paths, line numbers, descriptions, and severity",
          "outputs": "void - Displays diagnostics in Problems panel"
        },
        {
          "name": "updateDiagnosticsForFile",
          "desc": "Updates diagnostics for a specific file only",
          "inputs": "uri: vscode.Uri - File URI, insights: Insight[] - Insights for that file",
          "outputs": "void - Displays diagnostics for the specified file"
        },
        {
          "name": "clear",
          "desc": "Removes all diagnostics from the Problems panel",
          "inputs": "None",
          "outputs": "void"
        },
        {
          "name": "createDiagnostic",
          "desc": "Converts an Insight object into a VS Code Diagnostic object",
          "inputs": "insight: Insight - Contains description, severity, line number, file path, and ID",
          "outputs": "vscode.Diagnostic - VS Code diagnostic that appears in Problems panel and editor"
        },
        {
          "name": "getSeverity",
          "desc": "Maps insight severity string to VS Code DiagnosticSeverity enum",
          "inputs": "severity: string - Severity level from insight",
          "outputs": "vscode.DiagnosticSeverity - VS Code severity enum value"
        },
        {
          "name": "dispose",
          "desc": "Cleans up and disposes the diagnostic collection",
          "inputs": "None",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "./insightGenerator"
      ],
      "intent": "This file exists to bridge the gap between code analysis insights and VS Code's built-in diagnostics system, allowing code issues to be displayed natively in the Problems panel and editor with proper formatting, severity levels, and file grouping - giving users a familiar interface for viewing and navigating code issues discovered by Shadow Watch",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages and displays code diagnostics (warnings, errors, info messages) in the VS Code Problems panel based on insights generated from code analysis\",\n  \"userVisibleActions\": [\n    \"Shows diagnostic messages (warnings, errors, info) in the Problems panel for issues found in code files\",\n    \"Displays colored underlines or squiggles in code editor at specific line numbers where issues are detected\",\n    \"Groups diagnostic messages by file in the Problems panel\",\n    \"Shows 'Shadow Watch' as the source of diagnostic messages\",\n    \"Clears all diagnostic messages when requested\",\n    \"Updates diagnostics in real-time as insights are generated\"\n  ],\n  \"developerVisibleActions\": [\n    \"Creates a diagnostic collection named 'shadowWatch' that appears in the Problems panel\",\n    \"Converts Insight objects into VS Code Diagnostic objects that integrate with the editor\",\n    \"Updates diagnostics for all files or for a specific file based on insight data\",\n    \"Maps insight severity levels to VS Code diagnostic severity (Error, Warning, Information, Hint)\",\n    \"Positions diagnostics at specific line numbers extracted from insights\",\n    \"Clears diagnostics when analysis is reset or updated\",\n    \"Provides cleanup through dispose method for proper resource management\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"updateDiagnostics\",\n      \"desc\": \"Updates diagnostics for all files based on an array of insights\",\n      \"inputs\": \"insights: Insight[] - Array of insight objects containing file paths, line numbers, descriptions, and severity\",\n      \"outputs\": \"void - Displays diagnostics in Problems panel\"\n    },\n    {\n      \"name\": \"updateDiagnosticsForFile\",\n      \"desc\": \"Updates diagnostics for a specific file only\",\n      \"inputs\": \"uri: vscode.Uri - File URI, insights: Insight[] - Insights for that file\",\n      \"outputs\": \"void - Displays diagnostics for the specified file\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all diagnostics from the Problems panel\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"createDiagnostic\",\n      \"desc\": \"Converts an Insight object into a VS Code Diagnostic object\",\n      \"inputs\": \"insight: Insight - Contains description, severity, line number, file path, and ID\",\n      \"outputs\": \"vscode.Diagnostic - VS Code diagnostic that appears in Problems panel and editor\"\n    },\n    {\n      \"name\": \"getSeverity\",\n      \"desc\": \"Maps insight severity string to VS Code DiagnosticSeverity enum\",\n      \"inputs\": \"severity: string - Severity level from insight\",\n      \"outputs\": \"vscode.DiagnosticSeverity - VS Code severity enum value\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up and disposes the diagnostic collection\",\n      \"inputs\": \"None\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between code analysis insights and VS Code's built-in diagnostics system, allowing code issues to be displayed natively in the Problems panel and editor with proper formatting, severity levels, and file grouping - giving users a familiar interface for viewing and navigating code issues discovered by Shadow Watch\"\n}\n```"
    },
    {
      "file": "src/extension.ts",
      "role": "Core Logic",
      "purpose": "Main entry point that initializes and coordinates the code analysis extension, registering all commands and UI components.",
      "userVisibleActions": [
        "Click 'Analyze Code' command to scan current workspace and show insights",
        "View code analysis results in a tree view panel",
        "See diagnostic warnings/errors in the Problems panel",
        "Navigate through product features via Product Navigator tree view",
        "Browse analysis results in Analysis Viewer webview",
        "View AI-generated insights in Insights Viewer webview",
        "Explore static analysis findings in Static Analysis Viewer",
        "Access unit test information via Unit Tests Navigator",
        "See analysis status in status bar with loading indicator",
        "Open specific files by clicking items in tree views",
        "Auto-refresh analysis when files change in workspace",
        "Generate LLM-ready context from code analysis",
        "Copy formatted analysis to clipboard for AI assistants"
      ],
      "developerVisibleActions": [
        "Extension activates when VS Code starts or workspace opens",
        "Registers multiple tree view providers for different perspectives",
        "Initializes code analyzer to parse TypeScript/JavaScript files",
        "Sets up file watcher to detect code changes automatically",
        "Creates diagnostics provider to surface code issues",
        "Establishes cache layer for performance optimization",
        "Bootstraps all extension components and dependencies",
        "Registers command palette commands for analysis actions",
        "Manages configuration through VS Code settings",
        "Handles errors and logs them appropriately",
        "Disposes resources on extension deactivation"
      ],
      "keyFunctions": [
        {
          "name": "activate",
          "desc": "Entry point that initializes extension, creates all components, and registers commands",
          "inputs": "vscode.ExtensionContext",
          "outputs": "void"
        },
        {
          "name": "deactivate",
          "desc": "Cleanup function that disposes resources when extension shuts down",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "runAnalysis",
          "desc": "Executes code analysis on workspace and updates all views with results",
          "inputs": "workspace folder path",
          "outputs": "analysis results object"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "./analyzer",
        "./insightGenerator",
        "./llmFormatter",
        "./fileWatcher",
        "./insightsTreeView",
        "./diagnosticsProvider",
        "./cache",
        "./llmIntegration",
        "./productNavigator",
        "./analysisViewer",
        "./insightsViewer",
        "./staticAnalysisViewer",
        "./unitTestsNavigator",
        "./config/configurationManager",
        "./utils/errorHandler",
        "./ui/webview/webviewTemplateEngine",
        "./domain/bootstrap/extensionBootstrapper",
        "./domain/bootstrap/commandRegistry",
        "./domain/handlers/navigationHandler"
      ],
      "intent": "This file exists to orchestrate the entire code analysis extension by wiring together all components (analyzers, viewers, generators) and exposing them through VS Code's command palette and UI panels. It solves the problem of coordinating complex analysis workflows and presenting results through multiple specialized views.",
      "rawContent": "```json\n{\n  \"purpose\": \"Main entry point that initializes and coordinates the code analysis extension, registering all commands and UI components.\",\n  \"userVisibleActions\": [\n    \"Click 'Analyze Code' command to scan current workspace and show insights\",\n    \"View code analysis results in a tree view panel\",\n    \"See diagnostic warnings/errors in the Problems panel\",\n    \"Navigate through product features via Product Navigator tree view\",\n    \"Browse analysis results in Analysis Viewer webview\",\n    \"View AI-generated insights in Insights Viewer webview\",\n    \"Explore static analysis findings in Static Analysis Viewer\",\n    \"Access unit test information via Unit Tests Navigator\",\n    \"See analysis status in status bar with loading indicator\",\n    \"Open specific files by clicking items in tree views\",\n    \"Auto-refresh analysis when files change in workspace\",\n    \"Generate LLM-ready context from code analysis\",\n    \"Copy formatted analysis to clipboard for AI assistants\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extension activates when VS Code starts or workspace opens\",\n    \"Registers multiple tree view providers for different perspectives\",\n    \"Initializes code analyzer to parse TypeScript/JavaScript files\",\n    \"Sets up file watcher to detect code changes automatically\",\n    \"Creates diagnostics provider to surface code issues\",\n    \"Establishes cache layer for performance optimization\",\n    \"Bootstraps all extension components and dependencies\",\n    \"Registers command palette commands for analysis actions\",\n    \"Manages configuration through VS Code settings\",\n    \"Handles errors and logs them appropriately\",\n    \"Disposes resources on extension deactivation\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"activate\",\n      \"desc\": \"Entry point that initializes extension, creates all components, and registers commands\",\n      \"inputs\": \"vscode.ExtensionContext\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"deactivate\",\n      \"desc\": \"Cleanup function that disposes resources when extension shuts down\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"runAnalysis\",\n      \"desc\": \"Executes code analysis on workspace and updates all views with results\",\n      \"inputs\": \"workspace folder path\",\n      \"outputs\": \"analysis results object\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./analyzer\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./fileWatcher\",\n    \"./insightsTreeView\",\n    \"./diagnosticsProvider\",\n    \"./cache\",\n    \"./llmIntegration\",\n    \"./productNavigator\",\n    \"./analysisViewer\",\n    \"./insightsViewer\",\n    \"./staticAnalysisViewer\",\n    \"./unitTestsNavigator\",\n    \"./config/configurationManager\",\n    \"./utils/errorHandler\",\n    \"./ui/webview/webviewTemplateEngine\",\n    \"./domain/bootstrap/extensionBootstrapper\",\n    \"./domain/bootstrap/commandRegistry\",\n    \"./domain/handlers/navigationHandler\"\n  ],\n  \"intent\": \"This file exists to orchestrate the entire code analysis extension by wiring together all components (analyzers, viewers, generators) and exposing them through VS Code's command palette and UI panels. It solves the problem of coordinating complex analysis workflows and presenting results through multiple specialized views.\"\n}\n```"
    },
    {
      "file": "src/fileAccessHelper.ts",
      "role": "Core Logic",
      "purpose": "Provides file reading and grep search functionality to enable iterative analysis of codebases by LLM agents",
      "userVisibleActions": [
        "LLM can request to read specific files from the workspace",
        "LLM can search for code patterns across multiple files using grep",
        "LLM receives file contents with line counts and existence status",
        "LLM receives search results with matching lines and context",
        "Search results are limited to prevent overwhelming the LLM with too many matches"
      ],
      "developerVisibleActions": [
        "Developer provides workspace root path to initialize file access",
        "Developer can request file contents by specifying file paths",
        "Developer can search codebase using regex patterns with optional file filters",
        "Developer receives structured responses with file metadata (lines, existence)",
        "Developer receives grep results with line numbers and surrounding context",
        "Developer can limit number of search results returned",
        "Developer can filter searches by file patterns (glob patterns like '*.ts')",
        "Developer receives organized file listings grouped by folder"
      ],
      "keyFunctions": [
        {
          "name": "getFileListing",
          "desc": "Organizes and formats a list of files grouped by their containing folders",
          "inputs": "Array of file objects with path, lines, and language",
          "outputs": "Formatted string with files organized by folder hierarchy"
        },
        {
          "name": "readFile",
          "desc": "Reads a file from the workspace and returns its content with metadata",
          "inputs": "File path relative to workspace root",
          "outputs": "FileResponse with content, line count, and existence status"
        },
        {
          "name": "grep",
          "desc": "Searches for a pattern across workspace files with optional filtering",
          "inputs": "Search pattern, optional file pattern filter, optional max results limit",
          "outputs": "GrepResponse with matches, line numbers, context, and limitation status"
        },
        {
          "name": "processRequest",
          "desc": "Routes and processes either file read or grep requests from LLM",
          "inputs": "LLMRequest (either FileRequest or GrepRequest)",
          "outputs": "Either FileResponse or GrepResponse depending on request type"
        }
      ],
      "dependencies": [
        "fs",
        "path"
      ],
      "intent": "This file exists to give LLM agents the ability to iteratively explore and analyze codebases by reading specific files and searching for patterns, enabling more thorough and targeted code understanding without loading entire codebases upfront",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides file reading and grep search functionality to enable iterative analysis of codebases by LLM agents\",\n  \"userVisibleActions\": [\n    \"LLM can request to read specific files from the workspace\",\n    \"LLM can search for code patterns across multiple files using grep\",\n    \"LLM receives file contents with line counts and existence status\",\n    \"LLM receives search results with matching lines and context\",\n    \"Search results are limited to prevent overwhelming the LLM with too many matches\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer provides workspace root path to initialize file access\",\n    \"Developer can request file contents by specifying file paths\",\n    \"Developer can search codebase using regex patterns with optional file filters\",\n    \"Developer receives structured responses with file metadata (lines, existence)\",\n    \"Developer receives grep results with line numbers and surrounding context\",\n    \"Developer can limit number of search results returned\",\n    \"Developer can filter searches by file patterns (glob patterns like '*.ts')\",\n    \"Developer receives organized file listings grouped by folder\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getFileListing\",\n      \"desc\": \"Organizes and formats a list of files grouped by their containing folders\",\n      \"inputs\": \"Array of file objects with path, lines, and language\",\n      \"outputs\": \"Formatted string with files organized by folder hierarchy\"\n    },\n    {\n      \"name\": \"readFile\",\n      \"desc\": \"Reads a file from the workspace and returns its content with metadata\",\n      \"inputs\": \"File path relative to workspace root\",\n      \"outputs\": \"FileResponse with content, line count, and existence status\"\n    },\n    {\n      \"name\": \"grep\",\n      \"desc\": \"Searches for a pattern across workspace files with optional filtering\",\n      \"inputs\": \"Search pattern, optional file pattern filter, optional max results limit\",\n      \"outputs\": \"GrepResponse with matches, line numbers, context, and limitation status\"\n    },\n    {\n      \"name\": \"processRequest\",\n      \"desc\": \"Routes and processes either file read or grep requests from LLM\",\n      \"inputs\": \"LLMRequest (either FileRequest or GrepRequest)\",\n      \"outputs\": \"Either FileResponse or GrepResponse depending on request type\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\"\n  ],\n  \"intent\": \"This file exists to give LLM agents the ability to iteratively explore and analyze codebases by reading specific files and searching for patterns, enabling more thorough and targeted code understanding without loading entire codebases upfront\"\n}\n```"
    },
    {
      "file": "src/fileDocumentation.ts",
      "role": "Core Logic",
      "purpose": "Defines the type system and data structures for organizing code documentation at file, module, and product levels.",
      "userVisibleActions": [
        "No direct user-visible actions - this file defines data structures used internally"
      ],
      "developerVisibleActions": [
        "Import and use TypeScript interfaces to structure documentation data",
        "Create FileSummary objects to document individual code files with role, purpose, and key functions",
        "Build ModuleSummary objects to organize files into logical modules with capabilities",
        "Generate EnhancedProductDocumentation with product overview, user perspectives, and architecture",
        "Access structured documentation data through well-defined TypeScript types",
        "Use these interfaces to ensure consistent documentation format across the codebase"
      ],
      "keyFunctions": [
        {
          "name": "FileSummary",
          "desc": "Interface defining how individual file documentation is structured",
          "inputs": "file path, role, purpose, actions, functions, dependencies",
          "outputs": "Structured file-level documentation object"
        },
        {
          "name": "ModuleSummary",
          "desc": "Interface defining how module-level documentation is structured",
          "inputs": "module path, type, capabilities, files, endpoints/commands/workers",
          "outputs": "Structured module-level documentation object"
        },
        {
          "name": "EnhancedProductDocumentation",
          "desc": "Interface defining complete product documentation structure",
          "inputs": "overview, user perspectives (GUI/CLI/API/CICD), architecture, workflows, problems solved",
          "outputs": "Comprehensive product documentation object"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./analyzer"
      ],
      "intent": "This file exists to establish a consistent, hierarchical documentation structure that organizes code documentation from individual files up to product-level summaries. It provides TypeScript type definitions that ensure all documentation follows the same format, making it easier to generate, aggregate, and consume documentation programmatically across the codebase.",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines the type system and data structures for organizing code documentation at file, module, and product levels.\",\n  \"userVisibleActions\": [\n    \"No direct user-visible actions - this file defines data structures used internally\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import and use TypeScript interfaces to structure documentation data\",\n    \"Create FileSummary objects to document individual code files with role, purpose, and key functions\",\n    \"Build ModuleSummary objects to organize files into logical modules with capabilities\",\n    \"Generate EnhancedProductDocumentation with product overview, user perspectives, and architecture\",\n    \"Access structured documentation data through well-defined TypeScript types\",\n    \"Use these interfaces to ensure consistent documentation format across the codebase\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"FileSummary\",\n      \"desc\": \"Interface defining how individual file documentation is structured\",\n      \"inputs\": \"file path, role, purpose, actions, functions, dependencies\",\n      \"outputs\": \"Structured file-level documentation object\"\n    },\n    {\n      \"name\": \"ModuleSummary\",\n      \"desc\": \"Interface defining how module-level documentation is structured\",\n      \"inputs\": \"module path, type, capabilities, files, endpoints/commands/workers\",\n      \"outputs\": \"Structured module-level documentation object\"\n    },\n    {\n      \"name\": \"EnhancedProductDocumentation\",\n      \"desc\": \"Interface defining complete product documentation structure\",\n      \"inputs\": \"overview, user perspectives (GUI/CLI/API/CICD), architecture, workflows, problems solved\",\n      \"outputs\": \"Comprehensive product documentation object\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to establish a consistent, hierarchical documentation structure that organizes code documentation from individual files up to product-level summaries. It provides TypeScript type definitions that ensure all documentation follows the same format, making it easier to generate, aggregate, and consume documentation programmatically across the codebase.\"\n}\n```"
    },
    {
      "file": "src/fileWatcher.ts",
      "role": "Core Logic",
      "purpose": "Monitors file saves and automatically triggers code analysis when TypeScript files are saved",
      "userVisibleActions": [
        "Code is automatically analyzed when you save a TypeScript file",
        "Analysis results appear in diagnostics and insights tree after file save",
        "Duplicate analyses are prevented when saving files rapidly",
        "Analysis can be throttled based on configuration settings"
      ],
      "developerVisibleActions": [
        "File watcher automatically starts when extension activates if 'analyzeOnSave' is enabled",
        "Debouncing mechanism prevents multiple analyses from running simultaneously",
        "File saves trigger analysis pipeline: analyzer → insight generator → diagnostics → tree view",
        "Analysis is skipped if already in progress or too soon after last analysis",
        "Watcher can be started and stopped programmatically",
        "Errors during analysis are handled and logged without crashing the extension"
      ],
      "keyFunctions": [
        {
          "name": "start",
          "desc": "Starts watching for file saves and sets up automatic analysis",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "stop",
          "desc": "Stops watching for file saves and cleans up resources",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "onFileSaved",
          "desc": "Handles file save events and triggers analysis after debounce delay",
          "inputs": "document: vscode.TextDocument",
          "outputs": "void"
        },
        {
          "name": "triggerAnalysis",
          "desc": "Executes the analysis pipeline when conditions are met",
          "inputs": "document: vscode.TextDocument",
          "outputs": "Promise<void>"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all resources and stops the file watcher",
          "inputs": "none",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "CodeAnalyzer",
        "InsightGenerator",
        "DiagnosticsProvider",
        "InsightsTreeProvider",
        "ConfigurationManager",
        "ErrorHandler",
        "FileWatcherService"
      ],
      "intent": "This file exists to provide automatic code analysis triggered by file saves, giving users immediate feedback on their code without manual intervention. It solves the problem of having to manually trigger analysis after every code change by implementing intelligent debouncing and state management to ensure efficient, non-blocking analysis workflow.",
      "rawContent": "```json\n{\n  \"purpose\": \"Monitors file saves and automatically triggers code analysis when TypeScript files are saved\",\n  \"userVisibleActions\": [\n    \"Code is automatically analyzed when you save a TypeScript file\",\n    \"Analysis results appear in diagnostics and insights tree after file save\",\n    \"Duplicate analyses are prevented when saving files rapidly\",\n    \"Analysis can be throttled based on configuration settings\"\n  ],\n  \"developerVisibleActions\": [\n    \"File watcher automatically starts when extension activates if 'analyzeOnSave' is enabled\",\n    \"Debouncing mechanism prevents multiple analyses from running simultaneously\",\n    \"File saves trigger analysis pipeline: analyzer → insight generator → diagnostics → tree view\",\n    \"Analysis is skipped if already in progress or too soon after last analysis\",\n    \"Watcher can be started and stopped programmatically\",\n    \"Errors during analysis are handled and logged without crashing the extension\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"start\",\n      \"desc\": \"Starts watching for file saves and sets up automatic analysis\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"stop\",\n      \"desc\": \"Stops watching for file saves and cleans up resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"onFileSaved\",\n      \"desc\": \"Handles file save events and triggers analysis after debounce delay\",\n      \"inputs\": \"document: vscode.TextDocument\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"triggerAnalysis\",\n      \"desc\": \"Executes the analysis pipeline when conditions are met\",\n      \"inputs\": \"document: vscode.TextDocument\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all resources and stops the file watcher\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"CodeAnalyzer\",\n    \"InsightGenerator\",\n    \"DiagnosticsProvider\",\n    \"InsightsTreeProvider\",\n    \"ConfigurationManager\",\n    \"ErrorHandler\",\n    \"FileWatcherService\"\n  ],\n  \"intent\": \"This file exists to provide automatic code analysis triggered by file saves, giving users immediate feedback on their code without manual intervention. It solves the problem of having to manually trigger analysis after every code change by implementing intelligent debouncing and state management to ensure efficient, non-blocking analysis workflow.\"\n}\n```"
    },
    {
      "file": "src/insightGenerator.ts",
      "role": "Core Logic",
      "purpose": "Analyzes code structure and generates actionable insights about code quality, organization, and potential issues.",
      "userVisibleActions": [
        "Receives warnings about large files exceeding 500 lines of code",
        "Gets notified about orphaned files that aren't imported by other files",
        "Sees alerts for missing entry points in the codebase",
        "Receives warnings about potential circular dependencies between files",
        "Gets notified about 'god objects' (files with too many exports or responsibilities)",
        "Sees warnings about potential dead code that may not be used",
        "Receives suggestions about file organization issues",
        "Gets alerts about functions with high complexity",
        "Views severity levels (error, warning, info) for each insight",
        "Sees suggested fixes for each identified issue",
        "Views code snippets related to specific issues",
        "Gets file path and line number references for each problem"
      ],
      "developerVisibleActions": [
        "Calls generateInsights() with CodeAnalysis object to get all insights for entire codebase",
        "Calls generateInsightsForFile() with specific file path to get insights for single file",
        "Receives array of Insight objects with structured information (id, title, description, severity, category, suggestion)",
        "Uses severity levels to prioritize which insights to address first",
        "Follows suggestions to refactor or reorganize code",
        "Filters insights by category to focus on specific types of issues",
        "Uses file and line number information to navigate directly to problem areas"
      ],
      "keyFunctions": [
        {
          "name": "generateInsights",
          "desc": "Analyzes entire codebase and generates comprehensive list of code quality insights",
          "inputs": "CodeAnalysis object containing files, functions, and dependency information",
          "outputs": "Array of Insight objects with identified issues, warnings, and suggestions"
        },
        {
          "name": "generateInsightsForFile",
          "desc": "Generates insights specific to a single file in the codebase",
          "inputs": "CodeAnalysis object and specific file path string",
          "outputs": "Array of Insight objects relevant only to that file"
        },
        {
          "name": "checkLargeFiles",
          "desc": "Identifies files exceeding recommended line count threshold",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about oversized files"
        },
        {
          "name": "checkOrphanedFiles",
          "desc": "Finds files that aren't imported or used by other files",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about isolated files"
        },
        {
          "name": "checkEntryPoints",
          "desc": "Verifies presence of main entry points in codebase",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about missing entry points"
        },
        {
          "name": "checkCircularDependencies",
          "desc": "Detects potential circular import patterns between files",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about circular dependencies"
        },
        {
          "name": "checkGodObjects",
          "desc": "Identifies files with too many exports or responsibilities",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about files violating single responsibility principle"
        },
        {
          "name": "checkDeadCode",
          "desc": "Finds code that may not be used anywhere in the project",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about potentially unused code"
        },
        {
          "name": "checkFileOrganization",
          "desc": "Evaluates how files are structured and organized in the project",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about organizational improvements"
        },
        {
          "name": "checkFunctionComplexity",
          "desc": "Analyzes functions for excessive complexity or size",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of insights about overly complex functions"
        }
      ],
      "dependencies": [
        "./analyzer"
      ],
      "intent": "This file exists to transform raw code analysis data into actionable, human-readable insights that help developers improve code quality, maintainability, and organization. It solves the problem of making sense of complex codebase metrics by categorizing issues, prioritizing them by severity, and providing specific suggestions for improvement.",
      "rawContent": "```json\n{\n  \"purpose\": \"Analyzes code structure and generates actionable insights about code quality, organization, and potential issues.\",\n  \"userVisibleActions\": [\n    \"Receives warnings about large files exceeding 500 lines of code\",\n    \"Gets notified about orphaned files that aren't imported by other files\",\n    \"Sees alerts for missing entry points in the codebase\",\n    \"Receives warnings about potential circular dependencies between files\",\n    \"Gets notified about 'god objects' (files with too many exports or responsibilities)\",\n    \"Sees warnings about potential dead code that may not be used\",\n    \"Receives suggestions about file organization issues\",\n    \"Gets alerts about functions with high complexity\",\n    \"Views severity levels (error, warning, info) for each insight\",\n    \"Sees suggested fixes for each identified issue\",\n    \"Views code snippets related to specific issues\",\n    \"Gets file path and line number references for each problem\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls generateInsights() with CodeAnalysis object to get all insights for entire codebase\",\n    \"Calls generateInsightsForFile() with specific file path to get insights for single file\",\n    \"Receives array of Insight objects with structured information (id, title, description, severity, category, suggestion)\",\n    \"Uses severity levels to prioritize which insights to address first\",\n    \"Follows suggestions to refactor or reorganize code\",\n    \"Filters insights by category to focus on specific types of issues\",\n    \"Uses file and line number information to navigate directly to problem areas\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"generateInsights\",\n      \"desc\": \"Analyzes entire codebase and generates comprehensive list of code quality insights\",\n      \"inputs\": \"CodeAnalysis object containing files, functions, and dependency information\",\n      \"outputs\": \"Array of Insight objects with identified issues, warnings, and suggestions\"\n    },\n    {\n      \"name\": \"generateInsightsForFile\",\n      \"desc\": \"Generates insights specific to a single file in the codebase\",\n      \"inputs\": \"CodeAnalysis object and specific file path string\",\n      \"outputs\": \"Array of Insight objects relevant only to that file\"\n    },\n    {\n      \"name\": \"checkLargeFiles\",\n      \"desc\": \"Identifies files exceeding recommended line count threshold\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about oversized files\"\n    },\n    {\n      \"name\": \"checkOrphanedFiles\",\n      \"desc\": \"Finds files that aren't imported or used by other files\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about isolated files\"\n    },\n    {\n      \"name\": \"checkEntryPoints\",\n      \"desc\": \"Verifies presence of main entry points in codebase\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about missing entry points\"\n    },\n    {\n      \"name\": \"checkCircularDependencies\",\n      \"desc\": \"Detects potential circular import patterns between files\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about circular dependencies\"\n    },\n    {\n      \"name\": \"checkGodObjects\",\n      \"desc\": \"Identifies files with too many exports or responsibilities\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about files violating single responsibility principle\"\n    },\n    {\n      \"name\": \"checkDeadCode\",\n      \"desc\": \"Finds code that may not be used anywhere in the project\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about potentially unused code\"\n    },\n    {\n      \"name\": \"checkFileOrganization\",\n      \"desc\": \"Evaluates how files are structured and organized in the project\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about organizational improvements\"\n    },\n    {\n      \"name\": \"checkFunctionComplexity\",\n      \"desc\": \"Analyzes functions for excessive complexity or size\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of insights about overly complex functions\"\n    }\n  ],\n  \"dependencies\": [\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to transform raw code analysis data into actionable, human-readable insights that help developers improve code quality, maintainability, and organization. It solves the problem of making sense of complex codebase metrics by categorizing issues, prioritizing them by severity, and providing specific suggestions for improvement.\"\n}\n```"
    },
    {
      "file": "src/insightsTreeView.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view UI in VSCode that displays code analysis insights, documentation status, and generated reports with actions to regenerate or view content.",
      "userVisibleActions": [
        "View a tree hierarchy showing product documentation, insights, unit tests, and analysis reports",
        "See status indicators (idle, generating, complete) for different analysis types",
        "Click to regenerate product documentation for the codebase",
        "Click to regenerate insights about the code",
        "Click to regenerate unit tests",
        "Click to regenerate various types of reports (workspace, product, architecture, unit test)",
        "View timestamps showing when each analysis was last generated",
        "Open generated reports in the editor by clicking on them",
        "Copy insights text to clipboard",
        "See progress indicators while content is being generated",
        "Receive notifications when generation completes or fails",
        "Configure LLM settings through the tree view",
        "Search within insights using a search command"
      ],
      "developerVisibleActions": [
        "Maintains state of all analysis artifacts (documentation, insights, reports)",
        "Persists timestamps and file paths across VSCode sessions",
        "Coordinates with LLMService to generate AI-powered content",
        "Triggers tree view refresh when data changes",
        "Handles user clicks on tree items to execute appropriate commands",
        "Validates existence of generated files before displaying them",
        "Provides context menu actions for regenerating content",
        "Integrates with workspace state to remember generation history",
        "Emits events when tree data changes to update the UI",
        "Manages multiple report types (workspace, product, architecture, unit test)",
        "Handles asynchronous generation workflows with status tracking"
      ],
      "keyFunctions": [
        {
          "name": "getTreeItem",
          "desc": "Converts a TreeItem into a vscode.TreeItem for display in the tree view",
          "inputs": "element: TreeItem",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child nodes for the tree structure, creating the hierarchy of insights, docs, and reports",
          "inputs": "element?: TreeItem",
          "outputs": "TreeItem[] or Promise<TreeItem[]>"
        },
        {
          "name": "setInsights",
          "desc": "Updates the insights data and refreshes the tree view",
          "inputs": "insights: Insight[]",
          "outputs": "void"
        },
        {
          "name": "setProductDocsStatus",
          "desc": "Updates the status of product documentation generation and refreshes the view",
          "inputs": "status: 'idle' | 'generating' | 'complete', timestamp?: number",
          "outputs": "void"
        },
        {
          "name": "setLLMInsights",
          "desc": "Stores LLM-generated insights and updates the view",
          "inputs": "insights: LLMInsights",
          "outputs": "void"
        },
        {
          "name": "setReportPath",
          "desc": "Sets the path to a generated report file and updates the view",
          "inputs": "path: string, timestamp: number",
          "outputs": "void"
        },
        {
          "name": "refresh",
          "desc": "Triggers a refresh of the entire tree view UI",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "loadPersistedState",
          "desc": "Loads previously saved timestamps and file paths from workspace storage",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "cleanupMissingFiles",
          "desc": "Verifies that stored file paths still exist and clears invalid entries",
          "inputs": "none",
          "outputs": "Promise<void>"
        },
        {
          "name": "getUnitTestStatus",
          "desc": "Returns the current status of unit test generation",
          "inputs": "none",
          "outputs": "'idle' | 'generating' | 'complete'"
        }
      ],
      "dependencies": [
        "vscode",
        "./insightGenerator",
        "./llmFormatter",
        "./llmService"
      ],
      "intent": "This file exists to create an interactive sidebar panel in VSCode where users can view, manage, and regenerate AI-generated code analysis artifacts including documentation, insights, unit tests, and various reports, while maintaining state persistence across sessions.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view UI in VSCode that displays code analysis insights, documentation status, and generated reports with actions to regenerate or view content.\",\n  \"userVisibleActions\": [\n    \"View a tree hierarchy showing product documentation, insights, unit tests, and analysis reports\",\n    \"See status indicators (idle, generating, complete) for different analysis types\",\n    \"Click to regenerate product documentation for the codebase\",\n    \"Click to regenerate insights about the code\",\n    \"Click to regenerate unit tests\",\n    \"Click to regenerate various types of reports (workspace, product, architecture, unit test)\",\n    \"View timestamps showing when each analysis was last generated\",\n    \"Open generated reports in the editor by clicking on them\",\n    \"Copy insights text to clipboard\",\n    \"See progress indicators while content is being generated\",\n    \"Receive notifications when generation completes or fails\",\n    \"Configure LLM settings through the tree view\",\n    \"Search within insights using a search command\"\n  ],\n  \"developerVisibleActions\": [\n    \"Maintains state of all analysis artifacts (documentation, insights, reports)\",\n    \"Persists timestamps and file paths across VSCode sessions\",\n    \"Coordinates with LLMService to generate AI-powered content\",\n    \"Triggers tree view refresh when data changes\",\n    \"Handles user clicks on tree items to execute appropriate commands\",\n    \"Validates existence of generated files before displaying them\",\n    \"Provides context menu actions for regenerating content\",\n    \"Integrates with workspace state to remember generation history\",\n    \"Emits events when tree data changes to update the UI\",\n    \"Manages multiple report types (workspace, product, architecture, unit test)\",\n    \"Handles asynchronous generation workflows with status tracking\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts a TreeItem into a vscode.TreeItem for display in the tree view\",\n      \"inputs\": \"element: TreeItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child nodes for the tree structure, creating the hierarchy of insights, docs, and reports\",\n      \"inputs\": \"element?: TreeItem\",\n      \"outputs\": \"TreeItem[] or Promise<TreeItem[]>\"\n    },\n    {\n      \"name\": \"setInsights\",\n      \"desc\": \"Updates the insights data and refreshes the tree view\",\n      \"inputs\": \"insights: Insight[]\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setProductDocsStatus\",\n      \"desc\": \"Updates the status of product documentation generation and refreshes the view\",\n      \"inputs\": \"status: 'idle' | 'generating' | 'complete', timestamp?: number\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setLLMInsights\",\n      \"desc\": \"Stores LLM-generated insights and updates the view\",\n      \"inputs\": \"insights: LLMInsights\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setReportPath\",\n      \"desc\": \"Sets the path to a generated report file and updates the view\",\n      \"inputs\": \"path: string, timestamp: number\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Triggers a refresh of the entire tree view UI\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"loadPersistedState\",\n      \"desc\": \"Loads previously saved timestamps and file paths from workspace storage\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"cleanupMissingFiles\",\n      \"desc\": \"Verifies that stored file paths still exist and clears invalid entries\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"getUnitTestStatus\",\n      \"desc\": \"Returns the current status of unit test generation\",\n      \"inputs\": \"none\",\n      \"outputs\": \"'idle' | 'generating' | 'complete'\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./llmService\"\n  ],\n  \"intent\": \"This file exists to create an interactive sidebar panel in VSCode where users can view, manage, and regenerate AI-generated code analysis artifacts including documentation, insights, unit tests, and various reports, while maintaining state persistence across sessions.\"\n}\n```"
    },
    {
      "file": "src/insightsViewer.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, automatically updating when insight files change.",
      "userVisibleActions": [
        "View architecture insights in a tree structure in the sidebar",
        "Browse different categories of insights (Components, Data Flow, Architecture Patterns, etc.)",
        "Click on insight items to see detailed descriptions",
        "Open related source code files by clicking on file references",
        "See real-time updates when AI generates new insights",
        "Refresh the insights view manually",
        "Navigate to specific code locations from insight items",
        "View purpose statements for individual files",
        "See grouped insights by category and type"
      ],
      "developerVisibleActions": [
        "Tree view automatically refreshes when .shadow/docs/ai-architecture-insights.json file changes",
        "Tree view updates when .shadow/docs/purpose.json file changes",
        "Clicking on file paths opens the corresponding source file in the editor",
        "Tree provides hierarchical navigation of AI-generated insights",
        "Insights are loaded from JSON files in the .shadow/docs directory",
        "File watchers monitor for changes and trigger automatic updates",
        "Purpose statements are displayed as additional insight items"
      ],
      "keyFunctions": [
        {
          "name": "refresh",
          "desc": "Reloads insights from disk and updates the tree view display",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getTreeItem",
          "desc": "Converts an insight item into a VS Code tree item for display",
          "inputs": "InsightItem",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child items for the tree hierarchy (categories, subcategories, and individual insights)",
          "inputs": "optional parent InsightItem",
          "outputs": "Promise<InsightItem[]>"
        },
        {
          "name": "loadInsights",
          "desc": "Reads AI insights from the JSON file in .shadow/docs directory",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "loadPurposeStatements",
          "desc": "Reads file purpose statements from purpose.json file",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "setupFileWatcher",
          "desc": "Creates file system watchers to detect changes in insight files",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "openFile",
          "desc": "Opens a source code file in the editor at a specific location",
          "inputs": "file path and optional line number",
          "outputs": "Promise<void>"
        }
      ],
      "dependencies": [
        "vscode",
        "llmService",
        "path",
        "fs",
        "fileWatcherService"
      ],
      "intent": "This file exists to provide developers with an interactive, always-updated view of AI-generated architecture insights about their codebase. It solves the problem of making AI analysis results easily accessible and navigable within the VS Code interface, with automatic updates as the AI discovers new patterns or the code changes. It bridges the gap between AI analysis (stored in JSON files) and developer interaction (tree view UI).",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, automatically updating when insight files change.\",\n  \"userVisibleActions\": [\n    \"View architecture insights in a tree structure in the sidebar\",\n    \"Browse different categories of insights (Components, Data Flow, Architecture Patterns, etc.)\",\n    \"Click on insight items to see detailed descriptions\",\n    \"Open related source code files by clicking on file references\",\n    \"See real-time updates when AI generates new insights\",\n    \"Refresh the insights view manually\",\n    \"Navigate to specific code locations from insight items\",\n    \"View purpose statements for individual files\",\n    \"See grouped insights by category and type\"\n  ],\n  \"developerVisibleActions\": [\n    \"Tree view automatically refreshes when .shadow/docs/ai-architecture-insights.json file changes\",\n    \"Tree view updates when .shadow/docs/purpose.json file changes\",\n    \"Clicking on file paths opens the corresponding source file in the editor\",\n    \"Tree provides hierarchical navigation of AI-generated insights\",\n    \"Insights are loaded from JSON files in the .shadow/docs directory\",\n    \"File watchers monitor for changes and trigger automatic updates\",\n    \"Purpose statements are displayed as additional insight items\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Reloads insights from disk and updates the tree view display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts an insight item into a VS Code tree item for display\",\n      \"inputs\": \"InsightItem\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for the tree hierarchy (categories, subcategories, and individual insights)\",\n      \"inputs\": \"optional parent InsightItem\",\n      \"outputs\": \"Promise<InsightItem[]>\"\n    },\n    {\n      \"name\": \"loadInsights\",\n      \"desc\": \"Reads AI insights from the JSON file in .shadow/docs directory\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"loadPurposeStatements\",\n      \"desc\": \"Reads file purpose statements from purpose.json file\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"setupFileWatcher\",\n      \"desc\": \"Creates file system watchers to detect changes in insight files\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"openFile\",\n      \"desc\": \"Opens a source code file in the editor at a specific location\",\n      \"inputs\": \"file path and optional line number\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"llmService\",\n    \"path\",\n    \"fs\",\n    \"fileWatcherService\"\n  ],\n  \"intent\": \"This file exists to provide developers with an interactive, always-updated view of AI-generated architecture insights about their codebase. It solves the problem of making AI analysis results easily accessible and navigable within the VS Code interface, with automatic updates as the AI discovers new patterns or the code changes. It bridges the gap between AI analysis (stored in JSON files) and developer interaction (tree view UI).\"\n}\n```"
    },
    {
      "file": "src/llmFormatter.ts",
      "role": "Core Logic",
      "purpose": "Formats code architecture insights into different LLM-friendly output formats for use with various AI assistants",
      "userVisibleActions": [
        "Receives formatted architecture issues grouped by severity (errors, warnings, info)",
        "Gets structured prompts asking for help prioritizing and addressing issues",
        "Sees architecture insights in different styles optimized for Cursor, ChatGPT, or generic LLMs",
        "Views compact summaries showing issue counts by type and severity"
      ],
      "developerVisibleActions": [
        "Calls formatInsights() with insights array and format type to get formatted output",
        "Chooses between 'cursor', 'chatgpt', 'compact', or 'generic' format styles",
        "Receives markdown-formatted text ready to paste into AI assistants",
        "Gets insights automatically grouped and sorted by severity level",
        "Receives actionable prompts requesting specific refactoring guidance from LLMs"
      ],
      "keyFunctions": [
        {
          "name": "formatInsights",
          "desc": "Main entry point that routes to appropriate formatter based on specified format",
          "inputs": "insights array and format string ('cursor', 'chatgpt', 'compact', 'generic')",
          "outputs": "Formatted markdown string ready for LLM consumption"
        },
        {
          "name": "formatForCursor",
          "desc": "Formats insights specifically for Cursor AI with severity groups and actionable prompts",
          "inputs": "Array of Insight objects",
          "outputs": "Markdown text with emoji-decorated sections and specific requests for help"
        },
        {
          "name": "formatForChatGPT",
          "desc": "Formats insights for ChatGPT with conversational tone and context",
          "inputs": "Array of Insight objects",
          "outputs": "Markdown text optimized for ChatGPT's interaction style"
        },
        {
          "name": "formatCompact",
          "desc": "Creates brief summary format showing counts and key statistics",
          "inputs": "Array of Insight objects",
          "outputs": "Condensed markdown summary of issues"
        },
        {
          "name": "formatGeneric",
          "desc": "Produces neutral format suitable for any LLM without specific optimizations",
          "inputs": "Array of Insight objects",
          "outputs": "Standard markdown listing of insights"
        }
      ],
      "dependencies": [
        "./insightGenerator"
      ],
      "intent": "Bridges the gap between raw code analysis insights and AI assistant prompts by transforming technical findings into well-structured, actionable requests that guide LLMs to provide specific refactoring advice and architectural guidance",
      "rawContent": "```json\n{\n  \"purpose\": \"Formats code architecture insights into different LLM-friendly output formats for use with various AI assistants\",\n  \"userVisibleActions\": [\n    \"Receives formatted architecture issues grouped by severity (errors, warnings, info)\",\n    \"Gets structured prompts asking for help prioritizing and addressing issues\",\n    \"Sees architecture insights in different styles optimized for Cursor, ChatGPT, or generic LLMs\",\n    \"Views compact summaries showing issue counts by type and severity\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls formatInsights() with insights array and format type to get formatted output\",\n    \"Chooses between 'cursor', 'chatgpt', 'compact', or 'generic' format styles\",\n    \"Receives markdown-formatted text ready to paste into AI assistants\",\n    \"Gets insights automatically grouped and sorted by severity level\",\n    \"Receives actionable prompts requesting specific refactoring guidance from LLMs\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"formatInsights\",\n      \"desc\": \"Main entry point that routes to appropriate formatter based on specified format\",\n      \"inputs\": \"insights array and format string ('cursor', 'chatgpt', 'compact', 'generic')\",\n      \"outputs\": \"Formatted markdown string ready for LLM consumption\"\n    },\n    {\n      \"name\": \"formatForCursor\",\n      \"desc\": \"Formats insights specifically for Cursor AI with severity groups and actionable prompts\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Markdown text with emoji-decorated sections and specific requests for help\"\n    },\n    {\n      \"name\": \"formatForChatGPT\",\n      \"desc\": \"Formats insights for ChatGPT with conversational tone and context\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Markdown text optimized for ChatGPT's interaction style\"\n    },\n    {\n      \"name\": \"formatCompact\",\n      \"desc\": \"Creates brief summary format showing counts and key statistics\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Condensed markdown summary of issues\"\n    },\n    {\n      \"name\": \"formatGeneric\",\n      \"desc\": \"Produces neutral format suitable for any LLM without specific optimizations\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Standard markdown listing of insights\"\n    }\n  ],\n  \"dependencies\": [\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"Bridges the gap between raw code analysis insights and AI assistant prompts by transforming technical findings into well-structured, actionable requests that guide LLMs to provide specific refactoring advice and architectural guidance\"\n}\n```"
    },
    {
      "file": "src/llmIntegration.ts",
      "role": "Core Logic",
      "purpose": "Manages LLM-powered code analysis features including insights generation, documentation, and navigation tree views in VS Code.",
      "userVisibleActions": [
        "View AI-generated code insights in a tree view panel",
        "See analysis results for entry points, unit tests, and product documentation",
        "Get real-time updates when API key configuration changes",
        "View formatted documentation in an output channel",
        "Navigate through analyzed code structure via tree providers",
        "Access saved analysis results that persist across sessions",
        "Receive notifications about analysis progress and completion",
        "See error messages when LLM operations fail"
      ],
      "developerVisibleActions": [
        "Initialize LLM service with API configuration",
        "Trigger code analysis on workspace files",
        "Generate insights from code analysis results",
        "Save and load analysis contexts for reuse",
        "Refresh tree views when analysis updates",
        "Execute shell commands for analysis operations",
        "Access state management for LLM operations",
        "Convert code analysis to LLM context format",
        "Persist analysis results to storage",
        "Format documentation for display"
      ],
      "keyFunctions": [
        {
          "name": "initializeLLMService",
          "desc": "Sets up the LLM service, output channels, and tree view refresh handlers",
          "inputs": "none",
          "outputs": "void - initializes global state"
        },
        {
          "name": "convertCodeAnalysisToContext",
          "desc": "Transforms code analysis data into format suitable for LLM processing",
          "inputs": "CodeAnalysis object",
          "outputs": "AnalysisContext object"
        },
        {
          "name": "saveCodeAnalysis",
          "desc": "Persists code analysis results to storage",
          "inputs": "CodeAnalysis data",
          "outputs": "Promise indicating save completion"
        },
        {
          "name": "loadSavedCodeAnalysisFromFile",
          "desc": "Retrieves previously saved code analysis from storage",
          "inputs": "file path or identifier",
          "outputs": "Promise<CodeAnalysis>"
        }
      ],
      "dependencies": [
        "vscode",
        "fs",
        "path",
        "child_process",
        "util",
        "./llmService",
        "./insightsTreeView",
        "./fileDocumentation",
        "./analyzer",
        "./productNavigator",
        "./analysisViewer",
        "./insightsViewer",
        "./unitTestsNavigator",
        "./logger",
        "./state/llmStateManager",
        "./context/analysisContextBuilder",
        "./domain/formatters/documentationFormatter",
        "./infrastructure/persistence/analysisResultRepository"
      ],
      "intent": "This file exists to orchestrate LLM-powered code understanding features in VS Code. It solves the problem of making large codebases understandable by connecting AI analysis with VS Code's UI components (tree views, output channels, navigation). It manages the lifecycle of analysis operations, state persistence, and user-facing visualization of AI-generated insights.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages LLM-powered code analysis features including insights generation, documentation, and navigation tree views in VS Code.\",\n  \"userVisibleActions\": [\n    \"View AI-generated code insights in a tree view panel\",\n    \"See analysis results for entry points, unit tests, and product documentation\",\n    \"Get real-time updates when API key configuration changes\",\n    \"View formatted documentation in an output channel\",\n    \"Navigate through analyzed code structure via tree providers\",\n    \"Access saved analysis results that persist across sessions\",\n    \"Receive notifications about analysis progress and completion\",\n    \"See error messages when LLM operations fail\"\n  ],\n  \"developerVisibleActions\": [\n    \"Initialize LLM service with API configuration\",\n    \"Trigger code analysis on workspace files\",\n    \"Generate insights from code analysis results\",\n    \"Save and load analysis contexts for reuse\",\n    \"Refresh tree views when analysis updates\",\n    \"Execute shell commands for analysis operations\",\n    \"Access state management for LLM operations\",\n    \"Convert code analysis to LLM context format\",\n    \"Persist analysis results to storage\",\n    \"Format documentation for display\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initializeLLMService\",\n      \"desc\": \"Sets up the LLM service, output channels, and tree view refresh handlers\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void - initializes global state\"\n    },\n    {\n      \"name\": \"convertCodeAnalysisToContext\",\n      \"desc\": \"Transforms code analysis data into format suitable for LLM processing\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"AnalysisContext object\"\n    },\n    {\n      \"name\": \"saveCodeAnalysis\",\n      \"desc\": \"Persists code analysis results to storage\",\n      \"inputs\": \"CodeAnalysis data\",\n      \"outputs\": \"Promise indicating save completion\"\n    },\n    {\n      \"name\": \"loadSavedCodeAnalysisFromFile\",\n      \"desc\": \"Retrieves previously saved code analysis from storage\",\n      \"inputs\": \"file path or identifier\",\n      \"outputs\": \"Promise<CodeAnalysis>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"child_process\",\n    \"util\",\n    \"./llmService\",\n    \"./insightsTreeView\",\n    \"./fileDocumentation\",\n    \"./analyzer\",\n    \"./productNavigator\",\n    \"./analysisViewer\",\n    \"./insightsViewer\",\n    \"./unitTestsNavigator\",\n    \"./logger\",\n    \"./state/llmStateManager\",\n    \"./context/analysisContextBuilder\",\n    \"./domain/formatters/documentationFormatter\",\n    \"./infrastructure/persistence/analysisResultRepository\"\n  ],\n  \"intent\": \"This file exists to orchestrate LLM-powered code understanding features in VS Code. It solves the problem of making large codebases understandable by connecting AI analysis with VS Code's UI components (tree views, output channels, navigation). It manages the lifecycle of analysis operations, state persistence, and user-facing visualization of AI-generated insights.\"\n}\n```"
    },
    {
      "file": "src/llmSchemas.ts",
      "role": "Core Logic",
      "purpose": "Defines JSON schemas for Claude AI to generate structured, type-safe responses for code analysis tasks",
      "userVisibleActions": [
        "Product purpose analysis results appear in structured format",
        "Code issues are categorized and prioritized automatically",
        "Architectural explanations follow consistent structure",
        "Code behavior summaries use standardized format",
        "File relationships are visualized with clear connections"
      ],
      "developerVisibleActions": [
        "Import schema definitions to ensure Claude returns parseable JSON responses",
        "Use productPurposeAnalysisSchema to get structured product insights",
        "Use issueItemSchema to receive categorized code issues with severity levels",
        "Use fileBehaviorSchema to extract user-facing and developer-facing actions from code",
        "Use relationshipSchema to understand file dependencies and connections",
        "Schemas guarantee valid JSON output without manual parsing or error handling",
        "All schemas include required fields validation and type enforcement"
      ],
      "keyFunctions": [],
      "dependencies": [],
      "intent": "Ensures Claude AI returns consistent, structured responses that can be programmatically processed without parsing errors. Eliminates the need for manual JSON extraction, regex parsing, or error handling when analyzing code. Each schema defines the exact shape of data needed for different analysis types (product purpose, code issues, file behavior, relationships).",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines JSON schemas for Claude AI to generate structured, type-safe responses for code analysis tasks\",\n  \"userVisibleActions\": [\n    \"Product purpose analysis results appear in structured format\",\n    \"Code issues are categorized and prioritized automatically\",\n    \"Architectural explanations follow consistent structure\",\n    \"Code behavior summaries use standardized format\",\n    \"File relationships are visualized with clear connections\"\n  ],\n  \"developerVisibleActions\": [\n    \"Import schema definitions to ensure Claude returns parseable JSON responses\",\n    \"Use productPurposeAnalysisSchema to get structured product insights\",\n    \"Use issueItemSchema to receive categorized code issues with severity levels\",\n    \"Use fileBehaviorSchema to extract user-facing and developer-facing actions from code\",\n    \"Use relationshipSchema to understand file dependencies and connections\",\n    \"Schemas guarantee valid JSON output without manual parsing or error handling\",\n    \"All schemas include required fields validation and type enforcement\"\n  ],\n  \"keyFunctions\": [],\n  \"dependencies\": [],\n  \"intent\": \"Ensures Claude AI returns consistent, structured responses that can be programmatically processed without parsing errors. Eliminates the need for manual JSON extraction, regex parsing, or error handling when analyzing code. Each schema defines the exact shape of data needed for different analysis types (product purpose, code issues, file behavior, relationships).\"\n}\n```"
    },
    {
      "file": "src/llmService.ts",
      "role": "Core Logic",
      "purpose": "Orchestrates AI-powered code analysis by connecting to LLM providers (OpenAI/Claude) to generate intelligent insights, documentation, and test plans from codebase analysis.",
      "userVisibleActions": [
        "Receives AI-generated explanations of what the codebase does and why it exists",
        "Gets intelligent insights about code architecture, patterns, and technical decisions",
        "Views automatically generated product documentation describing the software's purpose",
        "Sees AI-created unit test plans for code coverage",
        "Receives refactoring suggestions with code improvements",
        "Gets analysis of product purpose and architecture rationale"
      ],
      "developerVisibleActions": [
        "Calls analyzeProductPurpose() to get AI analysis of what the product does and its architecture decisions",
        "Invokes generateLLMInsights() to receive intelligent observations about code quality, patterns, and concerns",
        "Uses generateProductDocumentation() to create comprehensive product documentation from file summaries",
        "Triggers generateUnitTestPlan() to get AI-generated test strategies for specific files",
        "Calls generateRefactoringSuggestions() to receive code improvement recommendations",
        "Configures LLM provider settings (OpenAI, Claude, Ollama, OpenRouter) through configuration manager",
        "Handles rate limiting, retries, and error recovery automatically during LLM interactions",
        "Receives structured JSON responses parsed from LLM outputs",
        "Triggers incremental analysis to update insights as code changes"
      ],
      "keyFunctions": [
        {
          "name": "analyzeProductPurpose",
          "desc": "Analyzes the entire codebase to determine what the product does, its architecture rationale, user problems it solves, and technical approach",
          "inputs": "analysisContext (file metadata, imports, entry points)",
          "outputs": "ProductPurposeAnalysis with purpose, rationale, user problems, and technical approach"
        },
        {
          "name": "generateLLMInsights",
          "desc": "Generates intelligent insights about code patterns, architecture decisions, potential issues, and recommendations",
          "inputs": "analysisContext, optional productPurpose",
          "outputs": "Array of categorized insights (architecture, patterns, performance, maintenance, concerns)"
        },
        {
          "name": "generateProductDocumentation",
          "desc": "Creates comprehensive product documentation by analyzing file summaries and module organization",
          "inputs": "fileSummaries array, moduleSummaries array",
          "outputs": "EnhancedProductDocumentation with overview, features, architecture, and module details"
        },
        {
          "name": "generateUnitTestPlan",
          "desc": "Creates a detailed test plan for a specific file including test cases, edge cases, and mocking strategies",
          "inputs": "filePath, fileContent, codeAnalysis",
          "outputs": "UnitTestPlan with test cases, coverage areas, dependencies, and recommendations"
        },
        {
          "name": "generateRefactoringSuggestions",
          "desc": "Analyzes functions and provides AI-powered refactoring recommendations with code examples",
          "inputs": "filePath, fileContent, functions metadata, optional context",
          "outputs": "Array of refactoring suggestions with priority, rationale, and code snippets"
        },
        {
          "name": "callLLM",
          "desc": "Central method that sends requests to configured LLM provider with rate limiting and retry logic",
          "inputs": "prompt, systemMessage, schema, optional config",
          "outputs": "Parsed JSON response from LLM"
        },
        {
          "name": "getProviderInstance",
          "desc": "Creates and configures the appropriate LLM provider based on user settings",
          "inputs": "none (reads from configuration)",
          "outputs": "Configured LLMProvider instance (OpenAI, Claude, Ollama, or OpenRouter)"
        }
      ],
      "dependencies": [
        "vscode",
        "./fileDocumentation",
        "./analyzer",
        "./analysis/enhancedAnalyzer",
        "./llmSchemas",
        "./fileAccessHelper",
        "./logger",
        "./config/configurationManager",
        "./ai/providers/providerFactory",
        "./ai/llmResponseParser",
        "./ai/llmRateLimiter",
        "./ai/llmRetryHandler",
        "./domain/prompts/promptBuilder",
        "./domain/services/incrementalAnalysisService",
        "./domain/prompts/refactoringPromptBuilder",
        "./analysis/functionAnalyzer"
      ],
      "intent": "This file exists to bridge the gap between raw code analysis and human-understandable insights by leveraging Large Language Models. It solves the problem of developers needing to manually understand complex codebases by automatically generating intelligent documentation, architectural insights, test plans, and refactoring suggestions. It abstracts away the complexity of working with multiple LLM providers and handles the orchestration of prompts, responses, rate limiting, and error handling.",
      "rawContent": "```json\n{\n  \"purpose\": \"Orchestrates AI-powered code analysis by connecting to LLM providers (OpenAI/Claude) to generate intelligent insights, documentation, and test plans from codebase analysis.\",\n  \"userVisibleActions\": [\n    \"Receives AI-generated explanations of what the codebase does and why it exists\",\n    \"Gets intelligent insights about code architecture, patterns, and technical decisions\",\n    \"Views automatically generated product documentation describing the software's purpose\",\n    \"Sees AI-created unit test plans for code coverage\",\n    \"Receives refactoring suggestions with code improvements\",\n    \"Gets analysis of product purpose and architecture rationale\"\n  ],\n  \"developerVisibleActions\": [\n    \"Calls analyzeProductPurpose() to get AI analysis of what the product does and its architecture decisions\",\n    \"Invokes generateLLMInsights() to receive intelligent observations about code quality, patterns, and concerns\",\n    \"Uses generateProductDocumentation() to create comprehensive product documentation from file summaries\",\n    \"Triggers generateUnitTestPlan() to get AI-generated test strategies for specific files\",\n    \"Calls generateRefactoringSuggestions() to receive code improvement recommendations\",\n    \"Configures LLM provider settings (OpenAI, Claude, Ollama, OpenRouter) through configuration manager\",\n    \"Handles rate limiting, retries, and error recovery automatically during LLM interactions\",\n    \"Receives structured JSON responses parsed from LLM outputs\",\n    \"Triggers incremental analysis to update insights as code changes\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeProductPurpose\",\n      \"desc\": \"Analyzes the entire codebase to determine what the product does, its architecture rationale, user problems it solves, and technical approach\",\n      \"inputs\": \"analysisContext (file metadata, imports, entry points)\",\n      \"outputs\": \"ProductPurposeAnalysis with purpose, rationale, user problems, and technical approach\"\n    },\n    {\n      \"name\": \"generateLLMInsights\",\n      \"desc\": \"Generates intelligent insights about code patterns, architecture decisions, potential issues, and recommendations\",\n      \"inputs\": \"analysisContext, optional productPurpose\",\n      \"outputs\": \"Array of categorized insights (architecture, patterns, performance, maintenance, concerns)\"\n    },\n    {\n      \"name\": \"generateProductDocumentation\",\n      \"desc\": \"Creates comprehensive product documentation by analyzing file summaries and module organization\",\n      \"inputs\": \"fileSummaries array, moduleSummaries array\",\n      \"outputs\": \"EnhancedProductDocumentation with overview, features, architecture, and module details\"\n    },\n    {\n      \"name\": \"generateUnitTestPlan\",\n      \"desc\": \"Creates a detailed test plan for a specific file including test cases, edge cases, and mocking strategies\",\n      \"inputs\": \"filePath, fileContent, codeAnalysis\",\n      \"outputs\": \"UnitTestPlan with test cases, coverage areas, dependencies, and recommendations\"\n    },\n    {\n      \"name\": \"generateRefactoringSuggestions\",\n      \"desc\": \"Analyzes functions and provides AI-powered refactoring recommendations with code examples\",\n      \"inputs\": \"filePath, fileContent, functions metadata, optional context\",\n      \"outputs\": \"Array of refactoring suggestions with priority, rationale, and code snippets\"\n    },\n    {\n      \"name\": \"callLLM\",\n      \"desc\": \"Central method that sends requests to configured LLM provider with rate limiting and retry logic\",\n      \"inputs\": \"prompt, systemMessage, schema, optional config\",\n      \"outputs\": \"Parsed JSON response from LLM\"\n    },\n    {\n      \"name\": \"getProviderInstance\",\n      \"desc\": \"Creates and configures the appropriate LLM provider based on user settings\",\n      \"inputs\": \"none (reads from configuration)\",\n      \"outputs\": \"Configured LLMProvider instance (OpenAI, Claude, Ollama, or OpenRouter)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./fileDocumentation\",\n    \"./analyzer\",\n    \"./analysis/enhancedAnalyzer\",\n    \"./llmSchemas\",\n    \"./fileAccessHelper\",\n    \"./logger\",\n    \"./config/configurationManager\",\n    \"./ai/providers/providerFactory\",\n    \"./ai/llmResponseParser\",\n    \"./ai/llmRateLimiter\",\n    \"./ai/llmRetryHandler\",\n    \"./domain/prompts/promptBuilder\",\n    \"./domain/services/incrementalAnalysisService\",\n    \"./domain/prompts/refactoringPromptBuilder\",\n    \"./analysis/functionAnalyzer\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between raw code analysis and human-understandable insights by leveraging Large Language Models. It solves the problem of developers needing to manually understand complex codebases by automatically generating intelligent documentation, architectural insights, test plans, and refactoring suggestions. It abstracts away the complexity of working with multiple LLM providers and handles the orchestration of prompts, responses, rate limiting, and error handling.\"\n}\n```"
    },
    {
      "file": "src/logger.ts",
      "role": "Core Logic",
      "purpose": "Provides a logging utility that writes timestamped messages to a log file in the workspace's .shadow/logs directory",
      "userVisibleActions": [
        "Log files are created in the .shadow/logs folder at the workspace root",
        "Log entries appear with timestamps in shadow-watch.log file",
        "Section headers with visual separators appear in log file for organizing log output"
      ],
      "developerVisibleActions": [
        "Developer calls SWLogger.log() to write timestamped messages to the log file",
        "Developer calls SWLogger.section() to create visually separated sections in logs",
        "Logging silently fails if workspace is not available or errors occur, preventing crashes",
        "Log directory .shadow/logs is automatically created if it doesn't exist"
      ],
      "keyFunctions": [
        {
          "name": "log",
          "desc": "Writes a timestamped message to the log file",
          "inputs": "message: string - the text to log",
          "outputs": "void - writes to file system"
        },
        {
          "name": "section",
          "desc": "Creates a visually separated section header in the log file",
          "inputs": "title: string - the section title",
          "outputs": "void - writes formatted section header to file"
        },
        {
          "name": "getLogPath",
          "desc": "Determines the file path for the log file in the workspace",
          "inputs": "none",
          "outputs": "string | null - path to log file or null if no workspace"
        },
        {
          "name": "ensureDir",
          "desc": "Creates a directory and parent directories if they don't exist",
          "inputs": "dir: string - directory path to create",
          "outputs": "void - creates directories on file system"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "vscode"
      ],
      "intent": "Provides centralized logging functionality for the extension to track operations and debugging information in a persistent file within the workspace, making it easier to troubleshoot issues and understand extension behavior over time",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a logging utility that writes timestamped messages to a log file in the workspace's .shadow/logs directory\",\n  \"userVisibleActions\": [\n    \"Log files are created in the .shadow/logs folder at the workspace root\",\n    \"Log entries appear with timestamps in shadow-watch.log file\",\n    \"Section headers with visual separators appear in log file for organizing log output\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer calls SWLogger.log() to write timestamped messages to the log file\",\n    \"Developer calls SWLogger.section() to create visually separated sections in logs\",\n    \"Logging silently fails if workspace is not available or errors occur, preventing crashes\",\n    \"Log directory .shadow/logs is automatically created if it doesn't exist\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"log\",\n      \"desc\": \"Writes a timestamped message to the log file\",\n      \"inputs\": \"message: string - the text to log\",\n      \"outputs\": \"void - writes to file system\"\n    },\n    {\n      \"name\": \"section\",\n      \"desc\": \"Creates a visually separated section header in the log file\",\n      \"inputs\": \"title: string - the section title\",\n      \"outputs\": \"void - writes formatted section header to file\"\n    },\n    {\n      \"name\": \"getLogPath\",\n      \"desc\": \"Determines the file path for the log file in the workspace\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string | null - path to log file or null if no workspace\"\n    },\n    {\n      \"name\": \"ensureDir\",\n      \"desc\": \"Creates a directory and parent directories if they don't exist\",\n      \"inputs\": \"dir: string - directory path to create\",\n      \"outputs\": \"void - creates directories on file system\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"vscode\"\n  ],\n  \"intent\": \"Provides centralized logging functionality for the extension to track operations and debugging information in a persistent file within the workspace, making it easier to troubleshoot issues and understand extension behavior over time\"\n}\n```"
    },
    {
      "file": "src/productNavigator.ts",
      "role": "Core Logic",
      "purpose": "Provides a product-centric navigation view that organizes code by functionality instead of file structure, allowing users to browse the codebase by features and capabilities.",
      "userVisibleActions": [
        "View codebase organized by product features and functionality instead of file structure",
        "Navigate to code files by clicking on feature categories and subcategories",
        "See real-time updates to the product navigation tree when code documentation changes",
        "Expand and collapse feature groups to explore different areas of the product",
        "Click on file items to open and view source code files",
        "See visual indicators (icons and labels) for different types of product features",
        "Browse features grouped by user-facing categories, developer tools, and architectural components"
      ],
      "developerVisibleActions": [
        "Registers a custom tree view provider that organizes code by product functionality",
        "Monitors file system for changes to product documentation and updates the navigation tree automatically",
        "Loads enhanced product documentation from .shadow/docs directory to build the navigation structure",
        "Provides tree data through VSCode's TreeDataProvider interface for rendering in the sidebar",
        "Handles file watchers for both aggregate documentation and incremental file updates",
        "Manages workspace state and product documentation lifecycle",
        "Triggers tree refresh when documentation files are created, changed, or deleted",
        "Integrates with FileWatcherService for centralized file monitoring"
      ],
      "keyFunctions": [
        {
          "name": "getTreeItem",
          "desc": "Returns the visual representation (label, icon, collapsible state) for a navigation item",
          "inputs": "ProductNavItem element",
          "outputs": "TreeItem with display properties"
        },
        {
          "name": "getChildren",
          "desc": "Returns child navigation items for a given parent, building the hierarchical product navigation structure",
          "inputs": "Optional parent ProductNavItem",
          "outputs": "Array of child ProductNavItem objects"
        },
        {
          "name": "refresh",
          "desc": "Reloads product documentation and updates the navigation tree view",
          "inputs": "None",
          "outputs": "Promise that resolves when refresh is complete"
        },
        {
          "name": "loadProductDocumentation",
          "desc": "Loads enhanced product documentation from the workspace's shadow directory",
          "inputs": "None",
          "outputs": "EnhancedProductDocumentation object or null"
        },
        {
          "name": "setupFileWatcher",
          "desc": "Configures file system watchers to detect changes to product documentation files",
          "inputs": "None",
          "outputs": "None (side effect: sets up file watchers)"
        },
        {
          "name": "openFile",
          "desc": "Opens a source code file in the editor when user clicks on a navigation item",
          "inputs": "ProductNavItem representing a file",
          "outputs": "Promise that resolves when file is opened"
        },
        {
          "name": "buildFeatureTree",
          "desc": "Constructs the hierarchical navigation tree from product documentation features",
          "inputs": "EnhancedProductDocumentation",
          "outputs": "Array of top-level ProductNavItem objects"
        }
      ],
      "dependencies": [
        "vscode",
        "fileDocumentation (EnhancedProductDocumentation, FileSummary, ModuleSummary)",
        "path",
        "fs",
        "domain/services/fileWatcherService"
      ],
      "intent": "This file exists to replace traditional file-based navigation with a product-centric approach that organizes code by what it does rather than where it lives. It solves the problem of developers and users struggling to understand a codebase's functionality when navigating through arbitrary file/folder structures. By presenting code through the lens of features and capabilities, it makes codebases more discoverable and understandable, especially for new team members or when working with unfamiliar code.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a product-centric navigation view that organizes code by functionality instead of file structure, allowing users to browse the codebase by features and capabilities.\",\n  \"userVisibleActions\": [\n    \"View codebase organized by product features and functionality instead of file structure\",\n    \"Navigate to code files by clicking on feature categories and subcategories\",\n    \"See real-time updates to the product navigation tree when code documentation changes\",\n    \"Expand and collapse feature groups to explore different areas of the product\",\n    \"Click on file items to open and view source code files\",\n    \"See visual indicators (icons and labels) for different types of product features\",\n    \"Browse features grouped by user-facing categories, developer tools, and architectural components\"\n  ],\n  \"developerVisibleActions\": [\n    \"Registers a custom tree view provider that organizes code by product functionality\",\n    \"Monitors file system for changes to product documentation and updates the navigation tree automatically\",\n    \"Loads enhanced product documentation from .shadow/docs directory to build the navigation structure\",\n    \"Provides tree data through VSCode's TreeDataProvider interface for rendering in the sidebar\",\n    \"Handles file watchers for both aggregate documentation and incremental file updates\",\n    \"Manages workspace state and product documentation lifecycle\",\n    \"Triggers tree refresh when documentation files are created, changed, or deleted\",\n    \"Integrates with FileWatcherService for centralized file monitoring\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the visual representation (label, icon, collapsible state) for a navigation item\",\n      \"inputs\": \"ProductNavItem element\",\n      \"outputs\": \"TreeItem with display properties\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child navigation items for a given parent, building the hierarchical product navigation structure\",\n      \"inputs\": \"Optional parent ProductNavItem\",\n      \"outputs\": \"Array of child ProductNavItem objects\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Reloads product documentation and updates the navigation tree view\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Promise that resolves when refresh is complete\"\n    },\n    {\n      \"name\": \"loadProductDocumentation\",\n      \"desc\": \"Loads enhanced product documentation from the workspace's shadow directory\",\n      \"inputs\": \"None\",\n      \"outputs\": \"EnhancedProductDocumentation object or null\"\n    },\n    {\n      \"name\": \"setupFileWatcher\",\n      \"desc\": \"Configures file system watchers to detect changes to product documentation files\",\n      \"inputs\": \"None\",\n      \"outputs\": \"None (side effect: sets up file watchers)\"\n    },\n    {\n      \"name\": \"openFile\",\n      \"desc\": \"Opens a source code file in the editor when user clicks on a navigation item\",\n      \"inputs\": \"ProductNavItem representing a file\",\n      \"outputs\": \"Promise that resolves when file is opened\"\n    },\n    {\n      \"name\": \"buildFeatureTree\",\n      \"desc\": \"Constructs the hierarchical navigation tree from product documentation features\",\n      \"inputs\": \"EnhancedProductDocumentation\",\n      \"outputs\": \"Array of top-level ProductNavItem objects\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fileDocumentation (EnhancedProductDocumentation, FileSummary, ModuleSummary)\",\n    \"path\",\n    \"fs\",\n    \"domain/services/fileWatcherService\"\n  ],\n  \"intent\": \"This file exists to replace traditional file-based navigation with a product-centric approach that organizes code by what it does rather than where it lives. It solves the problem of developers and users struggling to understand a codebase's functionality when navigating through arbitrary file/folder structures. By presenting code through the lens of features and capabilities, it makes codebases more discoverable and understandable, especially for new team members or when working with unfamiliar code.\"\n}\n```"
    },
    {
      "file": "src/reportsTreeProvider.ts",
      "role": "Core Logic",
      "purpose": "Provides a tree view sidebar that displays all available Shadow Watch reports with their generation status and allows users to open them.",
      "userVisibleActions": [
        "View a tree list of all Shadow Watch report types in the sidebar",
        "See which reports have been generated (green file icon) and which haven't (gray slash icon)",
        "See when each report was last generated in the tooltip",
        "Click on a generated report to open it in the editor",
        "See descriptive tooltips explaining what each report type contains",
        "View report file paths and timestamps on hover"
      ],
      "developerVisibleActions": [
        "Register report generation events to update the tree view",
        "Track five report types: workspace, product, architecture, refactoring, and unit-test",
        "Refresh the tree view automatically when reports are generated or deleted",
        "Handle report metadata including path, timestamp, and description",
        "Provide context values for available/unavailable reports to enable different menu actions",
        "Emit tree data change events to trigger UI updates"
      ],
      "keyFunctions": [
        {
          "name": "ReportTreeItem.constructor",
          "desc": "Creates a tree item representing a report with visual indicators for availability status",
          "inputs": "label, reportType, filePath, description, timestamp",
          "outputs": "TreeItem with icon, tooltip, command, and context value"
        },
        {
          "name": "getChildren",
          "desc": "Returns the list of all report types to display in the tree view",
          "inputs": "element (optional parent item)",
          "outputs": "Array of ReportTreeItem objects"
        },
        {
          "name": "refresh",
          "desc": "Triggers a refresh of the tree view to show updated report statuses",
          "inputs": "none",
          "outputs": "void (fires onDidChangeTreeData event)"
        },
        {
          "name": "updateReport",
          "desc": "Updates the metadata for a specific report type when it's generated or modified",
          "inputs": "reportInfo (type, path, timestamp, label, description)",
          "outputs": "void (updates internal map and refreshes tree)"
        },
        {
          "name": "deleteReport",
          "desc": "Marks a report as unavailable when it's deleted",
          "inputs": "reportType",
          "outputs": "void (removes from map and refreshes tree)"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "Replaces the old webview-based report viewer with a permanent sidebar pane that gives users a centralized location to see all report types, their availability status, and quick access to open them. Solves the problem of users not knowing which reports exist, whether they've been generated, and how to access them.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view sidebar that displays all available Shadow Watch reports with their generation status and allows users to open them.\",\n  \"userVisibleActions\": [\n    \"View a tree list of all Shadow Watch report types in the sidebar\",\n    \"See which reports have been generated (green file icon) and which haven't (gray slash icon)\",\n    \"See when each report was last generated in the tooltip\",\n    \"Click on a generated report to open it in the editor\",\n    \"See descriptive tooltips explaining what each report type contains\",\n    \"View report file paths and timestamps on hover\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register report generation events to update the tree view\",\n    \"Track five report types: workspace, product, architecture, refactoring, and unit-test\",\n    \"Refresh the tree view automatically when reports are generated or deleted\",\n    \"Handle report metadata including path, timestamp, and description\",\n    \"Provide context values for available/unavailable reports to enable different menu actions\",\n    \"Emit tree data change events to trigger UI updates\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"ReportTreeItem.constructor\",\n      \"desc\": \"Creates a tree item representing a report with visual indicators for availability status\",\n      \"inputs\": \"label, reportType, filePath, description, timestamp\",\n      \"outputs\": \"TreeItem with icon, tooltip, command, and context value\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns the list of all report types to display in the tree view\",\n      \"inputs\": \"element (optional parent item)\",\n      \"outputs\": \"Array of ReportTreeItem objects\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Triggers a refresh of the tree view to show updated report statuses\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void (fires onDidChangeTreeData event)\"\n    },\n    {\n      \"name\": \"updateReport\",\n      \"desc\": \"Updates the metadata for a specific report type when it's generated or modified\",\n      \"inputs\": \"reportInfo (type, path, timestamp, label, description)\",\n      \"outputs\": \"void (updates internal map and refreshes tree)\"\n    },\n    {\n      \"name\": \"deleteReport\",\n      \"desc\": \"Marks a report as unavailable when it's deleted\",\n      \"inputs\": \"reportType\",\n      \"outputs\": \"void (removes from map and refreshes tree)\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"Replaces the old webview-based report viewer with a permanent sidebar pane that gives users a centralized location to see all report types, their availability status, and quick access to open them. Solves the problem of users not knowing which reports exist, whether they've been generated, and how to access them.\"\n}\n```"
    },
    {
      "file": "src/staticAnalysisViewer.ts",
      "role": "GUI View",
      "purpose": "Displays a tree view of static code analysis issues organized by severity (errors, warnings, info) for users to browse and navigate to problem locations.",
      "userVisibleActions": [
        "View static analysis issues organized by severity categories (errors, warnings, info)",
        "See a summary count of total issues found",
        "Click on an issue to navigate to the file and line where it was detected",
        "See 'No static issues found' message when analysis finds no problems",
        "View issue descriptions and affected file locations in the tree view",
        "Expand/collapse severity categories to show/hide issues",
        "See icons indicating issue severity (error, warning, info)"
      ],
      "developerVisibleActions": [
        "Set insights data from analysis results to populate the tree view",
        "Refresh the tree view to update displayed issues",
        "Trigger 'Analyze Workspace' command to check for issues",
        "Navigate to specific file locations when issues are selected",
        "Organize issues into error, warning, and info severity categories",
        "Display formatted file paths and line numbers for each issue"
      ],
      "keyFunctions": [
        {
          "name": "setInsights",
          "desc": "Updates the tree view with new static analysis results",
          "inputs": "Array of Insight objects containing issue data",
          "outputs": "void (triggers tree refresh)"
        },
        {
          "name": "refresh",
          "desc": "Refreshes the tree view display to show current insights",
          "inputs": "none",
          "outputs": "void (fires tree data change event)"
        },
        {
          "name": "getTreeItem",
          "desc": "Returns the visual representation of a tree item",
          "inputs": "StaticAnalysisItem element",
          "outputs": "vscode.TreeItem for display"
        },
        {
          "name": "getChildren",
          "desc": "Provides child items for tree hierarchy (categories and issues)",
          "inputs": "Optional parent StaticAnalysisItem",
          "outputs": "Promise of StaticAnalysisItem array"
        },
        {
          "name": "getRootItems",
          "desc": "Generates top-level tree items including summary and severity categories",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for root level"
        },
        {
          "name": "getErrorItems",
          "desc": "Retrieves all error-severity issues for display",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for errors"
        },
        {
          "name": "getWarningItems",
          "desc": "Retrieves all warning-severity issues for display",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for warnings"
        },
        {
          "name": "getInfoItems",
          "desc": "Retrieves all info-severity issues for display",
          "inputs": "none",
          "outputs": "Array of StaticAnalysisItem for info items"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "./insightGenerator"
      ],
      "intent": "Provides a structured, browsable tree view interface for developers to review static code analysis results, organized by severity level, with quick navigation to problem locations in the codebase.",
      "rawContent": "```json\n{\n  \"purpose\": \"Displays a tree view of static code analysis issues organized by severity (errors, warnings, info) for users to browse and navigate to problem locations.\",\n  \"userVisibleActions\": [\n    \"View static analysis issues organized by severity categories (errors, warnings, info)\",\n    \"See a summary count of total issues found\",\n    \"Click on an issue to navigate to the file and line where it was detected\",\n    \"See 'No static issues found' message when analysis finds no problems\",\n    \"View issue descriptions and affected file locations in the tree view\",\n    \"Expand/collapse severity categories to show/hide issues\",\n    \"See icons indicating issue severity (error, warning, info)\"\n  ],\n  \"developerVisibleActions\": [\n    \"Set insights data from analysis results to populate the tree view\",\n    \"Refresh the tree view to update displayed issues\",\n    \"Trigger 'Analyze Workspace' command to check for issues\",\n    \"Navigate to specific file locations when issues are selected\",\n    \"Organize issues into error, warning, and info severity categories\",\n    \"Display formatted file paths and line numbers for each issue\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setInsights\",\n      \"desc\": \"Updates the tree view with new static analysis results\",\n      \"inputs\": \"Array of Insight objects containing issue data\",\n      \"outputs\": \"void (triggers tree refresh)\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Refreshes the tree view display to show current insights\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void (fires tree data change event)\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the visual representation of a tree item\",\n      \"inputs\": \"StaticAnalysisItem element\",\n      \"outputs\": \"vscode.TreeItem for display\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Provides child items for tree hierarchy (categories and issues)\",\n      \"inputs\": \"Optional parent StaticAnalysisItem\",\n      \"outputs\": \"Promise of StaticAnalysisItem array\"\n    },\n    {\n      \"name\": \"getRootItems\",\n      \"desc\": \"Generates top-level tree items including summary and severity categories\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for root level\"\n    },\n    {\n      \"name\": \"getErrorItems\",\n      \"desc\": \"Retrieves all error-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for errors\"\n    },\n    {\n      \"name\": \"getWarningItems\",\n      \"desc\": \"Retrieves all warning-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for warnings\"\n    },\n    {\n      \"name\": \"getInfoItems\",\n      \"desc\": \"Retrieves all info-severity issues for display\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Array of StaticAnalysisItem for info items\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"Provides a structured, browsable tree view interface for developers to review static code analysis results, organized by severity level, with quick navigation to problem locations in the codebase.\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [
    {
      "command": "shadow-watch.analyzeCode",
      "description": "Triggers comprehensive code analysis of the current workspace, generating insights, diagnostics, and updating all tree views"
    },
    {
      "command": "shadow-watch.openAnalysisViewer",
      "description": "Opens the Analysis Viewer panel showing codebase statistics, file structure, functions, and entry points"
    },
    {
      "command": "shadow-watch.openInsightsViewer",
      "description": "Opens the Insights Viewer displaying AI-generated architectural insights and code quality recommendations"
    },
    {
      "command": "shadow-watch.openStaticAnalysisViewer",
      "description": "Opens the Static Analysis Viewer showing detected issues organized by severity (errors, warnings, info)"
    },
    {
      "command": "shadow-watch.regenerateProductDocumentation",
      "description": "Triggers AI-powered generation of product-level documentation describing the codebase's purpose and architecture"
    },
    {
      "command": "shadow-watch.regenerateInsights",
      "description": "Regenerates AI-powered code insights including architectural patterns, technical decisions, and improvement suggestions"
    },
    {
      "command": "shadow-watch.regenerateUnitTests",
      "description": "Generates AI-powered unit test plans identifying gaps in test coverage"
    },
    {
      "command": "shadow-watch.regenerateReport",
      "description": "Regenerates a specific report type (workspace, product, architecture, or unit test documentation)"
    },
    {
      "command": "shadow-watch.clearCache",
      "description": "Clears cached analysis results, forcing a fresh analysis on next run"
    },
    {
      "command": "shadow-watch.configureLLM",
      "description": "Opens configuration for LLM provider settings (API keys, model selection)"
    },
    {
      "command": "shadow-watch.copyInsights",
      "description": "Copies formatted analysis insights to clipboard for use with external AI assistants"
    },
    {
      "command": "shadow-watch.openReport",
      "description": "Opens a specific generated report in the VS Code editor"
    }
  ],
  "workers": [
    {
      "name": "File Watcher",
      "description": "Monitors TypeScript file saves and triggers automatic analysis",
      "jobFlow": "User saves a TypeScript file → File watcher detects change → Throttles rapid saves → Triggers code analysis → Updates all views and diagnostics → Displays results in tree views and Problems panel"
    },
    {
      "name": "LLM Analysis Pipeline",
      "description": "Orchestrates AI-powered code analysis and documentation generation",
      "jobFlow": "User triggers analysis command → Code is parsed and analyzed for structure/metrics → Results formatted into LLM prompt → API call to OpenAI/Claude → Structured response parsed → Insights/documentation generated → Results saved to workspace → Tree views updated → User notified of completion"
    },
    {
      "name": "Cache Manager",
      "description": "Manages persistent storage and automatic expiration of analysis results",
      "jobFlow": "Analysis completes → Results serialized to JSON → Saved to .shadow/cache directory with timestamp → On workspace open, checks cache age → If under 24 hours, loads from cache → If expired, triggers fresh analysis → Cache can be manually cleared via command"
    },
    {
      "name": "Diagnostics Provider",
      "description": "Converts code insights into VS Code diagnostics displayed in Problems panel",
      "jobFlow": "Insights generated → Each insight mapped to diagnostic (error/warning/info) → Diagnostics associated with file locations and line numbers → Problems panel populated → Editor shows squiggles at problem locations → User clicks diagnostic → Editor navigates to problem location"
    }
  ],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-19T21:25:31.659Z"
  }
}