{
  "overallAssessment": "Shadow Watch exhibits a monolithic architecture with clear signs of evolution from a simpler tool into a more complex AI-augmented analysis platform. The extension follows a single-entry point pattern (src/extension.ts) appropriate for VS Code extensions, but the internal organization reveals significant architectural debt. The codebase contains two massive service files (llmService.ts at 2107 lines and llmIntegration.ts at 1827 lines) that appear to handle multiple responsibilities including AI provider management, response parsing, retry logic, rate limiting, and business logic orchestration. While some domain-driven design patterns are emerging (domain/bootstrap/, domain/handlers/, domain/services/), the architecture remains inconsistent with core business logic split between old monolithic services and newer domain-oriented modules.\n\nThe architecture struggles with layer separation and dependency management. Business logic, presentation logic, and infrastructure concerns are frequently mixed within the same files. The src/ directory contains 19 files at the root level, many of which (analyzer.ts, llmIntegration.ts, llmService.ts, insightsTreeView.ts, insightsViewer.ts) combine multiple architectural responsibilities. The emergence of a domain/ subdirectory with bootstrap, handlers, services, prompts, and formatters suggests an attempt to introduce clean architecture principles, but this effort is incomplete - the majority of business logic still resides in the original monolithic files. The ai/ subdirectory properly separates provider-specific concerns, but the llmService.ts and llmIntegration.ts files in src/ still handle too many AI-related responsibilities that should be delegated to the ai/ layer. The architecture would benefit significantly from completing the domain-driven refactoring, extracting responsibilities from the monolithic services into focused domain services, and establishing clear boundaries between presentation (UI/webview), application (orchestration), domain (business logic), and infrastructure (AI providers, file I/O, caching) layers.",
  "strengths": [
    "Clear AI provider abstraction layer (src/ai/providers/) that properly isolates OpenAI, Anthropic, and custom provider implementations behind ILLMProvider interface, supporting the product's multi-AI-tool integration goal",
    "Domain-driven design patterns emerging in src/domain/ with separate concerns for bootstrapping, command registration, navigation handling, and prompt building, showing architectural evolution toward better separation",
    "Proper separation of AI-specific concerns (rate limiting, retry handling, response parsing) into dedicated modules under src/ai/, avoiding mixing these cross-cutting concerns with business logic",
    "Configuration management centralized in src/config/configurationManager.ts, providing single source of truth for extension settings and AI provider configuration",
    "Incremental analysis architecture with caching (src/cache.ts, src/storage/incrementalStorage.ts) that aligns with non-blocking real-time feedback requirements",
    "File watcher service (src/domain/services/fileWatcherService.ts) properly encapsulates file monitoring concerns separate from analysis logic"
  ],
  "issues": [
    {
      "title": "God Object: llmService.ts Violates Single Responsibility",
      "description": "The llmService.ts file contains 2107 lines and 87 functions, handling multiple responsibilities including AI model interaction, prompt management, response parsing, error handling, and business logic orchestration. This creates a maintenance bottleneck and violates single responsibility principle. **Proposed Fix**: Extract responsibilities into focused services: (1) Create src/domain/services/aiOrchestrationService.ts for coordinating AI analysis workflows, (2) Move prompt construction logic to src/domain/prompts/promptBuilder.ts (already exists but underutilized), (3) Delegate response parsing entirely to src/ai/llmResponseParser.ts, (4) Move retry/rate limiting coordination to src/ai/ layer services, (5) Extract documentation generation into src/domain/services/documentationService.ts. The remaining llmService.ts should focus solely on low-level AI provider communication.",
      "relevantFiles": [
        "src/llmService.ts",
        "src/ai/llmResponseParser.ts",
        "src/domain/prompts/promptBuilder.ts"
      ],
      "relevantFunctions": [
        "llmService class",
        "generateProductDocumentation",
        "generateArchitectureInsights",
        "parseStructuredResponse"
      ]
    },
    {
      "title": "God Object: llmIntegration.ts Mixes UI and Business Logic",
      "description": "The llmIntegration.ts file contains 1827 lines and 146 functions, combining VS Code UI integration, business logic for analysis types, and orchestration concerns. This violates separation of concerns between presentation and application layers. **Proposed Fix**: (1) Extract UI-specific logic (webview creation, tree view management, command handlers) into src/ui/ layer - create src/ui/analysisPanel.ts, src/ui/insightsPanel.ts, src/ui/commandHandlers.ts, (2) Move analysis orchestration logic to src/domain/services/analysisOrchestrationService.ts, (3) Extract analysis type strategies (product docs, architecture, unit tests) into separate strategy classes under src/domain/strategies/, (4) Keep only integration glue code that connects UI commands to domain services.",
      "relevantFiles": [
        "src/llmIntegration.ts",
        "src/insightsTreeView.ts",
        "src/insightsViewer.ts",
        "src/analysisViewer.ts"
      ],
      "relevantFunctions": [
        "LLMIntegration class",
        "runProductDocumentation",
        "runArchitectureAnalysis",
        "runUnitTestDocumentation",
        "updateInsightsTreeView"
      ]
    },
    {
      "title": "Layer Violation: Business Logic in Presentation Components",
      "description": "Files like insightsTreeView.ts (957 lines), insightsViewer.ts (778 lines), and analysisViewer.ts (525 lines) contain both presentation logic (tree rendering, webview HTML generation) and business logic (analysis result processing, data transformation, filtering). This violates layered architecture principles. **Proposed Fix**: (1) Create src/domain/services/insightsService.ts to handle business logic for processing analysis results, filtering by severity, and preparing data for display, (2) Create src/ui/viewModels/ directory with ViewModel classes that transform domain data into UI-ready structures, (3) Refactor viewer files to focus solely on VS Code API interaction and rendering, delegating all business logic to domain services and ViewModels.",
      "relevantFiles": [
        "src/insightsTreeView.ts",
        "src/insightsViewer.ts",
        "src/analysisViewer.ts"
      ],
      "relevantFunctions": [
        "InsightsTreeViewProvider class",
        "InsightsViewer class",
        "AnalysisViewer class",
        "refresh",
        "getTreeItem",
        "getChildren"
      ]
    },
    {
      "title": "Missing Abstraction: Direct File System Access Throughout Codebase",
      "description": "Multiple files directly use Node.js fs module for file operations (analyzer.ts, cache.ts, fileAccessHelper.ts, incrementalStorage.ts) without a consistent abstraction layer. This creates tight coupling to file system implementation and makes testing difficult. **Proposed Fix**: (1) Create src/infrastructure/fileSystem/ directory, (2) Define IFileSystemProvider interface with operations like readFile, writeFile, exists, stat, readDir, (3) Implement FileSystemProvider that wraps Node.js fs module, (4) Implement MockFileSystemProvider for testing, (5) Inject IFileSystemProvider into all services that need file access, (6) Update analyzer.ts, cache.ts, fileAccessHelper.ts, and incrementalStorage.ts to use the abstraction.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/cache.ts",
        "src/fileAccessHelper.ts",
        "src/storage/incrementalStorage.ts"
      ],
      "relevantFunctions": [
        "Analyzer class",
        "Cache class",
        "FileAccessHelper class",
        "IncrementalStorage class"
      ]
    },
    {
      "title": "Circular Dependency: analyzer.ts and cache.ts",
      "description": "The analyzer.ts file imports from cache.ts, and cache.ts imports from analyzer.ts, creating a circular dependency. This indicates improper separation of concerns and can cause initialization issues. **Proposed Fix**: (1) Extract shared interfaces/types into src/domain/models/analysisModels.ts, (2) Make Cache depend only on domain models, not on Analyzer implementation, (3) Introduce dependency injection so Analyzer receives Cache through constructor rather than importing directly, (4) Consider making Cache a pure infrastructure service that doesn't know about analysis domain concepts - it should cache generic data, not analysis-specific results.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/cache.ts"
      ],
      "relevantFunctions": [
        "Analyzer class",
        "Cache class",
        "analyzeWorkspace",
        "get",
        "set"
      ]
    },
    {
      "title": "Inconsistent Error Handling Patterns",
      "description": "Error handling is inconsistent across the codebase. Some files use try-catch with logging (llmService.ts), some use error handler utilities (src/utils/errorHandler.ts), some return error objects, and some throw exceptions. This makes debugging difficult and error recovery unpredictable. **Proposed Fix**: (1) Establish consistent error handling strategy using Result<T, E> pattern or consistent exception hierarchy, (2) Create src/domain/errors/ directory with specific error classes (AnalysisError, AIProviderError, FileSystemError, ConfigurationError), (3) Update src/utils/errorHandler.ts to handle domain-specific errors consistently, (4) Implement error boundary pattern in UI layer to catch and display errors gracefully, (5) Add error recovery strategies for transient failures (retry logic for AI API calls, fallback for file access).",
      "relevantFiles": [
        "src/llmService.ts",
        "src/utils/errorHandler.ts",
        "src/ai/llmRetryHandler.ts",
        "src/extension.ts"
      ],
      "relevantFunctions": [
        "handleError",
        "retryWithExponentialBackoff",
        "ErrorHandler class"
      ]
    },
    {
      "title": "Root Directory Clutter with 14 Files",
      "description": "The root directory contains 14 files including 6 markdown documentation files, 2 .vsix packages, configuration files, and scripts. This makes navigation difficult and obscures the project structure. **Proposed Fix**: (1) Create docs/ directory and move GET_STARTED.md, IMPLEMENTATION_GUIDE.md, MENU_STRUCTURE.md, PLUGIN_DESIGN.md, QUICK_START.md, REFACTORING_PLAN.md to docs/, (2) Create releases/ or dist/ directory and move shadow-watch-1.0.0.vsix and shadow-watch.vsix there, (3) Keep only essential files in root: README.md, LICENSE, package.json, package-lock.json, tsconfig.json, webpack.config.js, (4) Update references in documentation to new paths.",
      "relevantFiles": [
        "GET_STARTED.md",
        "IMPLEMENTATION_GUIDE.md",
        "MENU_STRUCTURE.md",
        "PLUGIN_DESIGN.md",
        "QUICK_START.md",
        "REFACTORING_PLAN.md",
        "shadow-watch-1.0.0.vsix",
        "shadow-watch.vsix"
      ],
      "relevantFunctions": []
    },
    {
      "title": "Orphaned Infrastructure Service Not Integrated",
      "description": "The progressService.ts file in src/infrastructure/ is not imported by any other file, suggesting it was intended for progress reporting but never integrated. This represents incomplete functionality. **Proposed Fix**: (1) If progress reporting is needed, integrate ProgressService into long-running operations like AI analysis, file watching, and incremental storage, (2) Update llmService.ts and llmIntegration.ts to use ProgressService for reporting AI analysis progress to VS Code UI, (3) Add progress reporting to analyzer.ts for workspace analysis operations, (4) If progress reporting is not needed, remove the file to eliminate dead code.",
      "relevantFiles": [
        "src/infrastructure/progressService.ts",
        "src/llmService.ts",
        "src/llmIntegration.ts",
        "src/analyzer.ts"
      ],
      "relevantFunctions": [
        "ProgressService class",
        "withProgress",
        "reportProgress"
      ]
    },
    {
      "title": "Orphaned Base Webview Provider Pattern Not Used",
      "description": "The baseWebviewProvider.ts file defines an abstract base class for webview providers but is not imported or extended by any webview implementation. The existing webview code (insightsViewer.ts, analysisViewer.ts, staticAnalysisViewer.ts) doesn't use this abstraction. **Proposed Fix**: (1) If the base class provides valuable abstraction, refactor existing webview viewers to extend BaseWebviewProvider, extracting common webview lifecycle management, (2) If the abstraction doesn't fit current needs, remove baseWebviewProvider.ts, (3) Consider creating a WebviewFactory that uses the base class to standardize webview creation across different view types.",
      "relevantFiles": [
        "src/ui/webview/baseWebviewProvider.ts",
        "src/insightsViewer.ts",
        "src/analysisViewer.ts",
        "src/staticAnalysisViewer.ts"
      ],
      "relevantFunctions": [
        "BaseWebviewProvider class",
        "InsightsViewer class",
        "AnalysisViewer class"
      ]
    },
    {
      "title": "Duplicate Analysis Orchestration Logic",
      "description": "Both llmService.ts and llmIntegration.ts contain logic for orchestrating AI analysis workflows, determining which AI provider to use, handling retries, and managing analysis state. This creates duplicate code paths and inconsistent behavior. **Proposed Fix**: (1) Create single source of truth for analysis orchestration in src/domain/services/analysisOrchestrationService.ts, (2) This service should handle workflow: validate input -> select provider -> execute analysis -> parse response -> handle errors -> store results, (3) Both llmService.ts and llmIntegration.ts should delegate to this orchestration service, (4) Use strategy pattern for different analysis types (product docs, architecture, unit tests) with common orchestration flow.",
      "relevantFiles": [
        "src/llmService.ts",
        "src/llmIntegration.ts",
        "src/ai/llmRetryHandler.ts",
        "src/state/llmStateManager.ts"
      ],
      "relevantFunctions": [
        "generateProductDocumentation",
        "generateArchitectureInsights",
        "runProductDocumentation",
        "runArchitectureAnalysis"
      ]
    }
  ],
  "organization": "The codebase exhibits poor file organization that undermines architectural clarity and maintainability. The root directory contains 14 files including 6 markdown documentation files that should be in a docs/ directory, 2 .vsix package files that should be in a releases/ or dist/ directory, and various configuration files mixed together. This clutter makes it difficult to quickly understand the project structure and locate important files. The src/ directory contains 19 files at the root level, many of which are large monolithic services (llmService.ts at 2107 lines, llmIntegration.ts at 1827 lines) that violate single responsibility principle. These files should be broken down and organized into subdirectories that reflect architectural layers and responsibilities.\n\nThe emergence of a domain/ subdirectory suggests an incomplete migration toward domain-driven design. This directory contains bootstrap/, formatters/, handlers/, prompts/, and services/ subdirectories, indicating an attempt to organize code by architectural responsibility. However, the majority of business logic still resides outside this structure in the root src/ files. The src/ui/ directory contains only webview components, but other UI-related files (insightsTreeView.ts, insightsViewer.ts, analysisViewer.ts) remain in src/ root. Similarly, the src/ai/ directory properly contains provider implementations and AI-specific utilities, but the massive llmService.ts file in src/ root handles many AI-related concerns that should be delegated to the ai/ layer. The infrastructure/ directory contains only two files (progressService.ts and persistence/analysisResultRepository.ts), but other infrastructure concerns like file watching, caching, and storage are scattered in src/ root. This inconsistent organization makes it difficult to navigate the codebase, understand architectural boundaries, and locate related functionality. A systematic reorganization into clear architectural layers (presentation, application, domain, infrastructure) would significantly improve maintainability and make the intended architecture explicit in the folder structure.",
  "entryPointsAnalysis": "The extension has a single well-defined entry point at dist/extension.js (specified in package.json main field), which is appropriate for VS Code extensions that must follow the extension API lifecycle. The source entry point is src/extension.ts (642 lines, 42 functions) which handles extension activation, command registration, and initialization of core services. This file properly uses the extensionBootstrapper.ts to delegate initialization responsibilities, showing good separation between entry point and bootstrap logic. The extension activates on workspace opening (onStartupFinished) and registers multiple commands for different user workflows: analyzing architecture, generating documentation, viewing insights, and navigating code. The single entry point aligns well with the product's architecture as a VS Code extension that provides multiple interfaces (sidebar, webviews, commands, inline diagnostics) through a unified activation lifecycle. This approach is correct and should be maintained.",
  "orphanedFilesAnalysis": "Three orphaned files were identified: src/infrastructure/progressService.ts (139 lines), src/ui/webview/baseWebviewProvider.ts (84 lines), and webpack.config.js (37 lines). The progressService.ts file implements VS Code progress reporting functionality but is never imported, suggesting it was developed for long-running AI analysis operations but never integrated into the workflow. This represents incomplete functionality - either it should be integrated into llmService.ts and analyzer.ts for progress reporting, or removed if progress reporting is not needed. The baseWebviewProvider.ts file defines an abstract base class for webview providers following a template pattern, but none of the existing webview implementations (insightsViewer.ts, analysisViewer.ts, staticAnalysisViewer.ts) extend it. This suggests either the abstraction was created but not adopted, or the webview implementations were written before the base class was created. The webpack.config.js file being orphaned is likely a false positive since it's used by the build system rather than imported by TypeScript code. The progressService.ts and baseWebviewProvider.ts files should either be integrated into the architecture or removed to eliminate dead code.",
  "folderReorganization": "**Documentation Files**: Move GET_STARTED.md, IMPLEMENTATION_GUIDE.md, MENU_STRUCTURE.md, PLUGIN_DESIGN.md, QUICK_START.md, REFACTORING_PLAN.md from root to docs/ directory. Create docs/guides/ subdirectory for user-facing guides (GET_STARTED.md, QUICK_START.md) and docs/design/ for architectural documentation (IMPLEMENTATION_GUIDE.md, PLUGIN_DESIGN.md, MENU_STRUCTURE.md, REFACTORING_PLAN.md). Keep README.md and LICENSE in root.\n\n**Release Artifacts**: Move shadow-watch-1.0.0.vsix and shadow-watch.vsix from root to releases/ directory. Update build scripts to output to releases/ instead of root.\n\n**Presentation Layer Reorganization**: Create src/ui/views/ directory and move insightsTreeView.ts, insightsViewer.ts, analysisViewer.ts, staticAnalysisViewer.ts from src/ root to src/ui/views/. Move productNavigator.ts and unitTestsNavigator.ts to src/ui/navigation/. This consolidates all VS Code UI interaction code under src/ui/.\n\n**Application Layer Creation**: Create src/application/ directory for orchestration logic. Extract orchestration code from llmIntegration.ts into src/application/analysisOrchestrator.ts. Create src/application/commands/ directory and extract command handler logic into separate command handler files (analyzeCommand.ts, documentCommand.ts, insightsCommand.ts).\n\n**Domain Layer Expansion**: Move llmFormatter.ts to src/domain/formatters/ (alongside existing documentationFormatter.ts). Move insightGenerator.ts to src/domain/services/. Extract analysis strategies from llmIntegration.ts into src/domain/strategies/ with separate files for productDocStrategy.ts, architectureStrategy.ts, unitTestStrategy.ts. Move llmSchemas.ts to src/domain/models/.\n\n**Infrastructure Layer Organization**: Move analyzer.ts, cache.ts, fileAccessHelper.ts, fileWatcher.ts to src/infrastructure/analysis/. Move logger.ts to src/infrastructure/logging/. Create src/infrastructure/fileSystem/ and move file access logic there with proper abstraction. Move diagnosticsProvider.ts to src/infrastructure/diagnostics/.\n\n**AI Layer Consolidation**: Move llmService.ts to src/ai/llmService.ts (out of src/ root). Extract provider coordination logic into src/ai/providerCoordinator.ts. Keep rate limiting, retry handling, and response parsing in their current locations under src/ai/.\n\n**State Management**: Expand src/state/ directory. Move analysis state management from llmIntegration.ts to src/state/analysisState.ts. Create src/state/viewState.ts for managing UI state.\n\n**Final src/ Root Structure**: After reorganization, src/ root should contain only extension.ts and fileDocumentation.ts (if it's a cross-cutting concern). All other files should be organized into subdirectories: ui/, application/, domain/, infrastructure/, ai/, state/, config/, context/, storage/, utils/.",
  "recommendations": [
    {
      "title": "Complete Domain-Driven Design Migration",
      "description": "**If you want to improve maintainability and make architectural boundaries explicit**: Complete the migration to domain-driven design by moving all business logic from src/ root files (llmService.ts, llmIntegration.ts, analyzer.ts) into the src/domain/ structure. This aligns with the product's complexity level - Shadow Watch has distinct bounded contexts (AI analysis, file monitoring, insights presentation, documentation generation) that benefit from clear domain separation. Extract services from monolithic files into focused domain services, create explicit application services for orchestration, and establish clear interfaces between layers. This will make the codebase easier to understand for new contributors, improve testability by isolating business logic, and enable independent evolution of different product areas (e.g., adding new analysis types without modifying core services).",
      "relevantFiles": [
        "src/llmService.ts",
        "src/llmIntegration.ts",
        "src/analyzer.ts",
        "src/domain/services/",
        "src/application/"
      ],
      "relevantFunctions": [
        "llmService class",
        "LLMIntegration class",
        "Analyzer class"
      ]
    },
    {
      "title": "Implement Repository Pattern for Analysis Results",
      "description": "**If you want to support multiple storage backends or improve testability**: Introduce repository pattern for analysis results persistence. Currently, incrementalStorage.ts and analysisResultRepository.ts handle storage, but there's no abstraction that would allow swapping storage implementations (e.g., local file system vs. remote database vs. in-memory for testing). Create src/domain/repositories/ directory with IAnalysisRepository interface, implement FileSystemAnalysisRepository as current implementation, and add InMemoryAnalysisRepository for testing. This becomes especially valuable if you plan to add cloud synchronization features or want to persist analysis results to a team-shared database for collaborative architecture monitoring.",
      "relevantFiles": [
        "src/storage/incrementalStorage.ts",
        "src/infrastructure/persistence/analysisResultRepository.ts"
      ],
      "relevantFunctions": [
        "IncrementalStorage class",
        "AnalysisResultRepository class"
      ]
    },
    {
      "title": "Extract Analysis Type Strategies",
      "description": "**If you want to add new analysis types without modifying core services**: Implement strategy pattern for different analysis types (product documentation, architecture insights, unit test documentation). Currently, llmIntegration.ts contains large switch statements and separate methods for each analysis type, making it difficult to add new analysis types without modifying the core integration logic. Create src/domain/strategies/IAnalysisStrategy.ts interface with execute() method, implement ProductDocStrategy, ArchitectureStrategy, UnitTestStrategy classes, and use a strategy registry to select and execute the appropriate strategy. This aligns with the product roadmap if you plan to add more analysis types (e.g., API documentation, dependency analysis, security vulnerability scanning) and makes the system more extensible.",
      "relevantFiles": [
        "src/llmIntegration.ts",
        "src/llmService.ts"
      ],
      "relevantFunctions": [
        "runProductDocumentation",
        "runArchitectureAnalysis",
        "runUnitTestDocumentation",
        "generateProductDocumentation"
      ]
    },
    {
      "title": "Introduce ViewModels for Presentation Logic",
      "description": "**If you want to decouple business logic from VS Code API**: Create ViewModel layer between domain services and UI components. Currently, presentation components (insightsTreeView.ts, insightsViewer.ts) mix VS Code API interaction with business logic for processing analysis results, filtering, and formatting. Create src/ui/viewModels/ directory with InsightsViewModel, AnalysisViewModel, NavigationViewModel classes that transform domain models into UI-ready data structures. This makes the domain layer portable (not tied to VS Code), improves testability of presentation logic, and would enable supporting multiple UI frameworks if you ever wanted to create a web-based version of Shadow Watch or support other IDEs.",
      "relevantFiles": [
        "src/insightsTreeView.ts",
        "src/insightsViewer.ts",
        "src/analysisViewer.ts"
      ],
      "relevantFunctions": [
        "InsightsTreeViewProvider class",
        "refresh",
        "getTreeItem",
        "InsightsViewer class"
      ]
    },
    {
      "title": "Implement Plugin System for Custom Analysis Rules",
      "description": "**If you want to allow users to add custom architecture rules or analysis patterns**: Create a plugin system that allows users to define custom analysis rules without modifying core code. This would involve: (1) defining IAnalysisPlugin interface with methods for registering custom rules, (2) creating plugin discovery mechanism that loads plugins from workspace .shadowwatch/plugins/ directory, (3) adding plugin lifecycle management (activate, deactivate, configure), (4) providing plugin API for accessing file analysis results and registering custom issues. This aligns with the product's goal of bridging human expertise with AI analysis - expert architects could create plugins for domain-specific patterns (e.g., microservices anti-patterns, React best practices, security patterns) that complement the general AI analysis.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/insightGenerator.ts",
        "src/extension.ts"
      ],
      "relevantFunctions": [
        "analyzeWorkspace",
        "generateInsights",
        "activate"
      ]
    },
    {
      "title": "Maintain Multi-Interface Architecture",
      "description": "**If you want to continue supporting diverse developer workflows**: Keep the multiple viewing interfaces (sidebar tree view, webview documentation, inline diagnostics, command palette) as they serve different user contexts. The sidebar tree view is optimal for browsing issues hierarchically when exploring codebase health, webviews provide detailed documentation when onboarding or understanding system architecture, inline diagnostics show issues directly in code context when editing, and command palette enables keyboard-driven workflows. This multi-interface approach aligns with the product's value proposition of integrating architecture insights into existing development workflow. However, ensure consistency across interfaces - use shared ViewModels to guarantee all interfaces display the same underlying data, and implement consistent interaction patterns (e.g., clicking an issue in any interface should navigate to relevant code).",
      "relevantFiles": [
        "src/insightsTreeView.ts",
        "src/insightsViewer.ts",
        "src/analysisViewer.ts",
        "src/diagnosticsProvider.ts",
        "src/extension.ts"
      ],
      "relevantFunctions": [
        "InsightsTreeViewProvider class",
        "InsightsViewer class",
        "AnalysisViewer class",
        "updateDiagnostics"
      ]
    },
    {
      "title": "Centralize Prompt Engineering",
      "description": "**If you want to improve AI analysis quality and make prompts maintainable**: Consolidate all LLM prompt construction in src/domain/prompts/promptBuilder.ts (currently 698 lines but underutilized). Currently, prompt strings are scattered across llmService.ts and llmIntegration.ts, making it difficult to optimize prompts, ensure consistency, and version control prompt evolution. Move all prompt templates to promptBuilder.ts, use template engine pattern (e.g., Handlebars or template literals) for prompt construction, version prompts for A/B testing, and implement prompt validation to ensure prompts include required context. This becomes critical as Shadow Watch's value proposition depends on prompt quality - better prompts yield better AI analysis, which yields better refactoring guidance for users.",
      "relevantFiles": [
        "src/domain/prompts/promptBuilder.ts",
        "src/llmService.ts",
        "src/llmIntegration.ts"
      ],
      "relevantFunctions": [
        "PromptBuilder class",
        "generateProductDocumentation",
        "generateArchitectureInsights"
      ]
    }
  ],
  "priorities": [
    {
      "title": "Decompose God Objects (llmService.ts and llmIntegration.ts)",
      "description": "Break down the two massive files (2107 and 1827 lines) into focused services following single responsibility principle. This is the highest priority because these god objects are the primary source of architectural debt and maintainability issues. The decomposition will enable all other refactorings and significantly improve code navigability. **Rationale**: These files combine too many responsibilities (AI orchestration, UI management, business logic, error handling, state management), making them difficult to understand, test, and modify. Extract into separate services for AI orchestration, analysis strategies, UI coordination, and state management. Impact: High (affects entire codebase). Risk: Medium (requires careful dependency management). Estimated Effort: 2-3 weeks.",
      "relevantFiles": [
        "src/llmService.ts",
        "src/llmIntegration.ts",
        "src/ai/",
        "src/domain/services/",
        "src/application/"
      ],
      "relevantFunctions": [
        "llmService class",
        "LLMIntegration class",
        "generateProductDocumentation",
        "runProductDocumentation",
        "generateArchitectureInsights",
        "runArchitectureAnalysis"
      ]
    },
    {
      "title": "Organize Documentation and Release Artifacts",
      "description": "Move 6 markdown documentation files from root to docs/ directory (organized into docs/guides/ and docs/design/ subdirectories) and move 2 .vsix package files to releases/ directory. This is high priority because it provides immediate improvement in project navigability with minimal risk. **Rationale**: Root directory clutter makes it difficult for new contributors to understand project structure and locate important files. Clean root directory creates professional first impression and improves repository organization. Impact: Medium (improves navigation and professionalism). Risk: Low (only file moves, update references). Estimated Effort: 2-4 hours.",
      "relevantFiles": [
        "GET_STARTED.md",
        "IMPLEMENTATION_GUIDE.md",
        "MENU_STRUCTURE.md",
        "PLUGIN_DESIGN.md",
        "QUICK_START.md",
        "REFACTORING_PLAN.md",
        "shadow-watch-1.0.0.vsix",
        "shadow-watch.vsix"
      ],
      "relevantFunctions": []
    },
    {
      "title": "Establish Clear Architectural Layers",
      "description": "Reorganize src/ directory into explicit architectural layers: src/ui/ (all presentation logic), src/application/ (orchestration services), src/domain/ (business logic), src/infrastructure/ (file I/O, caching, external services), src/ai/ (AI providers and utilities). Move 19 files currently in src/ root into appropriate layer directories. **Rationale**: Current flat structure obscures architectural intent and makes it difficult to understand system boundaries. Clear layering enforces separation of concerns, improves testability, and makes dependencies explicit. This enables independent evolution of layers and prevents presentation logic from mixing with business logic. Impact: High (affects entire architecture). Risk: Medium (requires updating imports). Estimated Effort: 1 week.",
      "relevantFiles": [
        "src/insightsTreeView.ts",
        "src/insightsViewer.ts",
        "src/analysisViewer.ts",
        "src/analyzer.ts",
        "src/cache.ts",
        "src/fileAccessHelper.ts",
        "src/llmFormatter.ts",
        "src/insightGenerator.ts"
      ],
      "relevantFunctions": [
        "InsightsTreeViewProvider class",
        "InsightsViewer class",
        "Analyzer class",
        "Cache class"
      ]
    },
    {
      "title": "Break Circular Dependency Between analyzer.ts and cache.ts",
      "description": "Resolve circular dependency between analyzer and cache modules by extracting shared interfaces to src/domain/models/, implementing dependency injection, and making cache a pure infrastructure service. **Rationale**: Circular dependencies cause initialization issues, make testing difficult, and indicate improper separation of concerns. This is high priority because it affects core analysis functionality and blocks proper layering. The fix involves extracting interfaces, introducing dependency injection, and ensuring unidirectional dependencies (domain -> infrastructure, not bidirectional). Impact: Medium (affects analysis workflow). Risk: Medium (requires careful refactoring). Estimated Effort: 3-5 days.",
      "relevantFiles": [
        "src/analyzer.ts",
        "src/cache.ts",
        "src/domain/models/"
      ],
      "relevantFunctions": [
        "Analyzer class",
        "Cache class",
        "analyzeWorkspace",
        "get",
        "set"
      ]
    },
    {
      "title": "Integrate or Remove Orphaned Infrastructure Services",
      "description": "Either integrate progressService.ts into long-running operations (AI analysis, file monitoring) or remove it if progress reporting is not needed. Similarly, integrate baseWebviewProvider.ts by refactoring existing webview implementations to use it, or remove it if the abstraction doesn't fit. **Rationale**: Orphaned code creates confusion about whether functionality is complete and increases maintenance burden. Progress reporting would improve user experience for long-running AI analyses, but only if actually implemented. The webview base class could reduce duplication across viewer implementations. Impact: Low to Medium (quality of life improvement). Risk: Low (isolated changes). Estimated Effort: 1-2 days per file.",
      "relevantFiles": [
        "src/infrastructure/progressService.ts",
        "src/ui/webview/baseWebviewProvider.ts",
        "src/llmService.ts",
        "src/insightsViewer.ts",
        "src/analysisViewer.ts"
      ],
      "relevantFunctions": [
        "ProgressService class",
        "BaseWebviewProvider class",
        "generateProductDocumentation",
        "InsightsViewer class"
      ]
    }
  ],
  "cursorPrompt": "You are refactoring a VS Code extension called Shadow Watch that provides AI-powered architecture analysis and documentation generation. The codebase has architectural debt with two god objects (llmService.ts at 2107 lines and llmIntegration.ts at 1827 lines) that mix multiple responsibilities. Your task is to refactor toward clean architecture with clear layers: UI (presentation), Application (orchestration), Domain (business logic), Infrastructure (file I/O, caching, AI providers).\n\nKey refactoring objectives:\n1. Decompose god objects into focused services following single responsibility principle\n2. Establish clear architectural layers with unidirectional dependencies\n3. Extract analysis type strategies (product docs, architecture, unit tests) into separate strategy classes\n4. Separate presentation logic from business logic using ViewModel pattern\n5. Resolve circular dependency between analyzer.ts and cache.ts\n6. Organize files into layer-based directory structure\n\nWhen refactoring:\n- Preserve all existing functionality and command handlers\n- Maintain support for multiple AI providers (OpenAI, Anthropic, custom)\n- Keep multi-interface architecture (sidebar, webviews, inline diagnostics)\n- Ensure analysis remains non-blocking with caching and incremental updates\n- Follow dependency injection patterns for testability\n- Extract interfaces for all cross-layer dependencies\n\nStart by decomposing llmService.ts: extract AI orchestration into src/application/analysisOrchestrator.ts, move prompt construction to src/domain/prompts/promptBuilder.ts, delegate response parsing to src/ai/llmResponseParser.ts, and create src/domain/services/ for business logic. Show me the refactored structure for llmService.ts first.",
  "productPurposeAnalysis": {
    "productPurpose": "Shadow Watch aims to bridge the gap between traditional static code analysis and modern AI-assisted development by continuously monitoring codebases for architectural issues and automatically formatting those issues for AI assistants. Its core mission is to eliminate friction in the AI-augmented development workflow by detecting problems in real-time, understanding what code does from a product perspective, and generating prompts that can be immediately pasted into AI tools for refactoring guidance.",
    "architectureRationale": "The architecture exists as a VS Code extension with a single entry point because the product is fundamentally about augmenting the developer's existing workflow within their primary development environment. Multiple user interfaces (sidebar, webview, inline diagnostics, CLI-like commands) exist because developers interact with architectural insights in different contexts: browsing issues hierarchically in the sidebar when exploring, viewing detailed documentation in webviews when understanding, seeing inline diagnostics when editing, and copying formatted prompts when collaborating with AI. The AI provider abstraction exists because different teams use different AI tools (ChatGPT, Claude, Cursor, custom models), and the product's value proposition depends on working seamlessly with whatever AI assistant the developer prefers. The continuous monitoring architecture with file watchers and caching exists because architectural feedback is most valuable when it's immediate and non-blocking - developers need to know about issues as they write code, not after running a separate analysis command.",
    "designDecisions": [
      "Multi-view presentation (sidebar tree + webview + inline diagnostics) - Reason: Developers need different views for different tasks: tree navigation for browsing issues by severity, webviews for reading comprehensive documentation, and inline diagnostics for seeing problems directly in code context where they can act on them immediately",
      "Continuous file monitoring with save-based triggers - Reason: Architectural issues compound over time, so catching them immediately when code is saved prevents technical debt accumulation and keeps feedback in the developer's working memory while the code is fresh",
      "AI provider abstraction layer supporting OpenAI, Anthropic, and custom endpoints - Reason: The product's value depends on integrating with whatever AI assistant developers already use, and forcing a single provider would create adoption friction and limit usefulness across different teams and organizations",
      "LLM-ready prompt generation with format options (Cursor, ChatGPT, generic) - Reason: Different AI assistants expect different prompt formats and context structures, so pre-formatting issues for specific tools eliminates the manual work of reformatting and increases likelihood developers will actually use AI for refactoring",
      "Caching layer for analysis results - Reason: Running static analysis on every save across large codebases would block development workflow, so caching previous results and running incremental analysis ensures the monitoring remains non-intrusive and performant",
      "Three types of AI-powered documentation (product, architecture, unit tests) - Reason: Developers need to understand codebases from multiple perspectives: what it does for users (product docs), how it's structured (architecture), and what's tested (unit tests), with each perspective serving different tasks like onboarding, refactoring, and test coverage assessment",
      "JSON schema validation for AI responses - Reason: AI model outputs are non-deterministic, so structured validation ensures the extension can reliably parse and display insights even when models produce slightly unexpected responses",
      "Severity-based issue categorization (errors, warnings, info) - Reason: Not all architectural issues are equally urgent, so categorizing by severity helps developers prioritize what to fix first and prevents analysis fatigue from overwhelming lists of minor issues",
      "Multi-language support across 9+ programming languages - Reason: Development teams work in polyglot environments, and providing consistent architectural analysis across languages eliminates the need for multiple tools and creates a unified workflow regardless of technology stack"
    ],
    "userGoals": [
      "Identify architectural problems in real-time as code is written to prevent technical debt before it solidifies",
      "Quickly understand what an unfamiliar codebase does from a user perspective without reading through implementation details",
      "Get AI-powered refactoring guidance by copying architectural issues directly into ChatGPT, Cursor, or Claude without manual reformatting",
      "Navigate directly from detected issues to the problematic code location to fix problems efficiently",
      "Maintain up-to-date product documentation that reflects current codebase state without manual documentation effort",
      "Understand system architecture and design patterns when joining a new project or working in unfamiliar areas",
      "Assess test coverage and understand what unit tests are validating without reading test implementation",
      "Detect circular dependencies before they cause maintenance nightmares in larger systems",
      "Identify god objects and oversized files that will become maintenance bottlenecks",
      "Monitor codebase health trends over time through overall health score metrics",
      "Choose their preferred AI provider without being locked into a single vendor",
      "Work across multiple programming languages with consistent analysis quality and interface"
    ],
    "contextualFactors": [
      "VS Code extension ecosystem requiring single-entry architecture integrated into IDE lifecycle",
      "AI-augmented development workflow where developers switch between writing code and consulting AI assistants",
      "Real-time feedback requirements demanding non-blocking analysis that doesn't interrupt development flow",
      "Multi-language development environments requiring consistent analysis across technology stacks",
      "Heterogeneous AI tooling landscape where different teams use different AI assistants (ChatGPT, Claude, Cursor, custom models)",
      "Static analysis complexity requiring abstract syntax tree parsing and dependency graph analysis",
      "Documentation drift problem where product docs become outdated as code changes",
      "Knowledge gap between code implementation and user-facing product behavior",
      "Incremental development workflow where developers make small changes and save frequently",
      "Performance constraints of running analysis in IDE context without blocking UI",
      "Schema validation needs for handling non-deterministic AI model outputs",
      "Context switching cost between development environment and external AI tools"
    ]
  },
  "_metadata": {
    "generatedAt": "2025-11-18T16:50:45.379Z",
    "generatedAtLocal": "11/18/2025, 8:50:45 AM",
    "runId": "architecture-insights-2025-11-18T16-47-54-125Z"
  }
}