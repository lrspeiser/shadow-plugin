{
  "productPurpose": "Shadow Watch aims to bridge the gap between code implementation and architecture understanding by providing continuous, automated analysis that detects technical debt in real-time and translates complex code structure into formats that both humans and AI assistants can act upon. Its core mission is to prevent architecture degradation through immediate feedback while simultaneously enabling developers to leverage AI tools for refactoring by generating prompts specifically formatted for different AI assistants.",
  "architectureRationale": "This architecture exists because Shadow Watch serves as a continuous monitoring bridge between developers' code changes and AI-powered assistance systems. The single Node.js entry point exists because VS Code extensions require a unified activation point that can register multiple interface components (sidebar, webview, diagnostics, commands) within the editor's extension host process. The multi-layered architecture separates concerns: the monitoring layer watches for changes continuously because architecture issues need detection at write-time before they compound; the analysis engine operates incrementally with caching because developers cannot tolerate blocking delays during saves; the AI integration layer exists as an abstraction because different users prefer different AI providers and the product must format prompts differently for Cursor versus ChatGPT versus generic assistants; and multiple presentation interfaces (sidebar tree, webview, inline diagnostics) exist because developers need different views depending on context - quick overview during coding versus detailed exploration when investigating issues versus inline annotations when editing specific files.",
  "designDecisions": [
    "Continuous file monitoring with on-save analysis - Reason: Architecture issues compound quickly, so detection must happen immediately when code changes rather than waiting for manual review or CI pipeline execution",
    "Severity-based issue categorization (errors, warnings, info) - Reason: Developers need to prioritize which architecture problems to address first based on impact, and severity levels provide clear prioritization guidance",
    "LLM-ready prompt generation with multiple format options - Reason: Developers increasingly use AI assistants for refactoring but waste time reformatting context; generating Cursor-specific, ChatGPT-specific, and generic formats eliminates this friction",
    "AI provider abstraction supporting OpenAI, Anthropic, and custom endpoints - Reason: Organizations have different AI preferences based on cost, privacy, and capability requirements; a provider abstraction lets users choose without changing workflows",
    "Caching layer for analysis results - Reason: Re-analyzing unchanged code on every save would block developer workflow; caching enables continuous monitoring without performance penalties",
    "Multiple view interfaces (sidebar tree, webview, inline diagnostics) - Reason: Different development contexts require different information density - quick scanning during coding versus deep investigation versus contextual editing",
    "JSON schema validation for AI responses - Reason: AI-generated content is unpredictable; schema validation ensures structured data can be reliably parsed and displayed regardless of provider variations",
    "Direct code navigation from issues - Reason: Identifying problems is only valuable if developers can immediately jump to the problematic code location to fix it",
    "Incremental workspace analysis - Reason: Analyzing entire large codebases on startup would freeze the editor; incremental analysis maintains responsiveness while building comprehensive insights",
    "Product documentation generation alongside architecture analysis - Reason: Developers need to understand what code does from a user perspective, not just its technical structure, to make appropriate architecture decisions"
  ],
  "userGoals": [
    "Detect architecture anti-patterns immediately when writing code to prevent technical debt accumulation",
    "Quickly copy architecture issues into AI assistants like Cursor or ChatGPT to get automated refactoring suggestions",
    "Understand what an unfamiliar codebase does from a user perspective through AI-generated product documentation",
    "Identify circular dependencies and god objects before they cause maintenance problems",
    "Navigate directly to problematic code locations when exploring architecture issues",
    "Maintain up-to-date documentation automatically as the codebase evolves without manual writing effort",
    "Switch between different AI providers based on cost, capability, or organizational requirements",
    "Get actionable severity-based prioritization of which architecture issues to address first",
    "Analyze individual files during focused work or entire workspaces for comprehensive review",
    "Bridge the knowledge gap between code implementation details and system-level architecture patterns",
    "Reduce time spent formatting code context for AI tools through one-click prompt generation",
    "Access architecture insights through multiple interfaces depending on current workflow context"
  ],
  "contextualFactors": [
    "VS Code extension ecosystem constraints requiring single entry point with extension host integration",
    "Real-time continuous monitoring requirements demanding non-blocking incremental analysis",
    "Multi-AI-provider landscape requiring abstraction to support different vendors and self-hosted options",
    "Diverse AI assistant prompt format requirements (Cursor, ChatGPT, generic) needing specialized formatting",
    "Performance sensitivity in development environments requiring intelligent caching strategies",
    "Multiple developer workflow contexts requiring different information presentation modes",
    "Growing developer reliance on AI assistants for refactoring creating demand for AI-ready output",
    "Multi-language codebase support spanning Python, JavaScript, TypeScript, Java, Go, Rust, C/C++, Ruby, PHP",
    "Need to bridge technical implementation details with user-facing product behavior understanding",
    "Developer preference for in-editor tools over external analysis platforms",
    "Incremental development workflow where architecture feedback must not interrupt coding flow",
    "Documentation maintenance burden driving demand for automated generation tied to code changes"
  ],
  "_metadata": {
    "savedAt": "2025-11-18T16:56:45.618Z"
  }
}