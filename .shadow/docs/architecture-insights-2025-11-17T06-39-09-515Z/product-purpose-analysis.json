{
  "productPurpose": "Shadow Watch aims to continuously improve code quality and architecture by automatically detecting issues in real-time, generating AI-optimized insights that enable developers to quickly get intelligent recommendations from LLMs, and producing comprehensive documentation that helps teams understand their codebase without manual effort. Its core mission is to make architecture quality visible and actionable by bridging human developers with AI assistants through optimized formatting and automatic analysis.",
  "architectureRationale": "The architecture exists to support continuous background monitoring without disrupting developer workflow. There is a single entry point (./dist/extension.js) because Shadow Watch is a VSCode extension that must integrate into the editor's lifecycle - it activates when VSCode starts and runs persistently in the background. The multiple tree view providers exist because users need different perspectives on their code: issue-focused views for fixing problems, documentation views for understanding the system, and test views for quality assurance. The architecture separates analysis from presentation because analysis is computationally expensive (requiring AST parsing and dependency graphing) while UI updates must be instantaneous. The caching layer exists because re-analyzing entire workspaces on every save would be too slow, so incremental analysis of only changed files keeps updates under 1 second. The LLM integration layer exists because the product's core value proposition is preparing insights for AI assistants, requiring formatted outputs optimized for different LLM providers.",
  "designDecisions": [
    "Multiple tree view providers (InsightsTreeView, AnalysisViewerProvider, ProductNavigatorProvider, InsightsViewerProvider, UnitTestsNavigatorProvider) - Reason: Users need to switch between problem-solving mode (viewing issues), understanding mode (reading documentation), and testing mode (linking tests to source) without leaving VSCode",
    "Intelligent caching with time-based expiration - Reason: Developers save files constantly during coding, so re-analyzing the entire workspace every time would create unacceptable lag; caching enables sub-second incremental updates while ensuring analysis stays fresh",
    "FileWatcher triggering incremental analysis - Reason: Users expect real-time feedback as they code, not batch analysis they must manually trigger; automatic monitoring on save keeps insights current without breaking flow",
    "LLMFormatter with multiple output formats (Cursor, ChatGPT, generic) - Reason: Different AI assistants have different optimal input formats, and manually reformatting insights for each assistant would waste time and reduce adoption",
    "Separation of CodeAnalyzer (static analysis) from InsightGenerator (pattern detection) - Reason: Raw code structure parsing is reusable across different types of insights, while anti-pattern detection logic changes as new issues are identified; separation enables independent evolution",
    "DiagnosticsProvider publishing to VSCode Problems panel - Reason: Developers already use the Problems panel for compiler errors and linter warnings, so integrating architecture issues into the same interface reduces context switching",
    "Multi-LLM provider support (Claude, OpenAI, Gemini, Ollama) - Reason: Users have different LLM preferences based on cost, privacy, and capability; supporting multiple providers prevents vendor lock-in and maximizes adoption",
    "Severity categorization (Error, Warning, Info) - Reason: Not all issues are equally urgent; categorization helps developers prioritize fixes and understand which problems block releases versus which are technical debt",
    "AST parsing for function-level analysis - Reason: Surface-level text analysis cannot detect complex issues like cyclomatic complexity or nested control flow; deep AST parsing enables precise detection of code smells",
    "Background processing that never blocks editing - Reason: Developers will disable any tool that interferes with typing; non-blocking architecture ensures Shadow Watch remains enabled"
  ],
  "userGoals": [
    "Identify architecture problems in their codebase before they cause production issues or failed code reviews",
    "Get AI-powered recommendations for fixing detected issues without manually formatting context for LLMs",
    "Understand unfamiliar codebases quickly through AI-generated documentation rather than reading every file",
    "Keep documentation synchronized with code without manual writing or updating",
    "Prevent technical debt accumulation by seeing quality degradation in real-time as they code",
    "Reduce time spent in code review by catching common issues automatically before pushing commits",
    "Prioritize which issues to fix first using severity indicators and health scores",
    "Learn better architecture patterns by seeing examples of anti-patterns in their own code with explanations",
    "Share architecture context with team members or AI assistants efficiently using one-click copy",
    "Maintain awareness of codebase health without running separate analysis tools or leaving their editor",
    "Generate missing unit tests for uncovered code files",
    "Navigate directly from detected issues to the exact code location that needs fixing"
  ],
  "contextualFactors": [
    "VSCode extension ecosystem constraints requiring single entry point and lifecycle integration",
    "Real-time monitoring requirements demanding incremental analysis and intelligent caching",
    "Multi-LLM landscape requiring format flexibility and provider abstraction",
    "Diverse programming language support (9 languages) requiring generic AST parsing approach",
    "Developer workflow optimization requiring non-blocking background processing",
    "AI assistant integration being the core differentiator requiring specialized formatting layer",
    "Continuous evolution of architecture anti-patterns requiring separation of detection logic from analysis infrastructure",
    "Workspace-scale codebases requiring performance optimization through caching and incremental updates",
    "Multiple user modes (problem-solving, documentation-reading, test-navigation) requiring different UI views",
    "IDE integration standards requiring DiagnosticsProvider for Problems panel compatibility"
  ],
  "_metadata": {
    "savedAt": "2025-11-17T06:39:09.515Z"
  }
}