{
  "module": "src",
  "moduleType": "other",
  "capabilities": [
    "Automated code analysis and structure extraction from entire codebase or individual files",
    "Interactive tree view navigation of code architecture, dependencies, and entry points",
    "AI-powered code insights generation with severity-based categorization and recommendations",
    "Real-time diagnostics display showing code quality issues as inline squiggles and problem panel entries",
    "LLM-assisted documentation generation for files, modules, and product-level architecture",
    "Code quality monitoring with detection of large files, orphaned code, circular dependencies, and complexity issues",
    "Persistent caching of analysis results with automatic 24-hour expiration",
    "File watching with automatic re-analysis on save",
    "Multiple export formats (Markdown, JSON) optimized for different LLM tools (Cursor, ChatGPT)",
    "Test coverage mapping and unit test navigation",
    "Grep-based code search for pattern discovery",
    "Structured documentation hierarchy from file-level to product-level"
  ],
  "summary": "The src module provides a comprehensive VS Code extension for intelligent code analysis and documentation. It combines static code analysis with AI-powered insights to help developers understand, navigate, and improve their codebase. The extension analyzes code structure, extracts dependencies, identifies entry points, and detects quality issues like complexity, orphaned files, and circular dependencies.\n\nUsers interact with the analysis through multiple integrated views: a tree-based code structure browser, an insights panel showing categorized issues with severity levels, and inline diagnostics that appear as squiggly underlines in the editor. The extension supports both manual and automatic analysis workflows, with file watching capabilities that trigger re-analysis on save. Analysis results are cached for 24 hours to provide instant access when reopening workspaces.\n\nThe module leverages LLM services (OpenAI/Claude) to generate intelligent documentation at file, module, and product levels. It formats analysis results in multiple ways optimized for different AI assistants, provides structured schemas for consistent LLM responses, and offers grep-based search capabilities for iterative code exploration. All user actions—from viewing insights to generating documentation—are logged with timestamps for debugging and audit purposes.",
  "files": [
    {
      "file": "src/analysisViewer.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view interface in VSCode's sidebar to browse and navigate code analysis results organized by files, functions, dependencies, and entry points.",
      "userVisibleActions": [
        "View a tree structure showing code analysis results in the sidebar",
        "See summary statistics (total files, functions, dependencies, entry points)",
        "Browse files organized by directory structure",
        "Expand files to see their functions, imports, and exports",
        "View function details including parameters and complexity metrics",
        "See detected entry points in the codebase",
        "Click on items to jump to specific code locations in the editor",
        "View complexity warnings and dependency information",
        "See file roles (config, test, component, etc.) with icons",
        "Navigate through nested directory structures",
        "View 'No analysis available' message when no analysis has been run"
      ],
      "developerVisibleActions": [
        "Tree view populates with code analysis data after running workspace analysis",
        "Analysis results are displayed in a hierarchical tree structure",
        "Files are grouped by directory with appropriate icons and counts",
        "Functions show their signatures, line counts, and complexity scores",
        "Entry points are listed with their types (HTTP, CLI, event handlers, etc.)",
        "Dependencies show import/export relationships between files",
        "Items are clickable and navigate to corresponding code locations",
        "Tree automatically refreshes when new analysis data is provided",
        "Complex functions (complexity > 10) are flagged with warning icons"
      ],
      "keyFunctions": [
        {
          "name": "setAnalysis",
          "desc": "Updates the tree view with new analysis results",
          "inputs": "CodeAnalysis object or null",
          "outputs": "void (triggers tree refresh)"
        },
        {
          "name": "getTreeItem",
          "desc": "Returns the tree item representation for display",
          "inputs": "AnalysisItem element",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child items for a given tree node or root items if no element provided",
          "inputs": "optional AnalysisItem element",
          "outputs": "Promise<AnalysisItem[]>"
        },
        {
          "name": "getRootItems",
          "desc": "Creates the top-level tree items (statistics, files, functions, dependencies, entry points)",
          "inputs": "none",
          "outputs": "AnalysisItem[] array"
        },
        {
          "name": "getStatisticsItems",
          "desc": "Creates tree items showing analysis statistics counts",
          "inputs": "none",
          "outputs": "AnalysisItem[] array"
        },
        {
          "name": "getFilesItems",
          "desc": "Creates tree items for files and directories organized hierarchically",
          "inputs": "none",
          "outputs": "AnalysisItem[] array"
        },
        {
          "name": "getFileDetails",
          "desc": "Creates tree items showing details of a specific file (functions, imports, exports)",
          "inputs": "AnalysisItem representing a file",
          "outputs": "AnalysisItem[] array"
        },
        {
          "name": "getFunctionsItems",
          "desc": "Creates tree items listing all functions across the codebase",
          "inputs": "none",
          "outputs": "AnalysisItem[] array"
        },
        {
          "name": "getDependenciesItems",
          "desc": "Creates tree items showing file dependency relationships",
          "inputs": "none",
          "outputs": "AnalysisItem[] array"
        },
        {
          "name": "getEntryPointsItems",
          "desc": "Creates tree items for detected application entry points",
          "inputs": "none",
          "outputs": "AnalysisItem[] array"
        },
        {
          "name": "createFileLocation",
          "desc": "Creates a vscode.Location object for navigating to specific code positions",
          "inputs": "file path, optional line/column numbers",
          "outputs": "vscode.Location object"
        }
      ],
      "dependencies": [
        "vscode",
        "CodeAnalysis (from ./analyzer)",
        "FileInfo (from ./analyzer)",
        "FunctionInfo (from ./analyzer)",
        "EntryPoint (from ./analyzer)",
        "path"
      ],
      "intent": "This file exists to provide a visual, navigable tree interface for developers to explore code analysis results, making it easy to understand codebase structure, identify entry points, review function complexity, and navigate to specific code locations directly from the analysis view.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view interface in VSCode's sidebar to browse and navigate code analysis results organized by files, functions, dependencies, and entry points.\",\n  \"userVisibleActions\": [\n    \"View a tree structure showing code analysis results in the sidebar\",\n    \"See summary statistics (total files, functions, dependencies, entry points)\",\n    \"Browse files organized by directory structure\",\n    \"Expand files to see their functions, imports, and exports\",\n    \"View function details including parameters and complexity metrics\",\n    \"See detected entry points in the codebase\",\n    \"Click on items to jump to specific code locations in the editor\",\n    \"View complexity warnings and dependency information\",\n    \"See file roles (config, test, component, etc.) with icons\",\n    \"Navigate through nested directory structures\",\n    \"View 'No analysis available' message when no analysis has been run\"\n  ],\n  \"developerVisibleActions\": [\n    \"Tree view populates with code analysis data after running workspace analysis\",\n    \"Analysis results are displayed in a hierarchical tree structure\",\n    \"Files are grouped by directory with appropriate icons and counts\",\n    \"Functions show their signatures, line counts, and complexity scores\",\n    \"Entry points are listed with their types (HTTP, CLI, event handlers, etc.)\",\n    \"Dependencies show import/export relationships between files\",\n    \"Items are clickable and navigate to corresponding code locations\",\n    \"Tree automatically refreshes when new analysis data is provided\",\n    \"Complex functions (complexity > 10) are flagged with warning icons\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setAnalysis\",\n      \"desc\": \"Updates the tree view with new analysis results\",\n      \"inputs\": \"CodeAnalysis object or null\",\n      \"outputs\": \"void (triggers tree refresh)\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Returns the tree item representation for display\",\n      \"inputs\": \"AnalysisItem element\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for a given tree node or root items if no element provided\",\n      \"inputs\": \"optional AnalysisItem element\",\n      \"outputs\": \"Promise<AnalysisItem[]>\"\n    },\n    {\n      \"name\": \"getRootItems\",\n      \"desc\": \"Creates the top-level tree items (statistics, files, functions, dependencies, entry points)\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[] array\"\n    },\n    {\n      \"name\": \"getStatisticsItems\",\n      \"desc\": \"Creates tree items showing analysis statistics counts\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[] array\"\n    },\n    {\n      \"name\": \"getFilesItems\",\n      \"desc\": \"Creates tree items for files and directories organized hierarchically\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[] array\"\n    },\n    {\n      \"name\": \"getFileDetails\",\n      \"desc\": \"Creates tree items showing details of a specific file (functions, imports, exports)\",\n      \"inputs\": \"AnalysisItem representing a file\",\n      \"outputs\": \"AnalysisItem[] array\"\n    },\n    {\n      \"name\": \"getFunctionsItems\",\n      \"desc\": \"Creates tree items listing all functions across the codebase\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[] array\"\n    },\n    {\n      \"name\": \"getDependenciesItems\",\n      \"desc\": \"Creates tree items showing file dependency relationships\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[] array\"\n    },\n    {\n      \"name\": \"getEntryPointsItems\",\n      \"desc\": \"Creates tree items for detected application entry points\",\n      \"inputs\": \"none\",\n      \"outputs\": \"AnalysisItem[] array\"\n    },\n    {\n      \"name\": \"createFileLocation\",\n      \"desc\": \"Creates a vscode.Location object for navigating to specific code positions\",\n      \"inputs\": \"file path, optional line/column numbers\",\n      \"outputs\": \"vscode.Location object\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"CodeAnalysis (from ./analyzer)\",\n    \"FileInfo (from ./analyzer)\",\n    \"FunctionInfo (from ./analyzer)\",\n    \"EntryPoint (from ./analyzer)\",\n    \"path\"\n  ],\n  \"intent\": \"This file exists to provide a visual, navigable tree interface for developers to explore code analysis results, making it easy to understand codebase structure, identify entry points, review function complexity, and navigate to specific code locations directly from the analysis view.\"\n}\n```"
    },
    {
      "file": "src/analyzer.ts",
      "role": "Core Logic",
      "purpose": "Analyzes code files to extract structure, dependencies, functions, and relationships for codebase understanding and visualization",
      "userVisibleActions": [
        "View total file count, line count, and function count statistics",
        "See list of large files that may need refactoring",
        "View all functions with their metadata and locations",
        "See import relationships between files",
        "Identify orphaned files not imported by others",
        "Find entry points (files not importing others)",
        "Detect duplicate code blocks across the codebase",
        "View risk levels (high/medium/low) for functions",
        "See test coverage mapping for source files and functions",
        "Identify uncovered functions without tests"
      ],
      "developerVisibleActions": [
        "Call analyzer to scan directory and extract code structure",
        "Get structured data about functions including parameters, return types, visibility",
        "Access function dependencies (database, HTTP, filesystem, etc.)",
        "Retrieve branch information (if/else, loops, try/catch)",
        "Track state mutations (assignments, modifications, deletions)",
        "Query import/export relationships between files",
        "Use caching system to speed up repeated analysis",
        "Map test files to source files they test",
        "Filter analysis results by file type or pattern",
        "Export analysis results in structured format"
      ],
      "keyFunctions": [
        {
          "name": "CodeAnalysis",
          "desc": "Main data structure containing complete analysis results",
          "inputs": "N/A (interface)",
          "outputs": "Object with totalFiles, totalLines, functions, imports, orphanedFiles, duplicates, testMapping, etc."
        },
        {
          "name": "FunctionMetadata",
          "desc": "Detailed metadata about a single function",
          "inputs": "N/A (interface)",
          "outputs": "Object with symbolName, parameters, returnType, visibility, branches, dependencies, riskLevel, docstring"
        },
        {
          "name": "BranchInfo",
          "desc": "Information about conditional branches and control flow",
          "inputs": "N/A (interface)",
          "outputs": "Object with type (if/loop/try/etc), condition description, lineNumber"
        },
        {
          "name": "DependencyInfo",
          "desc": "Tracks external and internal dependencies",
          "inputs": "N/A (interface)",
          "outputs": "Object with dependency name, type (db/http/filesystem/etc), isInternal flag"
        },
        {
          "name": "StateMutationInfo",
          "desc": "Tracks where and how state is modified",
          "inputs": "N/A (interface)",
          "outputs": "Object with target name, mutationType (assign/modify/delete/read), lineNumber"
        },
        {
          "name": "TestMapping",
          "desc": "Maps source files and functions to their test files",
          "inputs": "N/A (interface)",
          "outputs": "Object with sourceFileToTests map, functionToTests map, uncoveredFunctions list"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./cache (AnalysisCache)"
      ],
      "intent": "This file defines the core data structures and interfaces for code analysis results. It exists to provide a standardized way to represent codebase structure, function metadata, dependencies, test coverage, and code quality metrics. Developers use these interfaces to understand code relationships, identify technical debt, assess risk, and improve test coverage.",
      "rawContent": "```json\n{\n  \"purpose\": \"Analyzes code files to extract structure, dependencies, functions, and relationships for codebase understanding and visualization\",\n  \"userVisibleActions\": [\n    \"View total file count, line count, and function count statistics\",\n    \"See list of large files that may need refactoring\",\n    \"View all functions with their metadata and locations\",\n    \"See import relationships between files\",\n    \"Identify orphaned files not imported by others\",\n    \"Find entry points (files not importing others)\",\n    \"Detect duplicate code blocks across the codebase\",\n    \"View risk levels (high/medium/low) for functions\",\n    \"See test coverage mapping for source files and functions\",\n    \"Identify uncovered functions without tests\"\n  ],\n  \"developerVisibleActions\": [\n    \"Call analyzer to scan directory and extract code structure\",\n    \"Get structured data about functions including parameters, return types, visibility\",\n    \"Access function dependencies (database, HTTP, filesystem, etc.)\",\n    \"Retrieve branch information (if/else, loops, try/catch)\",\n    \"Track state mutations (assignments, modifications, deletions)\",\n    \"Query import/export relationships between files\",\n    \"Use caching system to speed up repeated analysis\",\n    \"Map test files to source files they test\",\n    \"Filter analysis results by file type or pattern\",\n    \"Export analysis results in structured format\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"CodeAnalysis\",\n      \"desc\": \"Main data structure containing complete analysis results\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Object with totalFiles, totalLines, functions, imports, orphanedFiles, duplicates, testMapping, etc.\"\n    },\n    {\n      \"name\": \"FunctionMetadata\",\n      \"desc\": \"Detailed metadata about a single function\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Object with symbolName, parameters, returnType, visibility, branches, dependencies, riskLevel, docstring\"\n    },\n    {\n      \"name\": \"BranchInfo\",\n      \"desc\": \"Information about conditional branches and control flow\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Object with type (if/loop/try/etc), condition description, lineNumber\"\n    },\n    {\n      \"name\": \"DependencyInfo\",\n      \"desc\": \"Tracks external and internal dependencies\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Object with dependency name, type (db/http/filesystem/etc), isInternal flag\"\n    },\n    {\n      \"name\": \"StateMutationInfo\",\n      \"desc\": \"Tracks where and how state is modified\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Object with target name, mutationType (assign/modify/delete/read), lineNumber\"\n    },\n    {\n      \"name\": \"TestMapping\",\n      \"desc\": \"Maps source files and functions to their test files\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Object with sourceFileToTests map, functionToTests map, uncoveredFunctions list\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./cache (AnalysisCache)\"\n  ],\n  \"intent\": \"This file defines the core data structures and interfaces for code analysis results. It exists to provide a standardized way to represent codebase structure, function metadata, dependencies, test coverage, and code quality metrics. Developers use these interfaces to understand code relationships, identify technical debt, assess risk, and improve test coverage.\"\n}\n```"
    },
    {
      "file": "src/cache.ts",
      "role": "Core Logic",
      "purpose": "Manages persistent storage and retrieval of code analysis results with automatic expiration after 24 hours",
      "userVisibleActions": [
        "Analysis results are loaded instantly when reopening a previously analyzed workspace",
        "Analysis results become stale and are automatically refreshed after 24 hours",
        "Cache storage is automatically created in the workspace on first use",
        "Old analysis data can be cleared to free up disk space"
      ],
      "developerVisibleActions": [
        "Store code analysis results to disk for future retrieval",
        "Retrieve previously cached analysis results for a workspace",
        "Clear all cached analysis data across workspaces",
        "Invalidate outdated cache entries automatically after 24 hours",
        "Generate unique cache keys for different workspace paths"
      ],
      "keyFunctions": [
        {
          "name": "constructor",
          "desc": "Initializes the cache manager with a storage location",
          "inputs": "storagePath (string) - base directory for cache storage",
          "outputs": "AnalysisCache instance"
        },
        {
          "name": "getCacheKey",
          "desc": "Converts a workspace path into a safe filename for cache storage",
          "inputs": "workspaceRoot (string) - workspace directory path",
          "outputs": "string - base64-encoded safe filename"
        },
        {
          "name": "get",
          "desc": "Retrieves cached analysis results if they exist and are not expired",
          "inputs": "workspaceRoot (string) - workspace directory path",
          "outputs": "Promise<CodeAnalysis | null> - cached analysis or null if expired/missing"
        },
        {
          "name": "set",
          "desc": "Saves analysis results to cache with current timestamp",
          "inputs": "workspaceRoot (string), data (CodeAnalysis) - workspace path and analysis to cache",
          "outputs": "Promise<void>"
        },
        {
          "name": "clear",
          "desc": "Removes all cached analysis files from storage",
          "inputs": "none",
          "outputs": "Promise<void>"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./analyzer"
      ],
      "intent": "This file exists to speed up the extension by avoiding repeated analysis of unchanged codebases. It solves the performance problem of re-analyzing large projects every time VS Code is opened by persisting analysis results to disk with a time-based expiration strategy.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages persistent storage and retrieval of code analysis results with automatic expiration after 24 hours\",\n  \"userVisibleActions\": [\n    \"Analysis results are loaded instantly when reopening a previously analyzed workspace\",\n    \"Analysis results become stale and are automatically refreshed after 24 hours\",\n    \"Cache storage is automatically created in the workspace on first use\",\n    \"Old analysis data can be cleared to free up disk space\"\n  ],\n  \"developerVisibleActions\": [\n    \"Store code analysis results to disk for future retrieval\",\n    \"Retrieve previously cached analysis results for a workspace\",\n    \"Clear all cached analysis data across workspaces\",\n    \"Invalidate outdated cache entries automatically after 24 hours\",\n    \"Generate unique cache keys for different workspace paths\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"constructor\",\n      \"desc\": \"Initializes the cache manager with a storage location\",\n      \"inputs\": \"storagePath (string) - base directory for cache storage\",\n      \"outputs\": \"AnalysisCache instance\"\n    },\n    {\n      \"name\": \"getCacheKey\",\n      \"desc\": \"Converts a workspace path into a safe filename for cache storage\",\n      \"inputs\": \"workspaceRoot (string) - workspace directory path\",\n      \"outputs\": \"string - base64-encoded safe filename\"\n    },\n    {\n      \"name\": \"get\",\n      \"desc\": \"Retrieves cached analysis results if they exist and are not expired\",\n      \"inputs\": \"workspaceRoot (string) - workspace directory path\",\n      \"outputs\": \"Promise<CodeAnalysis | null> - cached analysis or null if expired/missing\"\n    },\n    {\n      \"name\": \"set\",\n      \"desc\": \"Saves analysis results to cache with current timestamp\",\n      \"inputs\": \"workspaceRoot (string), data (CodeAnalysis) - workspace path and analysis to cache\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all cached analysis files from storage\",\n      \"inputs\": \"none\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to speed up the extension by avoiding repeated analysis of unchanged codebases. It solves the performance problem of re-analyzing large projects every time VS Code is opened by persisting analysis results to disk with a time-based expiration strategy.\"\n}\n```"
    },
    {
      "file": "src/diagnosticsProvider.ts",
      "role": "Core Logic",
      "purpose": "Manages the display of code insights as inline diagnostics (squiggly underlines and problems panel entries) in the VS Code editor.",
      "userVisibleActions": [
        "See squiggly underlines in code where insights are detected",
        "View insights in the Problems panel with severity indicators (error, warning, info)",
        "Click on problems to navigate to the corresponding code location",
        "See 'Shadow Watch' as the source of diagnostic messages",
        "View insight descriptions as diagnostic messages",
        "Have diagnostics automatically cleared when insights are updated"
      ],
      "developerVisibleActions": [
        "Provide insights to be displayed as diagnostics in the editor",
        "Update diagnostics for all files or a specific file",
        "Clear all diagnostics from the Problems panel",
        "Dispose of the diagnostics collection when extension deactivates",
        "Diagnostics are automatically grouped by file",
        "Each insight is converted to a VS Code diagnostic with appropriate severity"
      ],
      "keyFunctions": [
        {
          "name": "updateDiagnostics",
          "desc": "Updates diagnostics for all files based on provided insights",
          "inputs": "Array of Insight objects",
          "outputs": "Void - displays diagnostics in editor and Problems panel"
        },
        {
          "name": "updateDiagnosticsForFile",
          "desc": "Updates diagnostics for a specific file",
          "inputs": "File URI and array of Insight objects for that file",
          "outputs": "Void - displays diagnostics for the specified file"
        },
        {
          "name": "clear",
          "desc": "Removes all diagnostics from the editor and Problems panel",
          "inputs": "None",
          "outputs": "Void"
        },
        {
          "name": "createDiagnostic",
          "desc": "Converts an insight into a VS Code diagnostic with severity, message, and location",
          "inputs": "Insight object",
          "outputs": "VS Code Diagnostic object"
        },
        {
          "name": "dispose",
          "desc": "Cleans up the diagnostics collection when no longer needed",
          "inputs": "None",
          "outputs": "Void"
        }
      ],
      "dependencies": [
        "vscode",
        "./insightGenerator"
      ],
      "intent": "This file exists to bridge the gap between Shadow Watch's insight generation system and VS Code's native diagnostics UI. It translates insights into the standard VS Code problems/diagnostics format so users can see issues directly in their code with familiar VS Code UI patterns (squiggles, Problems panel). It solves the problem of how to visually communicate detected insights to users in an intuitive, IDE-native way.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages the display of code insights as inline diagnostics (squiggly underlines and problems panel entries) in the VS Code editor.\",\n  \"userVisibleActions\": [\n    \"See squiggly underlines in code where insights are detected\",\n    \"View insights in the Problems panel with severity indicators (error, warning, info)\",\n    \"Click on problems to navigate to the corresponding code location\",\n    \"See 'Shadow Watch' as the source of diagnostic messages\",\n    \"View insight descriptions as diagnostic messages\",\n    \"Have diagnostics automatically cleared when insights are updated\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provide insights to be displayed as diagnostics in the editor\",\n    \"Update diagnostics for all files or a specific file\",\n    \"Clear all diagnostics from the Problems panel\",\n    \"Dispose of the diagnostics collection when extension deactivates\",\n    \"Diagnostics are automatically grouped by file\",\n    \"Each insight is converted to a VS Code diagnostic with appropriate severity\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"updateDiagnostics\",\n      \"desc\": \"Updates diagnostics for all files based on provided insights\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Void - displays diagnostics in editor and Problems panel\"\n    },\n    {\n      \"name\": \"updateDiagnosticsForFile\",\n      \"desc\": \"Updates diagnostics for a specific file\",\n      \"inputs\": \"File URI and array of Insight objects for that file\",\n      \"outputs\": \"Void - displays diagnostics for the specified file\"\n    },\n    {\n      \"name\": \"clear\",\n      \"desc\": \"Removes all diagnostics from the editor and Problems panel\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Void\"\n    },\n    {\n      \"name\": \"createDiagnostic\",\n      \"desc\": \"Converts an insight into a VS Code diagnostic with severity, message, and location\",\n      \"inputs\": \"Insight object\",\n      \"outputs\": \"VS Code Diagnostic object\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up the diagnostics collection when no longer needed\",\n      \"inputs\": \"None\",\n      \"outputs\": \"Void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between Shadow Watch's insight generation system and VS Code's native diagnostics UI. It translates insights into the standard VS Code problems/diagnostics format so users can see issues directly in their code with familiar VS Code UI patterns (squiggles, Problems panel). It solves the problem of how to visually communicate detected insights to users in an intuitive, IDE-native way.\"\n}\n```"
    },
    {
      "file": "src/extension.ts",
      "role": "Core Logic",
      "purpose": "Activates and orchestrates the VS Code extension for code analysis, providing commands, views, and integrations for analyzing codebases and generating insights.",
      "userVisibleActions": [
        "Trigger full codebase analysis through command palette or status bar",
        "Analyze currently open file for structure and insights",
        "View analyzed code insights in tree view sidebar",
        "Format analysis output for LLM consumption",
        "Navigate to specific code elements (functions, classes, entry points) from analysis views",
        "Export analysis results to markdown or JSON files",
        "View code analysis diagnostics and warnings in Problems panel",
        "Clear analysis cache to force fresh analysis",
        "View product navigation tree showing project structure",
        "View static analysis results in dedicated panel",
        "View unit tests organization in test navigator",
        "See analysis progress in status bar with clickable indicator"
      ],
      "developerVisibleActions": [
        "Extension initializes on VS Code startup and registers all commands and providers",
        "File watcher monitors workspace for changes and triggers automatic re-analysis",
        "Analysis results are cached to improve performance on subsequent requests",
        "Multiple webview providers display different aspects of analysis (insights, static analysis, unit tests)",
        "Command handlers process user actions and coordinate between analyzer, generators, and UI components",
        "Diagnostics provider updates Problems panel with code issues found during analysis",
        "Status bar item shows current analysis state and provides quick access to analysis commands",
        "Extension uses bootstrapper pattern to initialize components in correct dependency order",
        "Configuration manager provides centralized access to extension settings",
        "Error handler catches and displays user-friendly error messages for analysis failures"
      ],
      "keyFunctions": [
        {
          "name": "activate",
          "desc": "Entry point that initializes the extension, sets up all providers, registers commands, and starts file watching",
          "inputs": "context: vscode.ExtensionContext",
          "outputs": "void (registers disposables in context)"
        },
        {
          "name": "deactivate",
          "desc": "Cleanup function called when extension is disabled or VS Code closes",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "analyzeWorkspace",
          "desc": "Analyzes entire workspace codebase and updates all views with results",
          "inputs": "none (uses workspace folders)",
          "outputs": "Promise<void>"
        },
        {
          "name": "analyzeCurrentFile",
          "desc": "Analyzes the currently active editor file and displays results",
          "inputs": "none (uses active text editor)",
          "outputs": "Promise<void>"
        },
        {
          "name": "formatForLLM",
          "desc": "Formats analysis output in LLM-friendly format and displays in editor",
          "inputs": "none (uses cached analysis)",
          "outputs": "Promise<void>"
        },
        {
          "name": "exportAnalysis",
          "desc": "Exports current analysis results to file (markdown or JSON format)",
          "inputs": "format: 'markdown' | 'json'",
          "outputs": "Promise<void>"
        },
        {
          "name": "clearCache",
          "desc": "Clears analysis cache and forces fresh analysis on next request",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "navigateToElement",
          "desc": "Opens file and jumps to specific code element location from analysis view",
          "inputs": "item: TreeItem | AnalysisItem | InsightItem | StaticAnalysisItem",
          "outputs": "Promise<void>"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "./analyzer",
        "./insightGenerator",
        "./llmFormatter",
        "./fileWatcher",
        "./insightsTreeView",
        "./diagnosticsProvider",
        "./cache",
        "./llmIntegration",
        "./productNavigator",
        "./analysisViewer",
        "./insightsViewer",
        "./staticAnalysisViewer",
        "./unitTestsNavigator",
        "./config/configurationManager",
        "./utils/errorHandler",
        "./ui/webview/webviewTemplateEngine",
        "./domain/bootstrap/extensionBootstrapper",
        "./domain/bootstrap/commandRegistry",
        "./domain/handlers/navigationHandler"
      ],
      "intent": "This file exists as the main entry point and orchestrator for the VS Code extension. It solves the problem of coordinating multiple subsystems (analysis, UI, caching, file watching) into a cohesive user experience, registering all commands and views that users interact with, and managing the lifecycle of extension components from activation to deactivation.",
      "rawContent": "```json\n{\n  \"purpose\": \"Activates and orchestrates the VS Code extension for code analysis, providing commands, views, and integrations for analyzing codebases and generating insights.\",\n  \"userVisibleActions\": [\n    \"Trigger full codebase analysis through command palette or status bar\",\n    \"Analyze currently open file for structure and insights\",\n    \"View analyzed code insights in tree view sidebar\",\n    \"Format analysis output for LLM consumption\",\n    \"Navigate to specific code elements (functions, classes, entry points) from analysis views\",\n    \"Export analysis results to markdown or JSON files\",\n    \"View code analysis diagnostics and warnings in Problems panel\",\n    \"Clear analysis cache to force fresh analysis\",\n    \"View product navigation tree showing project structure\",\n    \"View static analysis results in dedicated panel\",\n    \"View unit tests organization in test navigator\",\n    \"See analysis progress in status bar with clickable indicator\"\n  ],\n  \"developerVisibleActions\": [\n    \"Extension initializes on VS Code startup and registers all commands and providers\",\n    \"File watcher monitors workspace for changes and triggers automatic re-analysis\",\n    \"Analysis results are cached to improve performance on subsequent requests\",\n    \"Multiple webview providers display different aspects of analysis (insights, static analysis, unit tests)\",\n    \"Command handlers process user actions and coordinate between analyzer, generators, and UI components\",\n    \"Diagnostics provider updates Problems panel with code issues found during analysis\",\n    \"Status bar item shows current analysis state and provides quick access to analysis commands\",\n    \"Extension uses bootstrapper pattern to initialize components in correct dependency order\",\n    \"Configuration manager provides centralized access to extension settings\",\n    \"Error handler catches and displays user-friendly error messages for analysis failures\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"activate\",\n      \"desc\": \"Entry point that initializes the extension, sets up all providers, registers commands, and starts file watching\",\n      \"inputs\": \"context: vscode.ExtensionContext\",\n      \"outputs\": \"void (registers disposables in context)\"\n    },\n    {\n      \"name\": \"deactivate\",\n      \"desc\": \"Cleanup function called when extension is disabled or VS Code closes\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"analyzeWorkspace\",\n      \"desc\": \"Analyzes entire workspace codebase and updates all views with results\",\n      \"inputs\": \"none (uses workspace folders)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"analyzeCurrentFile\",\n      \"desc\": \"Analyzes the currently active editor file and displays results\",\n      \"inputs\": \"none (uses active text editor)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"formatForLLM\",\n      \"desc\": \"Formats analysis output in LLM-friendly format and displays in editor\",\n      \"inputs\": \"none (uses cached analysis)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"exportAnalysis\",\n      \"desc\": \"Exports current analysis results to file (markdown or JSON format)\",\n      \"inputs\": \"format: 'markdown' | 'json'\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"clearCache\",\n      \"desc\": \"Clears analysis cache and forces fresh analysis on next request\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"navigateToElement\",\n      \"desc\": \"Opens file and jumps to specific code element location from analysis view\",\n      \"inputs\": \"item: TreeItem | AnalysisItem | InsightItem | StaticAnalysisItem\",\n      \"outputs\": \"Promise<void>\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"./analyzer\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./fileWatcher\",\n    \"./insightsTreeView\",\n    \"./diagnosticsProvider\",\n    \"./cache\",\n    \"./llmIntegration\",\n    \"./productNavigator\",\n    \"./analysisViewer\",\n    \"./insightsViewer\",\n    \"./staticAnalysisViewer\",\n    \"./unitTestsNavigator\",\n    \"./config/configurationManager\",\n    \"./utils/errorHandler\",\n    \"./ui/webview/webviewTemplateEngine\",\n    \"./domain/bootstrap/extensionBootstrapper\",\n    \"./domain/bootstrap/commandRegistry\",\n    \"./domain/handlers/navigationHandler\"\n  ],\n  \"intent\": \"This file exists as the main entry point and orchestrator for the VS Code extension. It solves the problem of coordinating multiple subsystems (analysis, UI, caching, file watching) into a cohesive user experience, registering all commands and views that users interact with, and managing the lifecycle of extension components from activation to deactivation.\"\n}\n```"
    },
    {
      "file": "src/fileAccessHelper.ts",
      "role": "Core Logic",
      "purpose": "Provides file reading and grep search functionality to enable iterative LLM analysis of code workspaces",
      "userVisibleActions": [
        "Search for code patterns across project files using grep",
        "View file contents on demand during analysis",
        "See search results with line numbers and context",
        "Get organized file listings by folder structure"
      ],
      "developerVisibleActions": [
        "Request specific files by path to read their contents",
        "Search for text patterns across the codebase with optional file filtering",
        "Limit search results to prevent overwhelming output",
        "Receive structured responses with file paths, line numbers, and content",
        "Get file listings organized by directory with metadata (lines, language)",
        "Process batch requests for multiple files or searches",
        "Handle workspace-relative file paths automatically"
      ],
      "keyFunctions": [
        {
          "name": "getFileListing",
          "desc": "Returns organized directory structure of files",
          "inputs": "Array of file objects with path, lines, and language",
          "outputs": "Formatted string showing files grouped by folder"
        },
        {
          "name": "processRequests",
          "desc": "Handles batch file reading and grep search requests",
          "inputs": "Array of FileRequest or GrepRequest objects",
          "outputs": "Array of FileResponse or GrepResponse objects"
        },
        {
          "name": "readFile",
          "desc": "Reads a single file and returns its content with metadata",
          "inputs": "File path string",
          "outputs": "FileResponse with content, line count, and exists flag"
        },
        {
          "name": "grepFiles",
          "desc": "Searches files for text patterns with optional filtering",
          "inputs": "Search pattern, file pattern (glob), max results limit",
          "outputs": "GrepResponse with matches, line numbers, and context"
        },
        {
          "name": "getFileContent",
          "desc": "Retrieves raw file content",
          "inputs": "File path",
          "outputs": "String content or error"
        }
      ],
      "dependencies": [
        "fs",
        "path"
      ],
      "intent": "This file exists to give LLMs the ability to explore codebases iteratively - instead of loading all files at once, the LLM can request specific files or search for patterns as needed during analysis, making the process more efficient and token-conscious",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides file reading and grep search functionality to enable iterative LLM analysis of code workspaces\",\n  \"userVisibleActions\": [\n    \"Search for code patterns across project files using grep\",\n    \"View file contents on demand during analysis\",\n    \"See search results with line numbers and context\",\n    \"Get organized file listings by folder structure\"\n  ],\n  \"developerVisibleActions\": [\n    \"Request specific files by path to read their contents\",\n    \"Search for text patterns across the codebase with optional file filtering\",\n    \"Limit search results to prevent overwhelming output\",\n    \"Receive structured responses with file paths, line numbers, and content\",\n    \"Get file listings organized by directory with metadata (lines, language)\",\n    \"Process batch requests for multiple files or searches\",\n    \"Handle workspace-relative file paths automatically\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"getFileListing\",\n      \"desc\": \"Returns organized directory structure of files\",\n      \"inputs\": \"Array of file objects with path, lines, and language\",\n      \"outputs\": \"Formatted string showing files grouped by folder\"\n    },\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Handles batch file reading and grep search requests\",\n      \"inputs\": \"Array of FileRequest or GrepRequest objects\",\n      \"outputs\": \"Array of FileResponse or GrepResponse objects\"\n    },\n    {\n      \"name\": \"readFile\",\n      \"desc\": \"Reads a single file and returns its content with metadata\",\n      \"inputs\": \"File path string\",\n      \"outputs\": \"FileResponse with content, line count, and exists flag\"\n    },\n    {\n      \"name\": \"grepFiles\",\n      \"desc\": \"Searches files for text patterns with optional filtering\",\n      \"inputs\": \"Search pattern, file pattern (glob), max results limit\",\n      \"outputs\": \"GrepResponse with matches, line numbers, and context\"\n    },\n    {\n      \"name\": \"getFileContent\",\n      \"desc\": \"Retrieves raw file content\",\n      \"inputs\": \"File path\",\n      \"outputs\": \"String content or error\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\"\n  ],\n  \"intent\": \"This file exists to give LLMs the ability to explore codebases iteratively - instead of loading all files at once, the LLM can request specific files or search for patterns as needed during analysis, making the process more efficient and token-conscious\"\n}\n```"
    },
    {
      "file": "src/fileDocumentation.ts",
      "role": "Core Logic",
      "purpose": "Defines the structured data models and type definitions for organizing code documentation at file, module, and product levels.",
      "userVisibleActions": [
        "User can view file-level summaries showing what each code file does",
        "User can see module-level rollups grouping related files by functionality",
        "User can browse product-level documentation with architecture diagrams",
        "User can access API endpoints, CLI commands, and worker job flows",
        "User can view dependency graphs showing how components relate"
      ],
      "developerVisibleActions": [
        "Developer defines file summaries with role, purpose, and key functions",
        "Developer organizes files into modules (API, CLI, workers, core, GUI)",
        "Developer documents user-facing actions separately from internal behavior",
        "Developer creates structured metadata for endpoints, commands, and workers",
        "Developer generates product documentation with overview and architecture",
        "Developer tracks dependencies between files and components",
        "Developer stores raw LLM responses alongside structured data"
      ],
      "keyFunctions": [
        {
          "name": "FileSummary",
          "desc": "Represents a single file's documentation including role, purpose, actions, and dependencies",
          "inputs": "file path, role, purpose, actions, functions, dependencies, intent",
          "outputs": "Structured file documentation object"
        },
        {
          "name": "ModuleSummary",
          "desc": "Aggregates multiple files into a module with capabilities, endpoints, commands, or workers",
          "inputs": "module path, type, capabilities, files array, optional endpoints/commands/workers",
          "outputs": "Module-level documentation object"
        },
        {
          "name": "EnhancedProductDocumentation",
          "desc": "Top-level product documentation with overview, user perspectives, architecture, and workflow integration",
          "inputs": "overview, capabilities, user perspectives (GUI/CLI/API/CI-CD), architecture, diagrams, metadata",
          "outputs": "Complete product documentation structure"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "./analyzer"
      ],
      "intent": "This file exists to establish a hierarchical documentation structure that transforms raw code analysis into user-friendly documentation at three levels: individual files, functional modules, and complete product overview. It separates user-visible behavior from developer-facing implementation details, enabling stakeholders at different levels to understand the codebase from their perspective.",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines the structured data models and type definitions for organizing code documentation at file, module, and product levels.\",\n  \"userVisibleActions\": [\n    \"User can view file-level summaries showing what each code file does\",\n    \"User can see module-level rollups grouping related files by functionality\",\n    \"User can browse product-level documentation with architecture diagrams\",\n    \"User can access API endpoints, CLI commands, and worker job flows\",\n    \"User can view dependency graphs showing how components relate\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer defines file summaries with role, purpose, and key functions\",\n    \"Developer organizes files into modules (API, CLI, workers, core, GUI)\",\n    \"Developer documents user-facing actions separately from internal behavior\",\n    \"Developer creates structured metadata for endpoints, commands, and workers\",\n    \"Developer generates product documentation with overview and architecture\",\n    \"Developer tracks dependencies between files and components\",\n    \"Developer stores raw LLM responses alongside structured data\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"FileSummary\",\n      \"desc\": \"Represents a single file's documentation including role, purpose, actions, and dependencies\",\n      \"inputs\": \"file path, role, purpose, actions, functions, dependencies, intent\",\n      \"outputs\": \"Structured file documentation object\"\n    },\n    {\n      \"name\": \"ModuleSummary\",\n      \"desc\": \"Aggregates multiple files into a module with capabilities, endpoints, commands, or workers\",\n      \"inputs\": \"module path, type, capabilities, files array, optional endpoints/commands/workers\",\n      \"outputs\": \"Module-level documentation object\"\n    },\n    {\n      \"name\": \"EnhancedProductDocumentation\",\n      \"desc\": \"Top-level product documentation with overview, user perspectives, architecture, and workflow integration\",\n      \"inputs\": \"overview, capabilities, user perspectives (GUI/CLI/API/CI-CD), architecture, diagrams, metadata\",\n      \"outputs\": \"Complete product documentation structure\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to establish a hierarchical documentation structure that transforms raw code analysis into user-friendly documentation at three levels: individual files, functional modules, and complete product overview. It separates user-visible behavior from developer-facing implementation details, enabling stakeholders at different levels to understand the codebase from their perspective.\"\n}\n```"
    },
    {
      "file": "src/fileWatcher.ts",
      "role": "Core Logic",
      "purpose": "Monitors file changes in the workspace and triggers automatic code analysis when files are saved",
      "userVisibleActions": [
        "Automatically analyzes code when files are saved in the editor",
        "Shows analysis progress indicator during file analysis",
        "Updates diagnostics and insights view after file changes",
        "Respects user's 'analyze on save' configuration setting"
      ],
      "developerVisibleActions": [
        "Starts/stops file watching based on configuration settings",
        "Debounces analysis requests to prevent multiple simultaneous analyses",
        "Handles document save events and triggers analysis pipeline",
        "Manages analysis state to prevent concurrent analyses",
        "Cleans up resources when stopping the watcher"
      ],
      "keyFunctions": [
        {
          "name": "start",
          "desc": "Begins watching for file save events if analyze-on-save is enabled",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "stop",
          "desc": "Stops watching for file changes and cleans up resources",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "onFileSaved",
          "desc": "Handles file save events and triggers debounced analysis",
          "inputs": "document (TextDocument)",
          "outputs": "Promise<void>"
        },
        {
          "name": "shouldAnalyzeFile",
          "desc": "Determines if a file should be analyzed based on file type and configuration",
          "inputs": "document (TextDocument)",
          "outputs": "boolean"
        },
        {
          "name": "triggerAnalysis",
          "desc": "Executes the full analysis pipeline for a document",
          "inputs": "document (TextDocument)",
          "outputs": "Promise<void>"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all resources and event listeners",
          "inputs": "none",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "CodeAnalyzer",
        "InsightGenerator",
        "DiagnosticsProvider",
        "InsightsTreeProvider",
        "ConfigurationManager",
        "ErrorHandler",
        "FileWatcherService"
      ],
      "intent": "This file exists to provide automatic, real-time code analysis by monitoring when users save files. It solves the problem of having to manually trigger analysis by automatically detecting file changes and running the analysis pipeline, while preventing duplicate analyses through debouncing and state management.",
      "rawContent": "```json\n{\n  \"purpose\": \"Monitors file changes in the workspace and triggers automatic code analysis when files are saved\",\n  \"userVisibleActions\": [\n    \"Automatically analyzes code when files are saved in the editor\",\n    \"Shows analysis progress indicator during file analysis\",\n    \"Updates diagnostics and insights view after file changes\",\n    \"Respects user's 'analyze on save' configuration setting\"\n  ],\n  \"developerVisibleActions\": [\n    \"Starts/stops file watching based on configuration settings\",\n    \"Debounces analysis requests to prevent multiple simultaneous analyses\",\n    \"Handles document save events and triggers analysis pipeline\",\n    \"Manages analysis state to prevent concurrent analyses\",\n    \"Cleans up resources when stopping the watcher\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"start\",\n      \"desc\": \"Begins watching for file save events if analyze-on-save is enabled\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"stop\",\n      \"desc\": \"Stops watching for file changes and cleans up resources\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"onFileSaved\",\n      \"desc\": \"Handles file save events and triggers debounced analysis\",\n      \"inputs\": \"document (TextDocument)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"shouldAnalyzeFile\",\n      \"desc\": \"Determines if a file should be analyzed based on file type and configuration\",\n      \"inputs\": \"document (TextDocument)\",\n      \"outputs\": \"boolean\"\n    },\n    {\n      \"name\": \"triggerAnalysis\",\n      \"desc\": \"Executes the full analysis pipeline for a document\",\n      \"inputs\": \"document (TextDocument)\",\n      \"outputs\": \"Promise<void>\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all resources and event listeners\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"CodeAnalyzer\",\n    \"InsightGenerator\",\n    \"DiagnosticsProvider\",\n    \"InsightsTreeProvider\",\n    \"ConfigurationManager\",\n    \"ErrorHandler\",\n    \"FileWatcherService\"\n  ],\n  \"intent\": \"This file exists to provide automatic, real-time code analysis by monitoring when users save files. It solves the problem of having to manually trigger analysis by automatically detecting file changes and running the analysis pipeline, while preventing duplicate analyses through debouncing and state management.\"\n}\n```"
    },
    {
      "file": "src/insightGenerator.ts",
      "role": "Core Logic",
      "purpose": "Generates code quality insights and recommendations by analyzing code files for issues like large files, orphaned code, circular dependencies, and complexity problems.",
      "userVisibleActions": [
        "Displays warnings when files exceed 500 lines of code",
        "Shows alerts for orphaned files that aren't imported anywhere",
        "Highlights missing entry points in the project",
        "Reports potential circular dependency issues",
        "Identifies 'god objects' (files with too many exports or responsibilities)",
        "Flags potential dead code that may not be used",
        "Provides file organization recommendations",
        "Reports overly complex functions that need refactoring",
        "Shows code snippets with specific issues",
        "Displays severity levels (error, warning, info) for each insight",
        "Provides actionable suggestions for fixing each issue"
      ],
      "developerVisibleActions": [
        "Call generateInsights() with code analysis to get all insights for a project",
        "Call generateInsightsForFile() to get insights for a specific file path",
        "Receive structured Insight objects containing id, title, description, severity, category, file location, line number, suggestion, and optional code snippet",
        "Use insights to improve code quality through automated analysis",
        "Filter insights by severity (error, warning, info) or category",
        "Integrate insight generation into code review or CI/CD workflows"
      ],
      "keyFunctions": [
        {
          "name": "generateInsights",
          "desc": "Analyzes entire codebase and returns all quality insights",
          "inputs": "CodeAnalysis object containing file and function information",
          "outputs": "Array of Insight objects with detected issues and recommendations"
        },
        {
          "name": "generateInsightsForFile",
          "desc": "Analyzes a specific file and returns insights only for that file",
          "inputs": "CodeAnalysis object and file path string",
          "outputs": "Array of Insight objects specific to the requested file"
        },
        {
          "name": "checkLargeFiles",
          "desc": "Detects files exceeding recommended line count",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for large files"
        },
        {
          "name": "checkOrphanedFiles",
          "desc": "Finds files that aren't imported or used anywhere",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for orphaned files"
        },
        {
          "name": "checkEntryPoints",
          "desc": "Verifies project has proper entry points",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for missing entry points"
        },
        {
          "name": "checkCircularDependencies",
          "desc": "Detects potential circular import dependencies",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for circular dependencies"
        },
        {
          "name": "checkGodObjects",
          "desc": "Identifies files with too many responsibilities or exports",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for god objects"
        },
        {
          "name": "checkDeadCode",
          "desc": "Finds code that may not be actively used",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for potential dead code"
        },
        {
          "name": "checkFileOrganization",
          "desc": "Evaluates project structure and organization",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for organization issues"
        },
        {
          "name": "checkFunctionComplexity",
          "desc": "Analyzes function complexity and size",
          "inputs": "CodeAnalysis object",
          "outputs": "Array of Insight objects for overly complex functions"
        }
      ],
      "dependencies": [
        "./analyzer"
      ],
      "intent": "This file exists to provide automated code quality analysis and actionable recommendations to developers. It solves the problem of manually identifying code smells, architectural issues, and maintainability concerns by automatically scanning code and generating structured insights with severity levels, categories, and improvement suggestions.",
      "rawContent": "```json\n{\n  \"purpose\": \"Generates code quality insights and recommendations by analyzing code files for issues like large files, orphaned code, circular dependencies, and complexity problems.\",\n  \"userVisibleActions\": [\n    \"Displays warnings when files exceed 500 lines of code\",\n    \"Shows alerts for orphaned files that aren't imported anywhere\",\n    \"Highlights missing entry points in the project\",\n    \"Reports potential circular dependency issues\",\n    \"Identifies 'god objects' (files with too many exports or responsibilities)\",\n    \"Flags potential dead code that may not be used\",\n    \"Provides file organization recommendations\",\n    \"Reports overly complex functions that need refactoring\",\n    \"Shows code snippets with specific issues\",\n    \"Displays severity levels (error, warning, info) for each insight\",\n    \"Provides actionable suggestions for fixing each issue\"\n  ],\n  \"developerVisibleActions\": [\n    \"Call generateInsights() with code analysis to get all insights for a project\",\n    \"Call generateInsightsForFile() to get insights for a specific file path\",\n    \"Receive structured Insight objects containing id, title, description, severity, category, file location, line number, suggestion, and optional code snippet\",\n    \"Use insights to improve code quality through automated analysis\",\n    \"Filter insights by severity (error, warning, info) or category\",\n    \"Integrate insight generation into code review or CI/CD workflows\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"generateInsights\",\n      \"desc\": \"Analyzes entire codebase and returns all quality insights\",\n      \"inputs\": \"CodeAnalysis object containing file and function information\",\n      \"outputs\": \"Array of Insight objects with detected issues and recommendations\"\n    },\n    {\n      \"name\": \"generateInsightsForFile\",\n      \"desc\": \"Analyzes a specific file and returns insights only for that file\",\n      \"inputs\": \"CodeAnalysis object and file path string\",\n      \"outputs\": \"Array of Insight objects specific to the requested file\"\n    },\n    {\n      \"name\": \"checkLargeFiles\",\n      \"desc\": \"Detects files exceeding recommended line count\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for large files\"\n    },\n    {\n      \"name\": \"checkOrphanedFiles\",\n      \"desc\": \"Finds files that aren't imported or used anywhere\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for orphaned files\"\n    },\n    {\n      \"name\": \"checkEntryPoints\",\n      \"desc\": \"Verifies project has proper entry points\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for missing entry points\"\n    },\n    {\n      \"name\": \"checkCircularDependencies\",\n      \"desc\": \"Detects potential circular import dependencies\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for circular dependencies\"\n    },\n    {\n      \"name\": \"checkGodObjects\",\n      \"desc\": \"Identifies files with too many responsibilities or exports\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for god objects\"\n    },\n    {\n      \"name\": \"checkDeadCode\",\n      \"desc\": \"Finds code that may not be actively used\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for potential dead code\"\n    },\n    {\n      \"name\": \"checkFileOrganization\",\n      \"desc\": \"Evaluates project structure and organization\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for organization issues\"\n    },\n    {\n      \"name\": \"checkFunctionComplexity\",\n      \"desc\": \"Analyzes function complexity and size\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"Array of Insight objects for overly complex functions\"\n    }\n  ],\n  \"dependencies\": [\n    \"./analyzer\"\n  ],\n  \"intent\": \"This file exists to provide automated code quality analysis and actionable recommendations to developers. It solves the problem of manually identifying code smells, architectural issues, and maintainability concerns by automatically scanning code and generating structured insights with severity levels, categories, and improvement suggestions.\"\n}\n```"
    },
    {
      "file": "src/insightsTreeView.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view in the VS Code sidebar that displays code insights, documentation status, analysis results, and generated reports with interactive actions.",
      "userVisibleActions": [
        "View a tree of code analysis insights organized by severity (critical, high, medium, low)",
        "See status indicators for product documentation generation (idle, generating, complete)",
        "See status indicators for insights generation and unit test generation",
        "Click on insights to navigate to the relevant code location",
        "Refresh the insights tree to update displayed information",
        "Generate product documentation from the tree view",
        "Generate architecture documentation from the tree view",
        "Generate unit tests from the tree view",
        "Open generated report files (workspace, product, architecture, unit test, static analysis)",
        "View timestamp information showing when reports were generated",
        "Copy insight text to clipboard",
        "Expand/collapse insight categories and details",
        "See a 'No insights available' message when no analysis has been performed",
        "View detailed insight information including file path, line number, and recommendations"
      ],
      "developerVisibleActions": [
        "Tree view updates automatically when insights are generated or refreshed",
        "Status changes are reflected in real-time (generating, complete, idle)",
        "Reports are saved to workspace storage and persist across sessions",
        "Tree items show contextual actions based on their type (generate, open, refresh)",
        "LLM-generated insights are displayed alongside traditional code insights",
        "Timestamps are persisted and restored when VS Code restarts",
        "Tree structure adapts based on available data (insights, reports, documentation)",
        "Context values enable conditional command visibility in the tree"
      ],
      "keyFunctions": [
        {
          "name": "setInsights",
          "desc": "Updates the tree view with new code insights",
          "inputs": "Array of Insight objects",
          "outputs": "Triggers tree refresh"
        },
        {
          "name": "setLLMInsights",
          "desc": "Updates the tree view with LLM-generated insights and documentation status",
          "inputs": "LLMInsights object containing status and generated content",
          "outputs": "Triggers tree refresh and saves timestamps"
        },
        {
          "name": "getTreeItem",
          "desc": "Converts a tree item into a VS Code tree item for display",
          "inputs": "TreeItem object",
          "outputs": "vscode.TreeItem with display properties"
        },
        {
          "name": "getChildren",
          "desc": "Provides the hierarchical structure of tree items",
          "inputs": "Optional parent TreeItem",
          "outputs": "Array of child TreeItem objects"
        },
        {
          "name": "setReportPath",
          "desc": "Saves the path to a generated report file",
          "inputs": "Report file path and type (workspace, product, architecture, unit test)",
          "outputs": "Updates tree display with report availability"
        },
        {
          "name": "refresh",
          "desc": "Forces the tree view to reload and display updated data",
          "inputs": "Optional TreeItem to refresh specific branch",
          "outputs": "Tree view refresh event"
        },
        {
          "name": "setStaticAnalysisViewer",
          "desc": "Associates the static analysis viewer with the tree view",
          "inputs": "Static analysis viewer instance",
          "outputs": "Enables static analysis report display"
        },
        {
          "name": "loadPersistedState",
          "desc": "Restores saved report paths and timestamps from previous sessions",
          "inputs": "Reads from extension context storage",
          "outputs": "Restores tree state with persisted data"
        }
      ],
      "dependencies": [
        "vscode",
        "./insightGenerator",
        "./llmFormatter",
        "./llmService"
      ],
      "intent": "This file exists to provide a visual, interactive sidebar panel in VS Code where users can view code analysis results, track documentation generation progress, access generated reports, and trigger various code analysis and documentation actions without leaving the editor.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view in the VS Code sidebar that displays code insights, documentation status, analysis results, and generated reports with interactive actions.\",\n  \"userVisibleActions\": [\n    \"View a tree of code analysis insights organized by severity (critical, high, medium, low)\",\n    \"See status indicators for product documentation generation (idle, generating, complete)\",\n    \"See status indicators for insights generation and unit test generation\",\n    \"Click on insights to navigate to the relevant code location\",\n    \"Refresh the insights tree to update displayed information\",\n    \"Generate product documentation from the tree view\",\n    \"Generate architecture documentation from the tree view\",\n    \"Generate unit tests from the tree view\",\n    \"Open generated report files (workspace, product, architecture, unit test, static analysis)\",\n    \"View timestamp information showing when reports were generated\",\n    \"Copy insight text to clipboard\",\n    \"Expand/collapse insight categories and details\",\n    \"See a 'No insights available' message when no analysis has been performed\",\n    \"View detailed insight information including file path, line number, and recommendations\"\n  ],\n  \"developerVisibleActions\": [\n    \"Tree view updates automatically when insights are generated or refreshed\",\n    \"Status changes are reflected in real-time (generating, complete, idle)\",\n    \"Reports are saved to workspace storage and persist across sessions\",\n    \"Tree items show contextual actions based on their type (generate, open, refresh)\",\n    \"LLM-generated insights are displayed alongside traditional code insights\",\n    \"Timestamps are persisted and restored when VS Code restarts\",\n    \"Tree structure adapts based on available data (insights, reports, documentation)\",\n    \"Context values enable conditional command visibility in the tree\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"setInsights\",\n      \"desc\": \"Updates the tree view with new code insights\",\n      \"inputs\": \"Array of Insight objects\",\n      \"outputs\": \"Triggers tree refresh\"\n    },\n    {\n      \"name\": \"setLLMInsights\",\n      \"desc\": \"Updates the tree view with LLM-generated insights and documentation status\",\n      \"inputs\": \"LLMInsights object containing status and generated content\",\n      \"outputs\": \"Triggers tree refresh and saves timestamps\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts a tree item into a VS Code tree item for display\",\n      \"inputs\": \"TreeItem object\",\n      \"outputs\": \"vscode.TreeItem with display properties\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Provides the hierarchical structure of tree items\",\n      \"inputs\": \"Optional parent TreeItem\",\n      \"outputs\": \"Array of child TreeItem objects\"\n    },\n    {\n      \"name\": \"setReportPath\",\n      \"desc\": \"Saves the path to a generated report file\",\n      \"inputs\": \"Report file path and type (workspace, product, architecture, unit test)\",\n      \"outputs\": \"Updates tree display with report availability\"\n    },\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Forces the tree view to reload and display updated data\",\n      \"inputs\": \"Optional TreeItem to refresh specific branch\",\n      \"outputs\": \"Tree view refresh event\"\n    },\n    {\n      \"name\": \"setStaticAnalysisViewer\",\n      \"desc\": \"Associates the static analysis viewer with the tree view\",\n      \"inputs\": \"Static analysis viewer instance\",\n      \"outputs\": \"Enables static analysis report display\"\n    },\n    {\n      \"name\": \"loadPersistedState\",\n      \"desc\": \"Restores saved report paths and timestamps from previous sessions\",\n      \"inputs\": \"Reads from extension context storage\",\n      \"outputs\": \"Restores tree state with persisted data\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./insightGenerator\",\n    \"./llmFormatter\",\n    \"./llmService\"\n  ],\n  \"intent\": \"This file exists to provide a visual, interactive sidebar panel in VS Code where users can view code analysis results, track documentation generation progress, access generated reports, and trigger various code analysis and documentation actions without leaving the editor.\"\n}\n```"
    },
    {
      "file": "src/insightsViewer.ts",
      "role": "GUI View",
      "purpose": "Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, including purpose, relationships, and file organization.",
      "userVisibleActions": [
        "View architecture insights in a tree view panel showing project purpose, file relationships, and directory structure",
        "Click on files in the insights tree to open them in the editor",
        "See color-coded file roles (Model, View, Controller, Service, etc.) with icons",
        "Browse files grouped by their architectural purpose",
        "Refresh the insights view to reload analysis results",
        "See file summaries and purposes when hovering or selecting items",
        "View metadata like LOC (lines of code) and programming language for each file",
        "Access insights even when files are missing from the workspace",
        "See real-time updates when insights.json or project-purpose.md files change"
      ],
      "developerVisibleActions": [
        "Tree view automatically refreshes when .shadow/docs/insights.json is modified",
        "Tree view updates when .shadow/project-purpose.md changes",
        "Files are organized by their architectural role (GUI, Model, Service, Controller, etc.)",
        "Clicking a file item navigates to that file in the editor",
        "Insights data is loaded from the .shadow/docs directory",
        "File watcher service monitors changes to insights and purpose files",
        "Tree provider implements VS Code TreeDataProvider interface for rendering",
        "Handles missing files gracefully by showing them in the tree with appropriate styling"
      ],
      "keyFunctions": [
        {
          "name": "refresh",
          "desc": "Reloads insights data from the file system and updates the tree view",
          "inputs": "insightsData (optional LLMInsights object)",
          "outputs": "void"
        },
        {
          "name": "getTreeItem",
          "desc": "Converts an InsightItem into a VS Code TreeItem for display in the tree view",
          "inputs": "element (InsightItem)",
          "outputs": "vscode.TreeItem"
        },
        {
          "name": "getChildren",
          "desc": "Returns child items for a given tree node (categories, files, or metadata)",
          "inputs": "element (optional InsightItem)",
          "outputs": "Promise<InsightItem[]>"
        },
        {
          "name": "setupFileWatcher",
          "desc": "Creates file system watchers to monitor changes to insights.json and project-purpose.md",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getRoleIcon",
          "desc": "Returns the appropriate icon name for a file based on its architectural role",
          "inputs": "role (string)",
          "outputs": "string (icon name)"
        },
        {
          "name": "getRoleColor",
          "desc": "Returns a color code for displaying files based on their role category",
          "inputs": "role (string)",
          "outputs": "string (color code)"
        },
        {
          "name": "dispose",
          "desc": "Cleans up file watchers and other resources when the provider is destroyed",
          "inputs": "none",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs",
        "./llmService (LLMInsights type)",
        "./domain/services/fileWatcherService"
      ],
      "intent": "This file exists to visualize AI-generated architecture insights in VS Code's sidebar, helping developers understand their codebase structure by showing how files relate to each other, what roles they play, and what purpose they serve. It solves the problem of navigating and understanding large codebases by providing an architectural overview that auto-updates as the analysis changes.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a tree view in VS Code that displays AI-generated architecture insights about the codebase, including purpose, relationships, and file organization.\",\n  \"userVisibleActions\": [\n    \"View architecture insights in a tree view panel showing project purpose, file relationships, and directory structure\",\n    \"Click on files in the insights tree to open them in the editor\",\n    \"See color-coded file roles (Model, View, Controller, Service, etc.) with icons\",\n    \"Browse files grouped by their architectural purpose\",\n    \"Refresh the insights view to reload analysis results\",\n    \"See file summaries and purposes when hovering or selecting items\",\n    \"View metadata like LOC (lines of code) and programming language for each file\",\n    \"Access insights even when files are missing from the workspace\",\n    \"See real-time updates when insights.json or project-purpose.md files change\"\n  ],\n  \"developerVisibleActions\": [\n    \"Tree view automatically refreshes when .shadow/docs/insights.json is modified\",\n    \"Tree view updates when .shadow/project-purpose.md changes\",\n    \"Files are organized by their architectural role (GUI, Model, Service, Controller, etc.)\",\n    \"Clicking a file item navigates to that file in the editor\",\n    \"Insights data is loaded from the .shadow/docs directory\",\n    \"File watcher service monitors changes to insights and purpose files\",\n    \"Tree provider implements VS Code TreeDataProvider interface for rendering\",\n    \"Handles missing files gracefully by showing them in the tree with appropriate styling\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"refresh\",\n      \"desc\": \"Reloads insights data from the file system and updates the tree view\",\n      \"inputs\": \"insightsData (optional LLMInsights object)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getTreeItem\",\n      \"desc\": \"Converts an InsightItem into a VS Code TreeItem for display in the tree view\",\n      \"inputs\": \"element (InsightItem)\",\n      \"outputs\": \"vscode.TreeItem\"\n    },\n    {\n      \"name\": \"getChildren\",\n      \"desc\": \"Returns child items for a given tree node (categories, files, or metadata)\",\n      \"inputs\": \"element (optional InsightItem)\",\n      \"outputs\": \"Promise<InsightItem[]>\"\n    },\n    {\n      \"name\": \"setupFileWatcher\",\n      \"desc\": \"Creates file system watchers to monitor changes to insights.json and project-purpose.md\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getRoleIcon\",\n      \"desc\": \"Returns the appropriate icon name for a file based on its architectural role\",\n      \"inputs\": \"role (string)\",\n      \"outputs\": \"string (icon name)\"\n    },\n    {\n      \"name\": \"getRoleColor\",\n      \"desc\": \"Returns a color code for displaying files based on their role category\",\n      \"inputs\": \"role (string)\",\n      \"outputs\": \"string (color code)\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up file watchers and other resources when the provider is destroyed\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\",\n    \"./llmService (LLMInsights type)\",\n    \"./domain/services/fileWatcherService\"\n  ],\n  \"intent\": \"This file exists to visualize AI-generated architecture insights in VS Code's sidebar, helping developers understand their codebase structure by showing how files relate to each other, what roles they play, and what purpose they serve. It solves the problem of navigating and understanding large codebases by providing an architectural overview that auto-updates as the analysis changes.\"\n}\n```"
    },
    {
      "file": "src/llmFormatter.ts",
      "role": "Core Logic",
      "purpose": "Formats code architecture insights into different output styles optimized for various LLM tools and display contexts.",
      "userVisibleActions": [
        "View architecture issues organized by severity (Critical, Warnings, Informational)",
        "See formatted output optimized for Cursor AI assistant",
        "See formatted output optimized for ChatGPT",
        "View compact format for quick scanning of issues",
        "Read generic formatted output compatible with any LLM",
        "See emoji indicators (🔴, ⚠️, ℹ️) for issue severity levels",
        "View actionable guidance on what help is needed from the LLM"
      ],
      "developerVisibleActions": [
        "Choose output format (cursor, chatgpt, compact, generic) when formatting insights",
        "Pass array of Insight objects to be formatted",
        "Receive formatted markdown string ready for display or LLM consumption",
        "Get insights automatically grouped by severity level",
        "Get structured output with clear sections for issue categories",
        "Get prompts embedded in output to guide LLM responses"
      ],
      "keyFunctions": [
        {
          "name": "formatInsights",
          "desc": "Routes insights to appropriate formatter based on specified format type",
          "inputs": "insights: Insight[], format: string (default 'cursor')",
          "outputs": "Formatted string in requested style"
        },
        {
          "name": "formatForCursor",
          "desc": "Creates Cursor AI-optimized output with severity grouping and action requests",
          "inputs": "insights: Insight[]",
          "outputs": "Markdown string with sections for errors, warnings, info, and guidance prompts"
        },
        {
          "name": "formatForChatGPT",
          "desc": "Creates ChatGPT-optimized output formatted as a conversation starter",
          "inputs": "insights: Insight[]",
          "outputs": "Markdown string formatted as a help request to ChatGPT"
        },
        {
          "name": "formatCompact",
          "desc": "Creates condensed output showing only essential information",
          "inputs": "insights: Insight[]",
          "outputs": "Compact markdown string with minimal formatting"
        },
        {
          "name": "formatGeneric",
          "desc": "Creates standard output compatible with any LLM or display context",
          "inputs": "insights: Insight[]",
          "outputs": "Generic markdown string with basic structure"
        },
        {
          "name": "formatInsightForCursor",
          "desc": "Formats individual insight with file location, issue details, and suggestions",
          "inputs": "insight: Insight",
          "outputs": "Formatted markdown section for single insight"
        }
      ],
      "dependencies": [
        "./insightGenerator"
      ],
      "intent": "Transforms technical code analysis insights into human-readable, LLM-friendly formats that prompt effective assistance from AI coding tools. Solves the problem of presenting architecture issues in a way that maximizes helpful responses from different AI assistants by tailoring the output format and embedded prompts to each tool's strengths.",
      "rawContent": "```json\n{\n  \"purpose\": \"Formats code architecture insights into different output styles optimized for various LLM tools and display contexts.\",\n  \"userVisibleActions\": [\n    \"View architecture issues organized by severity (Critical, Warnings, Informational)\",\n    \"See formatted output optimized for Cursor AI assistant\",\n    \"See formatted output optimized for ChatGPT\",\n    \"View compact format for quick scanning of issues\",\n    \"Read generic formatted output compatible with any LLM\",\n    \"See emoji indicators (🔴, ⚠️, ℹ️) for issue severity levels\",\n    \"View actionable guidance on what help is needed from the LLM\"\n  ],\n  \"developerVisibleActions\": [\n    \"Choose output format (cursor, chatgpt, compact, generic) when formatting insights\",\n    \"Pass array of Insight objects to be formatted\",\n    \"Receive formatted markdown string ready for display or LLM consumption\",\n    \"Get insights automatically grouped by severity level\",\n    \"Get structured output with clear sections for issue categories\",\n    \"Get prompts embedded in output to guide LLM responses\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"formatInsights\",\n      \"desc\": \"Routes insights to appropriate formatter based on specified format type\",\n      \"inputs\": \"insights: Insight[], format: string (default 'cursor')\",\n      \"outputs\": \"Formatted string in requested style\"\n    },\n    {\n      \"name\": \"formatForCursor\",\n      \"desc\": \"Creates Cursor AI-optimized output with severity grouping and action requests\",\n      \"inputs\": \"insights: Insight[]\",\n      \"outputs\": \"Markdown string with sections for errors, warnings, info, and guidance prompts\"\n    },\n    {\n      \"name\": \"formatForChatGPT\",\n      \"desc\": \"Creates ChatGPT-optimized output formatted as a conversation starter\",\n      \"inputs\": \"insights: Insight[]\",\n      \"outputs\": \"Markdown string formatted as a help request to ChatGPT\"\n    },\n    {\n      \"name\": \"formatCompact\",\n      \"desc\": \"Creates condensed output showing only essential information\",\n      \"inputs\": \"insights: Insight[]\",\n      \"outputs\": \"Compact markdown string with minimal formatting\"\n    },\n    {\n      \"name\": \"formatGeneric\",\n      \"desc\": \"Creates standard output compatible with any LLM or display context\",\n      \"inputs\": \"insights: Insight[]\",\n      \"outputs\": \"Generic markdown string with basic structure\"\n    },\n    {\n      \"name\": \"formatInsightForCursor\",\n      \"desc\": \"Formats individual insight with file location, issue details, and suggestions\",\n      \"inputs\": \"insight: Insight\",\n      \"outputs\": \"Formatted markdown section for single insight\"\n    }\n  ],\n  \"dependencies\": [\n    \"./insightGenerator\"\n  ],\n  \"intent\": \"Transforms technical code analysis insights into human-readable, LLM-friendly formats that prompt effective assistance from AI coding tools. Solves the problem of presenting architecture issues in a way that maximizes helpful responses from different AI assistants by tailoring the output format and embedded prompts to each tool's strengths.\"\n}\n```"
    },
    {
      "file": "src/llmIntegration.ts",
      "role": "Core Logic",
      "purpose": "Manages LLM-powered code analysis features, including initializing services, generating documentation, analyzing code, and handling user interactions with AI-generated insights.",
      "userVisibleActions": [
        "Generate documentation for code files and products",
        "View AI-generated insights about code structure and behavior",
        "Navigate through analyzed code via tree views",
        "See analysis progress and status messages in output channel",
        "Access generated documentation in webview panels",
        "View code analysis results including entry points and components",
        "Receive notifications when analysis completes or fails",
        "See API configuration status and warnings"
      ],
      "developerVisibleActions": [
        "Initialize LLM service on extension startup",
        "Trigger code analysis for workspace files",
        "Generate product documentation from analysis results",
        "Request AI insights for specific code contexts",
        "Refresh tree views when analysis data changes",
        "Save and load analysis results from cache",
        "Handle API key configuration and validation",
        "Manage analysis state across sessions",
        "Convert code analysis to LLM context format",
        "Display documentation in formatted webview",
        "Register commands for documentation and analysis actions",
        "Handle errors and display user-friendly messages",
        "Coordinate between analysis services and UI providers"
      ],
      "keyFunctions": [
        {
          "name": "initializeLLMService",
          "desc": "Sets up LLM service and loads saved analysis data on startup",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "generateDocumentation",
          "desc": "Creates AI-generated documentation for code files or entire products",
          "inputs": "file paths, analysis context",
          "outputs": "EnhancedProductDocumentation"
        },
        {
          "name": "analyzeCode",
          "desc": "Performs deep code analysis using LLM to extract structure and behavior",
          "inputs": "workspace paths, file list",
          "outputs": "CodeAnalysis with entry points and insights"
        },
        {
          "name": "requestInsights",
          "desc": "Gets AI-generated insights about code patterns and architecture",
          "inputs": "AnalysisContext",
          "outputs": "LLMInsights"
        },
        {
          "name": "saveCodeAnalysis",
          "desc": "Persists analysis results to cache for future sessions",
          "inputs": "CodeAnalysis object",
          "outputs": "void"
        },
        {
          "name": "loadSavedCodeAnalysis",
          "desc": "Retrieves previously saved analysis from cache",
          "inputs": "workspace identifier",
          "outputs": "CodeAnalysis or null"
        },
        {
          "name": "convertCodeAnalysisToContext",
          "desc": "Transforms code analysis into format suitable for LLM processing",
          "inputs": "CodeAnalysis",
          "outputs": "AnalysisContext"
        },
        {
          "name": "showDocumentation",
          "desc": "Displays generated documentation in webview panel",
          "inputs": "documentation object",
          "outputs": "void"
        }
      ],
      "dependencies": [
        "vscode",
        "fs",
        "path",
        "child_process",
        "util",
        "llmService",
        "insightsTreeView",
        "fileDocumentation",
        "analyzer",
        "productNavigator",
        "analysisViewer",
        "insightsViewer",
        "unitTestsNavigator",
        "logger",
        "llmStateManager",
        "analysisContextBuilder",
        "documentationFormatter",
        "analysisResultRepository"
      ],
      "intent": "This file exists to bridge the gap between VS Code extension UI and LLM analysis capabilities, coordinating all AI-powered features like documentation generation, code insights, and intelligent navigation. It solves the problem of managing complex interactions between user actions, background analysis, state persistence, and AI service calls in a unified way.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages LLM-powered code analysis features, including initializing services, generating documentation, analyzing code, and handling user interactions with AI-generated insights.\",\n  \"userVisibleActions\": [\n    \"Generate documentation for code files and products\",\n    \"View AI-generated insights about code structure and behavior\",\n    \"Navigate through analyzed code via tree views\",\n    \"See analysis progress and status messages in output channel\",\n    \"Access generated documentation in webview panels\",\n    \"View code analysis results including entry points and components\",\n    \"Receive notifications when analysis completes or fails\",\n    \"See API configuration status and warnings\"\n  ],\n  \"developerVisibleActions\": [\n    \"Initialize LLM service on extension startup\",\n    \"Trigger code analysis for workspace files\",\n    \"Generate product documentation from analysis results\",\n    \"Request AI insights for specific code contexts\",\n    \"Refresh tree views when analysis data changes\",\n    \"Save and load analysis results from cache\",\n    \"Handle API key configuration and validation\",\n    \"Manage analysis state across sessions\",\n    \"Convert code analysis to LLM context format\",\n    \"Display documentation in formatted webview\",\n    \"Register commands for documentation and analysis actions\",\n    \"Handle errors and display user-friendly messages\",\n    \"Coordinate between analysis services and UI providers\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"initializeLLMService\",\n      \"desc\": \"Sets up LLM service and loads saved analysis data on startup\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"generateDocumentation\",\n      \"desc\": \"Creates AI-generated documentation for code files or entire products\",\n      \"inputs\": \"file paths, analysis context\",\n      \"outputs\": \"EnhancedProductDocumentation\"\n    },\n    {\n      \"name\": \"analyzeCode\",\n      \"desc\": \"Performs deep code analysis using LLM to extract structure and behavior\",\n      \"inputs\": \"workspace paths, file list\",\n      \"outputs\": \"CodeAnalysis with entry points and insights\"\n    },\n    {\n      \"name\": \"requestInsights\",\n      \"desc\": \"Gets AI-generated insights about code patterns and architecture\",\n      \"inputs\": \"AnalysisContext\",\n      \"outputs\": \"LLMInsights\"\n    },\n    {\n      \"name\": \"saveCodeAnalysis\",\n      \"desc\": \"Persists analysis results to cache for future sessions\",\n      \"inputs\": \"CodeAnalysis object\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"loadSavedCodeAnalysis\",\n      \"desc\": \"Retrieves previously saved analysis from cache\",\n      \"inputs\": \"workspace identifier\",\n      \"outputs\": \"CodeAnalysis or null\"\n    },\n    {\n      \"name\": \"convertCodeAnalysisToContext\",\n      \"desc\": \"Transforms code analysis into format suitable for LLM processing\",\n      \"inputs\": \"CodeAnalysis\",\n      \"outputs\": \"AnalysisContext\"\n    },\n    {\n      \"name\": \"showDocumentation\",\n      \"desc\": \"Displays generated documentation in webview panel\",\n      \"inputs\": \"documentation object\",\n      \"outputs\": \"void\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"fs\",\n    \"path\",\n    \"child_process\",\n    \"util\",\n    \"llmService\",\n    \"insightsTreeView\",\n    \"fileDocumentation\",\n    \"analyzer\",\n    \"productNavigator\",\n    \"analysisViewer\",\n    \"insightsViewer\",\n    \"unitTestsNavigator\",\n    \"logger\",\n    \"llmStateManager\",\n    \"analysisContextBuilder\",\n    \"documentationFormatter\",\n    \"analysisResultRepository\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between VS Code extension UI and LLM analysis capabilities, coordinating all AI-powered features like documentation generation, code insights, and intelligent navigation. It solves the problem of managing complex interactions between user actions, background analysis, state persistence, and AI service calls in a unified way.\"\n}\n```"
    },
    {
      "file": "src/llmSchemas.ts",
      "role": "Core Logic",
      "purpose": "Defines JSON schemas that structure and validate LLM responses to ensure consistent, parseable output formats for code analysis tasks.",
      "userVisibleActions": [
        "Receives structured analysis of product purpose and architecture rationale",
        "Gets organized lists of design decisions and user goals from code analysis",
        "Views categorized code issues with titles, descriptions, and relevant files",
        "Sees risk assessments with severity levels and impact descriptions",
        "Receives actionable recommendations with priorities and effort estimates",
        "Gets structured summaries of codebase analysis results"
      ],
      "developerVisibleActions": [
        "Provides JSON schemas to LLM API calls to guarantee response structure",
        "Ensures LLM responses conform to expected formats without manual parsing",
        "Defines validation rules for product purpose analysis output",
        "Specifies required fields and data types for issue detection",
        "Enforces consistent format for risk assessments and recommendations",
        "Validates that all LLM responses include mandatory properties"
      ],
      "keyFunctions": [
        {
          "name": "productPurposeAnalysisSchema",
          "desc": "Schema for analyzing product purpose, architecture rationale, and design decisions",
          "inputs": "None (exported constant schema object)",
          "outputs": "JSON schema with productPurpose, architectureRationale, designDecisions, userGoals, contextualFactors"
        },
        {
          "name": "issueItemSchema",
          "desc": "Schema for individual code issues with title, description, and relevant files/functions",
          "inputs": "None (nested schema definition)",
          "outputs": "JSON schema with title, description, relevantFiles, relevantFunctions properties"
        }
      ],
      "dependencies": [],
      "intent": "Ensures Claude AI responses for code analysis are consistently structured and machine-parseable, eliminating the need for fragile text parsing and guaranteeing that all required information fields are present in every response.",
      "rawContent": "```json\n{\n  \"purpose\": \"Defines JSON schemas that structure and validate LLM responses to ensure consistent, parseable output formats for code analysis tasks.\",\n  \"userVisibleActions\": [\n    \"Receives structured analysis of product purpose and architecture rationale\",\n    \"Gets organized lists of design decisions and user goals from code analysis\",\n    \"Views categorized code issues with titles, descriptions, and relevant files\",\n    \"Sees risk assessments with severity levels and impact descriptions\",\n    \"Receives actionable recommendations with priorities and effort estimates\",\n    \"Gets structured summaries of codebase analysis results\"\n  ],\n  \"developerVisibleActions\": [\n    \"Provides JSON schemas to LLM API calls to guarantee response structure\",\n    \"Ensures LLM responses conform to expected formats without manual parsing\",\n    \"Defines validation rules for product purpose analysis output\",\n    \"Specifies required fields and data types for issue detection\",\n    \"Enforces consistent format for risk assessments and recommendations\",\n    \"Validates that all LLM responses include mandatory properties\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"productPurposeAnalysisSchema\",\n      \"desc\": \"Schema for analyzing product purpose, architecture rationale, and design decisions\",\n      \"inputs\": \"None (exported constant schema object)\",\n      \"outputs\": \"JSON schema with productPurpose, architectureRationale, designDecisions, userGoals, contextualFactors\"\n    },\n    {\n      \"name\": \"issueItemSchema\",\n      \"desc\": \"Schema for individual code issues with title, description, and relevant files/functions\",\n      \"inputs\": \"None (nested schema definition)\",\n      \"outputs\": \"JSON schema with title, description, relevantFiles, relevantFunctions properties\"\n    }\n  ],\n  \"dependencies\": [],\n  \"intent\": \"Ensures Claude AI responses for code analysis are consistently structured and machine-parseable, eliminating the need for fragile text parsing and guaranteeing that all required information fields are present in every response.\"\n}\n```"
    },
    {
      "file": "src/llmService.ts",
      "role": "Core Logic",
      "purpose": "Provides LLM-powered AI analysis services to generate intelligent insights, documentation, and code analysis by interfacing with OpenAI/Claude APIs.",
      "userVisibleActions": [
        "Generate intelligent insights about codebase purpose and architecture",
        "Create comprehensive product documentation from code analysis",
        "Analyze code quality and provide improvement suggestions",
        "Generate unit test plans for functions",
        "Get AI-powered refactoring suggestions for complex functions",
        "Receive explanations of what the product does and why it was built",
        "View AI-generated module summaries and relationships",
        "See incremental analysis results as codebase changes",
        "Get file-level and function-level documentation generated by AI"
      ],
      "developerVisibleActions": [
        "Call LLM service to analyze codebase structure and purpose",
        "Request AI-generated documentation for entire product",
        "Trigger AI analysis of code quality and architecture",
        "Generate test plans using AI understanding of functions",
        "Request refactoring suggestions for complex code",
        "Use incremental analysis to only analyze changed files",
        "Configure LLM provider (OpenAI, Claude, or local models)",
        "Set custom system prompts for AI analysis",
        "Control token budgets and rate limiting for API calls",
        "Handle retries and errors from LLM API responses",
        "Parse structured AI responses into usable data structures",
        "Access file summaries and module groupings from AI analysis"
      ],
      "keyFunctions": [
        {
          "name": "analyzePurpose",
          "desc": "Analyzes the codebase to determine product purpose, architecture rationale, and key features using AI",
          "inputs": "AnalysisContext with file structure, imports, and entry points",
          "outputs": "ProductPurposeAnalysis with product purpose, architecture, and design patterns"
        },
        {
          "name": "generateEnhancedDocumentation",
          "desc": "Generates comprehensive product documentation including purpose, features, architecture, and user scenarios using AI",
          "inputs": "CodeAnalysis and AnalysisContext",
          "outputs": "EnhancedProductDocumentation with full product overview and technical details"
        },
        {
          "name": "generateLLMInsights",
          "desc": "Generates intelligent insights about code quality, patterns, and improvement suggestions using AI",
          "inputs": "CodeAnalysis with code metrics and structure",
          "outputs": "LLM insights with code quality assessment and recommendations"
        },
        {
          "name": "generateUnitTestPlan",
          "desc": "Creates a comprehensive unit test plan for a specific function using AI analysis",
          "inputs": "Function metadata, file content, and function name",
          "outputs": "Unit test plan with test cases, setup, assertions, and edge cases"
        },
        {
          "name": "generateRefactoringSuggestions",
          "desc": "Provides AI-powered refactoring suggestions for complex or problematic functions",
          "inputs": "Function code, metrics (complexity, length, nesting), and surrounding context",
          "outputs": "Refactoring suggestions with specific improvements and code examples"
        },
        {
          "name": "analyzeIncrementally",
          "desc": "Performs incremental AI analysis only on files that have changed since last analysis",
          "inputs": "Changed file URIs and analysis context",
          "outputs": "Updated insights and documentation for changed files only"
        },
        {
          "name": "callLLM",
          "desc": "Makes API calls to configured LLM provider with rate limiting, retries, and error handling",
          "inputs": "System prompt, user prompt, optional schema for structured output",
          "outputs": "Parsed LLM response with requested analysis or documentation"
        },
        {
          "name": "generateFileSummary",
          "desc": "Creates AI-generated summary of a single file's purpose, functionality, and role",
          "inputs": "File path, content, and role in codebase",
          "outputs": "FileSummary with description, key functions, and relationships"
        },
        {
          "name": "generateModuleSummary",
          "desc": "Creates AI-generated summary of a module's purpose and file organization",
          "inputs": "Module name, list of files, and module type",
          "outputs": "ModuleSummary with module purpose and file descriptions"
        }
      ],
      "dependencies": [
        "vscode",
        "./fileDocumentation",
        "./analyzer",
        "./analysis/enhancedAnalyzer",
        "./llmSchemas",
        "./fileAccessHelper",
        "./logger",
        "./config/configurationManager",
        "./ai/providers/providerFactory",
        "./ai/llmResponseParser",
        "./ai/llmRateLimiter",
        "./ai/llmRetryHandler",
        "./domain/prompts/promptBuilder",
        "./domain/services/incrementalAnalysisService",
        "./domain/prompts/refactoringPromptBuilder",
        "./analysis/functionAnalyzer"
      ],
      "intent": "This file exists to bridge the gap between static code analysis and intelligent AI-powered insights. It solves the problem of understanding large codebases by using LLMs to generate human-readable documentation, identify architectural patterns, suggest improvements, and create test plans. It abstracts away the complexity of calling different LLM providers (OpenAI, Claude, local models) and handles rate limiting, retries, and response parsing so developers can get AI insights without managing API details.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides LLM-powered AI analysis services to generate intelligent insights, documentation, and code analysis by interfacing with OpenAI/Claude APIs.\",\n  \"userVisibleActions\": [\n    \"Generate intelligent insights about codebase purpose and architecture\",\n    \"Create comprehensive product documentation from code analysis\",\n    \"Analyze code quality and provide improvement suggestions\",\n    \"Generate unit test plans for functions\",\n    \"Get AI-powered refactoring suggestions for complex functions\",\n    \"Receive explanations of what the product does and why it was built\",\n    \"View AI-generated module summaries and relationships\",\n    \"See incremental analysis results as codebase changes\",\n    \"Get file-level and function-level documentation generated by AI\"\n  ],\n  \"developerVisibleActions\": [\n    \"Call LLM service to analyze codebase structure and purpose\",\n    \"Request AI-generated documentation for entire product\",\n    \"Trigger AI analysis of code quality and architecture\",\n    \"Generate test plans using AI understanding of functions\",\n    \"Request refactoring suggestions for complex code\",\n    \"Use incremental analysis to only analyze changed files\",\n    \"Configure LLM provider (OpenAI, Claude, or local models)\",\n    \"Set custom system prompts for AI analysis\",\n    \"Control token budgets and rate limiting for API calls\",\n    \"Handle retries and errors from LLM API responses\",\n    \"Parse structured AI responses into usable data structures\",\n    \"Access file summaries and module groupings from AI analysis\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzePurpose\",\n      \"desc\": \"Analyzes the codebase to determine product purpose, architecture rationale, and key features using AI\",\n      \"inputs\": \"AnalysisContext with file structure, imports, and entry points\",\n      \"outputs\": \"ProductPurposeAnalysis with product purpose, architecture, and design patterns\"\n    },\n    {\n      \"name\": \"generateEnhancedDocumentation\",\n      \"desc\": \"Generates comprehensive product documentation including purpose, features, architecture, and user scenarios using AI\",\n      \"inputs\": \"CodeAnalysis and AnalysisContext\",\n      \"outputs\": \"EnhancedProductDocumentation with full product overview and technical details\"\n    },\n    {\n      \"name\": \"generateLLMInsights\",\n      \"desc\": \"Generates intelligent insights about code quality, patterns, and improvement suggestions using AI\",\n      \"inputs\": \"CodeAnalysis with code metrics and structure\",\n      \"outputs\": \"LLM insights with code quality assessment and recommendations\"\n    },\n    {\n      \"name\": \"generateUnitTestPlan\",\n      \"desc\": \"Creates a comprehensive unit test plan for a specific function using AI analysis\",\n      \"inputs\": \"Function metadata, file content, and function name\",\n      \"outputs\": \"Unit test plan with test cases, setup, assertions, and edge cases\"\n    },\n    {\n      \"name\": \"generateRefactoringSuggestions\",\n      \"desc\": \"Provides AI-powered refactoring suggestions for complex or problematic functions\",\n      \"inputs\": \"Function code, metrics (complexity, length, nesting), and surrounding context\",\n      \"outputs\": \"Refactoring suggestions with specific improvements and code examples\"\n    },\n    {\n      \"name\": \"analyzeIncrementally\",\n      \"desc\": \"Performs incremental AI analysis only on files that have changed since last analysis\",\n      \"inputs\": \"Changed file URIs and analysis context\",\n      \"outputs\": \"Updated insights and documentation for changed files only\"\n    },\n    {\n      \"name\": \"callLLM\",\n      \"desc\": \"Makes API calls to configured LLM provider with rate limiting, retries, and error handling\",\n      \"inputs\": \"System prompt, user prompt, optional schema for structured output\",\n      \"outputs\": \"Parsed LLM response with requested analysis or documentation\"\n    },\n    {\n      \"name\": \"generateFileSummary\",\n      \"desc\": \"Creates AI-generated summary of a single file's purpose, functionality, and role\",\n      \"inputs\": \"File path, content, and role in codebase\",\n      \"outputs\": \"FileSummary with description, key functions, and relationships\"\n    },\n    {\n      \"name\": \"generateModuleSummary\",\n      \"desc\": \"Creates AI-generated summary of a module's purpose and file organization\",\n      \"inputs\": \"Module name, list of files, and module type\",\n      \"outputs\": \"ModuleSummary with module purpose and file descriptions\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"./fileDocumentation\",\n    \"./analyzer\",\n    \"./analysis/enhancedAnalyzer\",\n    \"./llmSchemas\",\n    \"./fileAccessHelper\",\n    \"./logger\",\n    \"./config/configurationManager\",\n    \"./ai/providers/providerFactory\",\n    \"./ai/llmResponseParser\",\n    \"./ai/llmRateLimiter\",\n    \"./ai/llmRetryHandler\",\n    \"./domain/prompts/promptBuilder\",\n    \"./domain/services/incrementalAnalysisService\",\n    \"./domain/prompts/refactoringPromptBuilder\",\n    \"./analysis/functionAnalyzer\"\n  ],\n  \"intent\": \"This file exists to bridge the gap between static code analysis and intelligent AI-powered insights. It solves the problem of understanding large codebases by using LLMs to generate human-readable documentation, identify architectural patterns, suggest improvements, and create test plans. It abstracts away the complexity of calling different LLM providers (OpenAI, Claude, local models) and handles rate limiting, retries, and response parsing so developers can get AI insights without managing API details.\"\n}\n```"
    },
    {
      "file": "src/logger.ts",
      "role": "Core Logic",
      "purpose": "Provides logging functionality that writes timestamped messages to a log file in the workspace's .shadow/logs directory",
      "userVisibleActions": [
        "Log files are automatically created in .shadow/logs/shadow-watch.log in the workspace root",
        "All logged events are timestamped with ISO format timestamps",
        "Log sections are visually separated with header lines for easier reading"
      ],
      "developerVisibleActions": [
        "Developers can log messages that appear in .shadow/logs/shadow-watch.log",
        "Developers can create section headers in the log file to organize different parts of execution",
        "Logging fails silently if the workspace is not available or errors occur",
        "The .shadow/logs directory is automatically created if it doesn't exist"
      ],
      "keyFunctions": [
        {
          "name": "log",
          "desc": "Writes a timestamped message to the log file",
          "inputs": "message (string) - the text to log",
          "outputs": "void - writes to file system"
        },
        {
          "name": "section",
          "desc": "Creates a formatted section header in the log file with surrounding equals signs",
          "inputs": "title (string) - the section header text",
          "outputs": "void - writes to file system"
        },
        {
          "name": "getLogPath",
          "desc": "Determines the file path where logs should be written",
          "inputs": "none",
          "outputs": "string | null - path to log file or null if no workspace"
        },
        {
          "name": "ensureDir",
          "desc": "Creates a directory if it doesn't already exist",
          "inputs": "dir (string) - directory path to create",
          "outputs": "void - modifies file system"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "vscode"
      ],
      "intent": "This file exists to provide a centralized, file-based logging system for the extension, allowing developers to track extension behavior and debug issues by writing timestamped logs to a consistent location in the workspace",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides logging functionality that writes timestamped messages to a log file in the workspace's .shadow/logs directory\",\n  \"userVisibleActions\": [\n    \"Log files are automatically created in .shadow/logs/shadow-watch.log in the workspace root\",\n    \"All logged events are timestamped with ISO format timestamps\",\n    \"Log sections are visually separated with header lines for easier reading\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developers can log messages that appear in .shadow/logs/shadow-watch.log\",\n    \"Developers can create section headers in the log file to organize different parts of execution\",\n    \"Logging fails silently if the workspace is not available or errors occur\",\n    \"The .shadow/logs directory is automatically created if it doesn't exist\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"log\",\n      \"desc\": \"Writes a timestamped message to the log file\",\n      \"inputs\": \"message (string) - the text to log\",\n      \"outputs\": \"void - writes to file system\"\n    },\n    {\n      \"name\": \"section\",\n      \"desc\": \"Creates a formatted section header in the log file with surrounding equals signs\",\n      \"inputs\": \"title (string) - the section header text\",\n      \"outputs\": \"void - writes to file system\"\n    },\n    {\n      \"name\": \"getLogPath\",\n      \"desc\": \"Determines the file path where logs should be written\",\n      \"inputs\": \"none\",\n      \"outputs\": \"string | null - path to log file or null if no workspace\"\n    },\n    {\n      \"name\": \"ensureDir\",\n      \"desc\": \"Creates a directory if it doesn't already exist\",\n      \"inputs\": \"dir (string) - directory path to create\",\n      \"outputs\": \"void - modifies file system\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"vscode\"\n  ],\n  \"intent\": \"This file exists to provide a centralized, file-based logging system for the extension, allowing developers to track extension behavior and debug issues by writing timestamped logs to a consistent location in the workspace\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [
    {
      "command": "shadow-watch.analyzeWorkspace",
      "description": "Trigger full codebase analysis to extract structure, dependencies, functions, and generate insights"
    },
    {
      "command": "shadow-watch.analyzeCurrentFile",
      "description": "Analyze only the currently open file for structure and quality issues"
    },
    {
      "command": "shadow-watch.formatForLLM",
      "description": "Export analysis results in LLM-optimized format (Cursor, ChatGPT, or generic)"
    },
    {
      "command": "shadow-watch.exportToMarkdown",
      "description": "Export analysis results as a Markdown file"
    },
    {
      "command": "shadow-watch.exportToJSON",
      "description": "Export analysis results as a structured JSON file"
    },
    {
      "command": "shadow-watch.clearCache",
      "description": "Clear cached analysis data to force fresh analysis"
    },
    {
      "command": "shadow-watch.generateProductDocumentation",
      "description": "Generate AI-powered product-level documentation including architecture and purpose"
    },
    {
      "command": "shadow-watch.generateArchitectureDocumentation",
      "description": "Generate AI-powered architecture documentation with diagrams and relationships"
    },
    {
      "command": "shadow-watch.generateUnitTests",
      "description": "Generate AI-powered unit test plans for functions"
    },
    {
      "command": "shadow-watch.refreshInsights",
      "description": "Refresh the insights tree view to update displayed analysis results"
    }
  ],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-20T00:59:52.550Z"
  }
}