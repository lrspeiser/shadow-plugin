{
  "module": "src/domain/services",
  "moduleType": "other",
  "capabilities": [
    "Automatic file system monitoring and change detection across the workspace",
    "Iterative code analysis using LLM with multi-round information gathering",
    "Automatic test framework detection and configuration validation",
    "Real-time response to file creation, modification, and deletion events",
    "Progressive analysis with automatic file content and search result retrieval",
    "Test dependency and setup requirement identification"
  ],
  "summary": "The services module provides core automation and monitoring capabilities that power the extension's intelligent features. It includes a file watching service that continuously monitors the workspace for file system changes, enabling real-time responses to file creation, modification, deletion, and save events based on configurable file patterns. This allows the extension to stay synchronized with workspace changes without manual intervention.\n\nThe module features an incremental analysis service that orchestrates multi-round LLM conversations for deep code analysis. This service automatically gathers information across multiple iterations, retrieving file contents and executing searches based on previous results, continuing until analysis criteria are met or iteration limits are reached. This enables comprehensive understanding of complex codebases through progressive refinement.\n\nAdditionally, the module includes a test configuration service that automatically detects which testing framework is in use (Jest, Mocha, Vitest, or Pytest) and validates the test environment setup. It identifies missing dependencies, reports configuration status, and provides actionable setup requirements, ensuring generated tests can run successfully without manual configuration troubleshooting.",
  "files": [
    {
      "file": "src/domain/services/fileWatcherService.ts",
      "role": "Core Logic",
      "purpose": "Provides a centralized service for monitoring file system changes and document saves in the workspace, consolidating file watching functionality across the extension.",
      "userVisibleActions": [
        "Automatically detects when files are created in the workspace",
        "Automatically detects when files are modified or saved",
        "Automatically detects when files are deleted from the workspace",
        "Responds to file changes based on specific file patterns (e.g., *.md, *.json)",
        "Triggers updates when documents are saved in the editor"
      ],
      "developerVisibleActions": [
        "Register handlers to respond to file creation events",
        "Register handlers to respond to file modification events",
        "Register handlers to respond to file deletion events",
        "Register handlers to respond to document save events",
        "Filter file changes using ignore patterns (e.g., exclude node_modules)",
        "Watch multiple file patterns simultaneously with different handlers",
        "Dispose of watchers to stop monitoring files",
        "Configure which types of changes to monitor (create, change, delete)",
        "Receive structured file change events with URI and change type"
      ],
      "keyFunctions": [
        {
          "name": "watch",
          "desc": "Monitors file system changes matching a specific pattern and triggers callbacks",
          "inputs": "id (string), pattern (file glob or relative pattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete flags)",
          "outputs": "Disposable object to stop watching"
        },
        {
          "name": "onDocumentSave",
          "desc": "Registers a callback to be triggered whenever a document is saved in the editor",
          "inputs": "handler (callback function receiving TextDocument)",
          "outputs": "Disposable object to unregister the handler"
        },
        {
          "name": "stopWatching",
          "desc": "Stops monitoring a specific file pattern and removes associated handlers",
          "inputs": "id (string)",
          "outputs": "void"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all active watchers and handlers when service is no longer needed",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getPatternKey",
          "desc": "Generates a unique key for a file pattern to prevent duplicate watchers",
          "inputs": "pattern (string or RelativePattern)",
          "outputs": "string key"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "This file exists to eliminate duplication of file watching code across multiple components (fileWatcher.ts, productNavigator.ts, insightsViewer.ts) by providing a single, reusable service that manages file system monitoring. It solves the problem of multiple components independently creating watchers, which leads to code duplication, inconsistent behavior, and resource waste. By centralizing this functionality, components can easily respond to file changes without managing watcher lifecycles themselves.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a centralized service for monitoring file system changes and document saves in the workspace, consolidating file watching functionality across the extension.\",\n  \"userVisibleActions\": [\n    \"Automatically detects when files are created in the workspace\",\n    \"Automatically detects when files are modified or saved\",\n    \"Automatically detects when files are deleted from the workspace\",\n    \"Responds to file changes based on specific file patterns (e.g., *.md, *.json)\",\n    \"Triggers updates when documents are saved in the editor\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register handlers to respond to file creation events\",\n    \"Register handlers to respond to file modification events\",\n    \"Register handlers to respond to file deletion events\",\n    \"Register handlers to respond to document save events\",\n    \"Filter file changes using ignore patterns (e.g., exclude node_modules)\",\n    \"Watch multiple file patterns simultaneously with different handlers\",\n    \"Dispose of watchers to stop monitoring files\",\n    \"Configure which types of changes to monitor (create, change, delete)\",\n    \"Receive structured file change events with URI and change type\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"watch\",\n      \"desc\": \"Monitors file system changes matching a specific pattern and triggers callbacks\",\n      \"inputs\": \"id (string), pattern (file glob or relative pattern), handler (callback function), options (ignorePatterns, watchCreate, watchChange, watchDelete flags)\",\n      \"outputs\": \"Disposable object to stop watching\"\n    },\n    {\n      \"name\": \"onDocumentSave\",\n      \"desc\": \"Registers a callback to be triggered whenever a document is saved in the editor\",\n      \"inputs\": \"handler (callback function receiving TextDocument)\",\n      \"outputs\": \"Disposable object to unregister the handler\"\n    },\n    {\n      \"name\": \"stopWatching\",\n      \"desc\": \"Stops monitoring a specific file pattern and removes associated handlers\",\n      \"inputs\": \"id (string)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all active watchers and handlers when service is no longer needed\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getPatternKey\",\n      \"desc\": \"Generates a unique key for a file pattern to prevent duplicate watchers\",\n      \"inputs\": \"pattern (string or RelativePattern)\",\n      \"outputs\": \"string key\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"This file exists to eliminate duplication of file watching code across multiple components (fileWatcher.ts, productNavigator.ts, insightsViewer.ts) by providing a single, reusable service that manages file system monitoring. It solves the problem of multiple components independently creating watchers, which leads to code duplication, inconsistent behavior, and resource waste. By centralizing this functionality, components can easily respond to file changes without managing watcher lifecycles themselves.\"\n}\n```"
    },
    {
      "file": "src/domain/services/incrementalAnalysisService.ts",
      "role": "Core Logic",
      "purpose": "Manages iterative LLM analysis by processing file and grep requests across multiple conversation rounds until analysis is complete.",
      "userVisibleActions": [
        "Analysis proceeds in multiple rounds, with each round gathering more information based on previous results",
        "File contents and search results are retrieved automatically during analysis",
        "Progress through iterations is tracked and communicated",
        "Analysis stops when completion criteria are met or maximum iterations reached"
      ],
      "developerVisibleActions": [
        "Service processes LLM requests for file reads and grep searches iteratively",
        "Callbacks notify when iterations start and complete",
        "Returns structured results including iteration count, requests made, and whether to continue",
        "Limits requests to 5 per iteration to prevent excessive processing",
        "Formats file and search results into conversation messages",
        "Provides async iterator pattern for testable iteration control"
      ],
      "keyFunctions": [
        {
          "name": "processRequests",
          "desc": "Processes file read and grep search requests from LLM, returning formatted results",
          "inputs": "requests (LLMRequest[]), currentResult (any), messages (conversation array)",
          "outputs": "ProcessRequestsResult with additionalInfo string and updated messages array"
        },
        {
          "name": "IterationResult",
          "desc": "Structure representing outcome of a single analysis iteration",
          "inputs": "N/A (interface)",
          "outputs": "Contains result, iteration number, max iterations, requests made, and continuation flag"
        },
        {
          "name": "IterationCallbacks",
          "desc": "Optional callbacks to monitor iteration lifecycle",
          "inputs": "N/A (interface)",
          "outputs": "Callbacks for iteration start and completion events"
        }
      ],
      "dependencies": [
        "fileAccessHelper",
        "LLMRequest"
      ],
      "intent": "Eliminates code duplication by extracting iterative LLM analysis logic into a dedicated service that handles multi-round conversations where the LLM requests additional files or searches to complete its analysis, making the pattern testable and reusable across different analysis scenarios.",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages iterative LLM analysis by processing file and grep requests across multiple conversation rounds until analysis is complete.\",\n  \"userVisibleActions\": [\n    \"Analysis proceeds in multiple rounds, with each round gathering more information based on previous results\",\n    \"File contents and search results are retrieved automatically during analysis\",\n    \"Progress through iterations is tracked and communicated\",\n    \"Analysis stops when completion criteria are met or maximum iterations reached\"\n  ],\n  \"developerVisibleActions\": [\n    \"Service processes LLM requests for file reads and grep searches iteratively\",\n    \"Callbacks notify when iterations start and complete\",\n    \"Returns structured results including iteration count, requests made, and whether to continue\",\n    \"Limits requests to 5 per iteration to prevent excessive processing\",\n    \"Formats file and search results into conversation messages\",\n    \"Provides async iterator pattern for testable iteration control\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Processes file read and grep search requests from LLM, returning formatted results\",\n      \"inputs\": \"requests (LLMRequest[]), currentResult (any), messages (conversation array)\",\n      \"outputs\": \"ProcessRequestsResult with additionalInfo string and updated messages array\"\n    },\n    {\n      \"name\": \"IterationResult\",\n      \"desc\": \"Structure representing outcome of a single analysis iteration\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Contains result, iteration number, max iterations, requests made, and continuation flag\"\n    },\n    {\n      \"name\": \"IterationCallbacks\",\n      \"desc\": \"Optional callbacks to monitor iteration lifecycle\",\n      \"inputs\": \"N/A (interface)\",\n      \"outputs\": \"Callbacks for iteration start and completion events\"\n    }\n  ],\n  \"dependencies\": [\n    \"fileAccessHelper\",\n    \"LLMRequest\"\n  ],\n  \"intent\": \"Eliminates code duplication by extracting iterative LLM analysis logic into a dedicated service that handles multi-round conversations where the LLM requests additional files or searches to complete its analysis, making the pattern testable and reusable across different analysis scenarios.\"\n}\n```"
    },
    {
      "file": "src/domain/services/testConfigurationService.ts",
      "role": "Core Logic",
      "purpose": "Automatically detects test framework configuration in the workspace and determines if setup is required for generated tests to work",
      "userVisibleActions": [
        "Automatically detects which test framework is being used in the project (Jest, Mocha, Vitest, or Pytest)",
        "Reports whether test configuration is properly set up and ready to use",
        "Identifies missing test dependencies that need to be installed",
        "Provides list of setup actions required to make tests work",
        "Detects if TypeScript support for testing is configured"
      ],
      "developerVisibleActions": [
        "Reads package.json to detect test scripts and installed dependencies",
        "Scans for test framework configuration files (jest.config.js, .mocharc.json, vitest.config.ts, pytest.ini, etc.)",
        "Checks if TypeScript test dependencies are installed when TypeScript files exist",
        "Returns structured status report about test framework and configuration state",
        "Identifies specific missing dependencies needed for the detected framework",
        "Generates list of required setup actions to complete test configuration"
      ],
      "keyFunctions": [
        {
          "name": "detectTestConfiguration",
          "desc": "Analyzes workspace to detect test framework and configuration status",
          "inputs": "workspaceRoot: string (path to project root)",
          "outputs": "TestConfigStatus object with framework type, configuration status, missing dependencies, and required setup actions"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "SWLogger"
      ],
      "intent": "Eliminates manual test configuration by automatically detecting the test framework in use and identifying any missing setup, ensuring generated tests will work without user intervention or configuration errors",
      "rawContent": "```json\n{\n  \"purpose\": \"Automatically detects test framework configuration in the workspace and determines if setup is required for generated tests to work\",\n  \"userVisibleActions\": [\n    \"Automatically detects which test framework is being used in the project (Jest, Mocha, Vitest, or Pytest)\",\n    \"Reports whether test configuration is properly set up and ready to use\",\n    \"Identifies missing test dependencies that need to be installed\",\n    \"Provides list of setup actions required to make tests work\",\n    \"Detects if TypeScript support for testing is configured\"\n  ],\n  \"developerVisibleActions\": [\n    \"Reads package.json to detect test scripts and installed dependencies\",\n    \"Scans for test framework configuration files (jest.config.js, .mocharc.json, vitest.config.ts, pytest.ini, etc.)\",\n    \"Checks if TypeScript test dependencies are installed when TypeScript files exist\",\n    \"Returns structured status report about test framework and configuration state\",\n    \"Identifies specific missing dependencies needed for the detected framework\",\n    \"Generates list of required setup actions to complete test configuration\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"detectTestConfiguration\",\n      \"desc\": \"Analyzes workspace to detect test framework and configuration status\",\n      \"inputs\": \"workspaceRoot: string (path to project root)\",\n      \"outputs\": \"TestConfigStatus object with framework type, configuration status, missing dependencies, and required setup actions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"SWLogger\"\n  ],\n  \"intent\": \"Eliminates manual test configuration by automatically detecting the test framework in use and identifying any missing setup, ensuring generated tests will work without user intervention or configuration errors\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-20T01:01:05.700Z"
  }
}