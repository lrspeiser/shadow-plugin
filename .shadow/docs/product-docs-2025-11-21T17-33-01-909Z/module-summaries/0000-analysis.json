{
  "module": "src/analysis",
  "moduleType": "other",
  "capabilities": [
    "Performs deep static code analysis by parsing Abstract Syntax Trees (AST) to understand code structure and behavior",
    "Extracts comprehensive function-level metadata including signatures, parameters, return types, and dependencies",
    "Analyzes code complexity metrics and identifies behavioral patterns in functions",
    "Maps relationships between functions to show what each function depends on and what depends on it",
    "Identifies conditional logic paths and provides branch coverage information",
    "Detects test-to-source code mappings to understand test coverage relationships",
    "Highlights functions in large files that may benefit from refactoring",
    "Provides insights into how functions interact with application state and external dependencies"
  ],
  "summary": "The analysis module provides comprehensive static code analysis capabilities that help users understand their codebase at a deep structural level. By parsing Abstract Syntax Trees (AST), it extracts detailed metadata about functions, their dependencies, complexity patterns, and behavioral characteristics. Users can leverage this module to gain visibility into how their code is organized, identify potential refactoring opportunities, and understand the relationships between different parts of their codebase.\n\nThe module serves two primary workflows: enhanced analysis for understanding code behavior and complexity, and function-level analysis for refactoring support. Enhanced analysis examines conditional logic branches, dependency patterns, and state interactions to provide insights into code quality and test coverage. Function analysis focuses on extracting detailed information about individual functions within large files, showing their signatures, what they depend on, and what other code depends on them. Together, these capabilities enable users to make informed decisions about code maintenance, refactoring, and quality improvements.\n\nThis module is particularly valuable for developers working with large codebases who need to understand complex function interactions, identify tightly coupled components, or plan refactoring efforts. The analysis results can inform decisions about code splitting, test coverage improvements, and architectural changes by providing clear visibility into the existing code structure and dependencies.",
  "files": [
    {
      "file": "src/analysis/enhancedAnalyzer.ts",
      "role": "Core Logic",
      "purpose": "Performs deep code analysis by parsing Abstract Syntax Trees (AST) to extract detailed metadata about functions, branches, dependencies, and behavioral patterns.",
      "userVisibleActions": [
        "Receives detailed analysis of code complexity and behavioral hints",
        "Gets insights into how functions interact with state and dependencies",
        "Views branch coverage information for conditional logic paths",
        "Sees identified test mappings between test files and source code"
      ],
      "developerVisibleActions": [
        "Analyzes TypeScript/JavaScript files using AST parsing to extract function metadata",
        "Detects branches (if/else, switch, ternary) and tracks conditional logic complexity",
        "Profiles function dependencies by tracking imports, function calls, and external references",
        "Identifies state mutations and side effects in function bodies",
        "Generates behavioral hints about function characteristics (pure, async, error-prone)",
        "Maps test files to source code functions for coverage analysis",
        "Falls back to regex-based analysis for non-TypeScript languages",
        "Extracts function content from source files based on line ranges"
      ],
      "keyFunctions": [
        {
          "name": "analyzeFileMetadata",
          "desc": "Analyzes a file and extracts enhanced metadata for all functions",
          "inputs": "filePath: string, content: string, language: string, functions: FunctionInfo[]",
          "outputs": "Map<string, FunctionMetadata>"
        },
        {
          "name": "analyzeTypeScriptFunction",
          "desc": "Performs AST-based analysis on TypeScript/JavaScript functions",
          "inputs": "filePath: string, content: string, func: FunctionInfo, functionContent: string",
          "outputs": "FunctionMetadata"
        },
        {
          "name": "analyzeFunctionWithRegex",
          "desc": "Fallback analysis using regex patterns for non-TypeScript languages",
          "inputs": "filePath: string, func: FunctionInfo, functionContent: string, language: string",
          "outputs": "FunctionMetadata"
        },
        {
          "name": "extractFunctionContent",
          "desc": "Extracts the text content of a function from a file",
          "inputs": "content: string, startLine: number, endLine: number",
          "outputs": "string"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "typescript",
        "../analyzer"
      ],
      "intent": "This file exists to provide advanced static code analysis beyond basic syntax parsing. It solves the problem of understanding code behavior, complexity, and relationships by using AST parsing to detect branches, dependencies, state mutations, and behavioral patterns. This enables intelligent test generation, code quality assessment, and automated documentation.",
      "rawContent": "```json\n{\n  \"purpose\": \"Performs deep code analysis by parsing Abstract Syntax Trees (AST) to extract detailed metadata about functions, branches, dependencies, and behavioral patterns.\",\n  \"userVisibleActions\": [\n    \"Receives detailed analysis of code complexity and behavioral hints\",\n    \"Gets insights into how functions interact with state and dependencies\",\n    \"Views branch coverage information for conditional logic paths\",\n    \"Sees identified test mappings between test files and source code\"\n  ],\n  \"developerVisibleActions\": [\n    \"Analyzes TypeScript/JavaScript files using AST parsing to extract function metadata\",\n    \"Detects branches (if/else, switch, ternary) and tracks conditional logic complexity\",\n    \"Profiles function dependencies by tracking imports, function calls, and external references\",\n    \"Identifies state mutations and side effects in function bodies\",\n    \"Generates behavioral hints about function characteristics (pure, async, error-prone)\",\n    \"Maps test files to source code functions for coverage analysis\",\n    \"Falls back to regex-based analysis for non-TypeScript languages\",\n    \"Extracts function content from source files based on line ranges\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeFileMetadata\",\n      \"desc\": \"Analyzes a file and extracts enhanced metadata for all functions\",\n      \"inputs\": \"filePath: string, content: string, language: string, functions: FunctionInfo[]\",\n      \"outputs\": \"Map<string, FunctionMetadata>\"\n    },\n    {\n      \"name\": \"analyzeTypeScriptFunction\",\n      \"desc\": \"Performs AST-based analysis on TypeScript/JavaScript functions\",\n      \"inputs\": \"filePath: string, content: string, func: FunctionInfo, functionContent: string\",\n      \"outputs\": \"FunctionMetadata\"\n    },\n    {\n      \"name\": \"analyzeFunctionWithRegex\",\n      \"desc\": \"Fallback analysis using regex patterns for non-TypeScript languages\",\n      \"inputs\": \"filePath: string, func: FunctionInfo, functionContent: string, language: string\",\n      \"outputs\": \"FunctionMetadata\"\n    },\n    {\n      \"name\": \"extractFunctionContent\",\n      \"desc\": \"Extracts the text content of a function from a file\",\n      \"inputs\": \"content: string, startLine: number, endLine: number\",\n      \"outputs\": \"string\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"typescript\",\n    \"../analyzer\"\n  ],\n  \"intent\": \"This file exists to provide advanced static code analysis beyond basic syntax parsing. It solves the problem of understanding code behavior, complexity, and relationships by using AST parsing to detect branches, dependencies, state mutations, and behavioral patterns. This enables intelligent test generation, code quality assessment, and automated documentation.\"\n}\n```"
    },
    {
      "file": "src/analysis/functionAnalyzer.ts",
      "role": "Core Logic",
      "purpose": "Extracts detailed function information from large code files to support refactoring analysis and reporting.",
      "userVisibleActions": [
        "Identifies functions in large files that may need refactoring",
        "Provides detailed function information including signatures, dependencies, and responsibilities",
        "Highlights which functions are called by other parts of the codebase (dependents)",
        "Shows what other functions or modules each function depends on"
      ],
      "developerVisibleActions": [
        "Developer runs analysis on a codebase to identify large files",
        "System automatically analyzes all functions in files exceeding a configurable line threshold (default 500 lines)",
        "Developer receives structured function analysis data for each function in large files",
        "System extracts function signatures, metadata, dependencies, and dependent relationships",
        "Developer can use this analysis to inform refactoring decisions and generate refactoring reports",
        "Analysis integrates with existing code analysis infrastructure to build comprehensive function profiles"
      ],
      "keyFunctions": [
        {
          "name": "analyzeFunctions",
          "desc": "Analyzes all functions in large files and returns detailed function analysis data",
          "inputs": "CodeAnalysis object, optional line threshold for large files (default 500)",
          "outputs": "Array of FunctionAnalysis objects containing detailed function information"
        },
        {
          "name": "analyzeFunction",
          "desc": "Performs detailed analysis on a single function including extracting signature, dependencies, and dependent relationships",
          "inputs": "File path, function information object, code analysis object",
          "outputs": "FunctionAnalysis object or null if analysis fails"
        },
        {
          "name": "resolveFilePath",
          "desc": "Resolves relative file paths to absolute paths for file system access",
          "inputs": "Relative file path, code analysis object",
          "outputs": "Absolute file path string"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "typescript",
        "../analyzer",
        "../domain/prompts/refactoringPromptBuilder"
      ],
      "intent": "This file exists to provide deep analysis of functions within large files to support automated refactoring suggestions. It solves the problem of identifying which functions in oversized files should be refactored by extracting their signatures, understanding their dependencies, and mapping their usage patterns across the codebase. This enables developers to make informed decisions about code splitting and module organization.",
      "rawContent": "```json\n{\n  \"purpose\": \"Extracts detailed function information from large code files to support refactoring analysis and reporting.\",\n  \"userVisibleActions\": [\n    \"Identifies functions in large files that may need refactoring\",\n    \"Provides detailed function information including signatures, dependencies, and responsibilities\",\n    \"Highlights which functions are called by other parts of the codebase (dependents)\",\n    \"Shows what other functions or modules each function depends on\"\n  ],\n  \"developerVisibleActions\": [\n    \"Developer runs analysis on a codebase to identify large files\",\n    \"System automatically analyzes all functions in files exceeding a configurable line threshold (default 500 lines)\",\n    \"Developer receives structured function analysis data for each function in large files\",\n    \"System extracts function signatures, metadata, dependencies, and dependent relationships\",\n    \"Developer can use this analysis to inform refactoring decisions and generate refactoring reports\",\n    \"Analysis integrates with existing code analysis infrastructure to build comprehensive function profiles\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"analyzeFunctions\",\n      \"desc\": \"Analyzes all functions in large files and returns detailed function analysis data\",\n      \"inputs\": \"CodeAnalysis object, optional line threshold for large files (default 500)\",\n      \"outputs\": \"Array of FunctionAnalysis objects containing detailed function information\"\n    },\n    {\n      \"name\": \"analyzeFunction\",\n      \"desc\": \"Performs detailed analysis on a single function including extracting signature, dependencies, and dependent relationships\",\n      \"inputs\": \"File path, function information object, code analysis object\",\n      \"outputs\": \"FunctionAnalysis object or null if analysis fails\"\n    },\n    {\n      \"name\": \"resolveFilePath\",\n      \"desc\": \"Resolves relative file paths to absolute paths for file system access\",\n      \"inputs\": \"Relative file path, code analysis object\",\n      \"outputs\": \"Absolute file path string\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"typescript\",\n    \"../analyzer\",\n    \"../domain/prompts/refactoringPromptBuilder\"\n  ],\n  \"intent\": \"This file exists to provide deep analysis of functions within large files to support automated refactoring suggestions. It solves the problem of identifying which functions in oversized files should be refactored by extracting their signatures, understanding their dependencies, and mapping their usage patterns across the codebase. This enables developers to make informed decisions about code splitting and module organization.\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-21T17:48:39.103Z"
  }
}