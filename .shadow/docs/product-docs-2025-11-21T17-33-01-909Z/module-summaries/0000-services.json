{
  "module": "src/domain/services",
  "moduleType": "other",
  "capabilities": [
    "Automatic file system monitoring and change detection across the extension",
    "Iterative AI-powered code analysis that automatically gathers required context",
    "Intelligent test framework detection and configuration validation",
    "Real-time synchronization of views and data when files are modified",
    "Automatic detection of missing test dependencies and configuration issues",
    "Progressive analysis that reads additional files and searches code as needed"
  ],
  "summary": "The services module provides core automated workflows that enhance the user experience by eliminating manual configuration and monitoring tasks. It includes a file watcher service that automatically detects changes to files in the workspace, ensuring that all views and analysis results stay synchronized with the latest file system state without requiring manual refreshes. The incremental analysis service powers intelligent code understanding by iteratively requesting additional context, reading relevant files, and performing grep searches until sufficient information is gathered for analysis tasks.\n\nThe test configuration service automatically detects which testing framework is being used (Jest, Mocha, Vitest, or Pytest) and validates that the environment is properly configured to run generated tests. It identifies missing dependencies, checks for required configuration files, and provides actionable recommendations to fix any setup issues. Together, these services create a seamless experience where file changes are automatically tracked, code analysis progressively deepens its understanding, and test generation works reliably without manual environment setup.\n\nThese services work behind the scenes to support user-facing features like test generation, code analysis, and file-based insights. Users benefit from automatic updates when files change, intelligent analysis that knows when to gather more information, and test generation that adapts to their specific testing setup without requiring configuration knowledge.",
  "files": [
    {
      "file": "src/domain/services/fileWatcherService.ts",
      "role": "Core Logic",
      "purpose": "Provides a centralized service for monitoring file system changes and document saves across the extension, eliminating duplication of file watching logic.",
      "userVisibleActions": [
        "Files are automatically monitored for changes when opened or created",
        "Updates occur automatically when files are saved, modified, or deleted",
        "File system changes trigger automatic refreshes of views and data",
        "Changes to specific file patterns (like product files or insights) are detected in real-time"
      ],
      "developerVisibleActions": [
        "Register file watchers for specific patterns (e.g., '**/*.md', '**/*.json')",
        "Subscribe to file creation, modification, and deletion events",
        "Register handlers for document save events",
        "Ignore specific file patterns when watching (e.g., '.git/**', 'node_modules/**')",
        "Clean up watchers automatically when handlers are disposed",
        "Receive structured FileChangeEvent objects with URI and event type",
        "Watch multiple patterns with separate handlers for each",
        "Debounce file change events to prevent excessive handler calls"
      ],
      "keyFunctions": [
        {
          "name": "watch",
          "desc": "Registers a handler to be called when files matching a pattern are created, changed, or deleted",
          "inputs": "id (string), pattern (glob or RelativePattern), handler (callback function), options (ignore patterns, event types to watch)",
          "outputs": "Disposable object to stop watching"
        },
        {
          "name": "onDidSaveTextDocument",
          "desc": "Registers a handler to be called when any text document is saved",
          "inputs": "handler (callback function receiving TextDocument)",
          "outputs": "Disposable object to unregister the handler"
        },
        {
          "name": "unwatch",
          "desc": "Removes a specific handler from watching file changes",
          "inputs": "id (string), pattern (glob or RelativePattern)",
          "outputs": "void"
        },
        {
          "name": "dispose",
          "desc": "Cleans up all watchers and handlers when the service is no longer needed",
          "inputs": "none",
          "outputs": "void"
        },
        {
          "name": "getPatternKey",
          "desc": "Generates a unique key for a file pattern to avoid duplicate watchers",
          "inputs": "pattern (string or RelativePattern)",
          "outputs": "string key"
        }
      ],
      "dependencies": [
        "vscode",
        "path",
        "fs"
      ],
      "intent": "This file exists to consolidate file watching functionality that was previously duplicated across multiple components (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It solves the problem of maintaining consistent file monitoring behavior and prevents resource waste from multiple watchers monitoring the same files. It provides a single, reliable service that other components can use to react to file system changes without implementing their own watching logic.",
      "rawContent": "```json\n{\n  \"purpose\": \"Provides a centralized service for monitoring file system changes and document saves across the extension, eliminating duplication of file watching logic.\",\n  \"userVisibleActions\": [\n    \"Files are automatically monitored for changes when opened or created\",\n    \"Updates occur automatically when files are saved, modified, or deleted\",\n    \"File system changes trigger automatic refreshes of views and data\",\n    \"Changes to specific file patterns (like product files or insights) are detected in real-time\"\n  ],\n  \"developerVisibleActions\": [\n    \"Register file watchers for specific patterns (e.g., '**/*.md', '**/*.json')\",\n    \"Subscribe to file creation, modification, and deletion events\",\n    \"Register handlers for document save events\",\n    \"Ignore specific file patterns when watching (e.g., '.git/**', 'node_modules/**')\",\n    \"Clean up watchers automatically when handlers are disposed\",\n    \"Receive structured FileChangeEvent objects with URI and event type\",\n    \"Watch multiple patterns with separate handlers for each\",\n    \"Debounce file change events to prevent excessive handler calls\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"watch\",\n      \"desc\": \"Registers a handler to be called when files matching a pattern are created, changed, or deleted\",\n      \"inputs\": \"id (string), pattern (glob or RelativePattern), handler (callback function), options (ignore patterns, event types to watch)\",\n      \"outputs\": \"Disposable object to stop watching\"\n    },\n    {\n      \"name\": \"onDidSaveTextDocument\",\n      \"desc\": \"Registers a handler to be called when any text document is saved\",\n      \"inputs\": \"handler (callback function receiving TextDocument)\",\n      \"outputs\": \"Disposable object to unregister the handler\"\n    },\n    {\n      \"name\": \"unwatch\",\n      \"desc\": \"Removes a specific handler from watching file changes\",\n      \"inputs\": \"id (string), pattern (glob or RelativePattern)\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"dispose\",\n      \"desc\": \"Cleans up all watchers and handlers when the service is no longer needed\",\n      \"inputs\": \"none\",\n      \"outputs\": \"void\"\n    },\n    {\n      \"name\": \"getPatternKey\",\n      \"desc\": \"Generates a unique key for a file pattern to avoid duplicate watchers\",\n      \"inputs\": \"pattern (string or RelativePattern)\",\n      \"outputs\": \"string key\"\n    }\n  ],\n  \"dependencies\": [\n    \"vscode\",\n    \"path\",\n    \"fs\"\n  ],\n  \"intent\": \"This file exists to consolidate file watching functionality that was previously duplicated across multiple components (fileWatcher.ts, productNavigator.ts, insightsViewer.ts). It solves the problem of maintaining consistent file monitoring behavior and prevents resource waste from multiple watchers monitoring the same files. It provides a single, reliable service that other components can use to react to file system changes without implementing their own watching logic.\"\n}\n```"
    },
    {
      "file": "src/domain/services/incrementalAnalysisService.ts",
      "role": "Core Logic",
      "purpose": "Manages iterative LLM analysis by processing file read and grep search requests across multiple analysis iterations until completion or max iterations reached",
      "userVisibleActions": [
        "System performs multiple analysis passes to gather required information",
        "Additional files are read automatically when analysis needs more context",
        "Grep searches execute to find code patterns requested during analysis",
        "Analysis stops after maximum iterations or when no more information needed",
        "Progress shown as iteration count advances through analysis process"
      ],
      "developerVisibleActions": [
        "Configure maximum number of analysis iterations allowed",
        "Provide callbacks to track iteration start and completion events",
        "Receive structured results containing analysis outcome, iteration count, and all file/grep requests made",
        "Access conversation history with assistant and user messages accumulated across iterations",
        "Handle file read and grep search requests automatically limited to 5 per iteration",
        "Use async iterator pattern for incremental analysis instead of while loops"
      ],
      "keyFunctions": [
        {
          "name": "processRequests",
          "desc": "Processes LLM-requested file reads and grep searches, formatting results for next iteration",
          "inputs": "requests: LLMRequest[], currentResult: any, messages: conversation history array",
          "outputs": "ProcessRequestsResult with additionalInfo string and updated messages array"
        },
        {
          "name": "Constructor",
          "desc": "Initializes service with file access helper for reading files and running searches",
          "inputs": "fileAccessHelper: FileAccessHelper",
          "outputs": "IncrementalAnalysisService instance"
        }
      ],
      "dependencies": [
        "../../fileAccessHelper (FileAccessHelper, LLMRequest types)"
      ],
      "intent": "Eliminates code duplication from llmService.ts by extracting iterative analysis logic into a reusable, testable service that handles the common pattern of: analyze → request files/searches → gather info → re-analyze → repeat until done",
      "rawContent": "```json\n{\n  \"purpose\": \"Manages iterative LLM analysis by processing file read and grep search requests across multiple analysis iterations until completion or max iterations reached\",\n  \"userVisibleActions\": [\n    \"System performs multiple analysis passes to gather required information\",\n    \"Additional files are read automatically when analysis needs more context\",\n    \"Grep searches execute to find code patterns requested during analysis\",\n    \"Analysis stops after maximum iterations or when no more information needed\",\n    \"Progress shown as iteration count advances through analysis process\"\n  ],\n  \"developerVisibleActions\": [\n    \"Configure maximum number of analysis iterations allowed\",\n    \"Provide callbacks to track iteration start and completion events\",\n    \"Receive structured results containing analysis outcome, iteration count, and all file/grep requests made\",\n    \"Access conversation history with assistant and user messages accumulated across iterations\",\n    \"Handle file read and grep search requests automatically limited to 5 per iteration\",\n    \"Use async iterator pattern for incremental analysis instead of while loops\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"processRequests\",\n      \"desc\": \"Processes LLM-requested file reads and grep searches, formatting results for next iteration\",\n      \"inputs\": \"requests: LLMRequest[], currentResult: any, messages: conversation history array\",\n      \"outputs\": \"ProcessRequestsResult with additionalInfo string and updated messages array\"\n    },\n    {\n      \"name\": \"Constructor\",\n      \"desc\": \"Initializes service with file access helper for reading files and running searches\",\n      \"inputs\": \"fileAccessHelper: FileAccessHelper\",\n      \"outputs\": \"IncrementalAnalysisService instance\"\n    }\n  ],\n  \"dependencies\": [\n    \"../../fileAccessHelper (FileAccessHelper, LLMRequest types)\"\n  ],\n  \"intent\": \"Eliminates code duplication from llmService.ts by extracting iterative analysis logic into a reusable, testable service that handles the common pattern of: analyze → request files/searches → gather info → re-analyze → repeat until done\"\n}\n```"
    },
    {
      "file": "src/domain/services/testConfigurationService.ts",
      "role": "Core Logic",
      "purpose": "Automatically detects and configures test framework settings to ensure generated tests work without manual user setup",
      "userVisibleActions": [
        "Automatically detects which test framework (Jest, Mocha, Vitest, Pytest) is being used in the project",
        "Identifies missing test dependencies and provides setup recommendations",
        "Validates that test configuration files exist and are properly configured",
        "Reports whether the test environment is ready to run generated tests",
        "Suggests specific setup actions needed to fix configuration issues"
      ],
      "developerVisibleActions": [
        "Scans workspace root for package.json to identify test framework from scripts and dependencies",
        "Checks for framework-specific configuration files (jest.config.js, .mocharc, vitest.config.ts, pytest.ini)",
        "Detects TypeScript setup and verifies TypeScript-specific test dependencies (ts-jest, @jest/globals)",
        "Analyzes installed dependencies versus required dependencies for the detected framework",
        "Returns structured status report with framework type, configuration state, and required actions",
        "Provides list of missing dependencies that need to be installed",
        "Determines if manual setup steps are required before tests can run"
      ],
      "keyFunctions": [
        {
          "name": "detectTestConfiguration",
          "desc": "Scans project to identify test framework and configuration completeness",
          "inputs": "workspaceRoot (string path to project root)",
          "outputs": "TestConfigStatus object with framework type, configuration status, missing dependencies, and setup actions"
        }
      ],
      "dependencies": [
        "fs",
        "path",
        "SWLogger"
      ],
      "intent": "Eliminates manual test configuration burden by automatically detecting what test framework is used, what's missing, and what setup is needed, ensuring generated tests can run immediately without user intervention or troubleshooting",
      "rawContent": "```json\n{\n  \"purpose\": \"Automatically detects and configures test framework settings to ensure generated tests work without manual user setup\",\n  \"userVisibleActions\": [\n    \"Automatically detects which test framework (Jest, Mocha, Vitest, Pytest) is being used in the project\",\n    \"Identifies missing test dependencies and provides setup recommendations\",\n    \"Validates that test configuration files exist and are properly configured\",\n    \"Reports whether the test environment is ready to run generated tests\",\n    \"Suggests specific setup actions needed to fix configuration issues\"\n  ],\n  \"developerVisibleActions\": [\n    \"Scans workspace root for package.json to identify test framework from scripts and dependencies\",\n    \"Checks for framework-specific configuration files (jest.config.js, .mocharc, vitest.config.ts, pytest.ini)\",\n    \"Detects TypeScript setup and verifies TypeScript-specific test dependencies (ts-jest, @jest/globals)\",\n    \"Analyzes installed dependencies versus required dependencies for the detected framework\",\n    \"Returns structured status report with framework type, configuration state, and required actions\",\n    \"Provides list of missing dependencies that need to be installed\",\n    \"Determines if manual setup steps are required before tests can run\"\n  ],\n  \"keyFunctions\": [\n    {\n      \"name\": \"detectTestConfiguration\",\n      \"desc\": \"Scans project to identify test framework and configuration completeness\",\n      \"inputs\": \"workspaceRoot (string path to project root)\",\n      \"outputs\": \"TestConfigStatus object with framework type, configuration status, missing dependencies, and setup actions\"\n    }\n  ],\n  \"dependencies\": [\n    \"fs\",\n    \"path\",\n    \"SWLogger\"\n  ],\n  \"intent\": \"Eliminates manual test configuration burden by automatically detecting what test framework is used, what's missing, and what setup is needed, ensuring generated tests can run immediately without user intervention or troubleshooting\"\n}\n```"
    }
  ],
  "endpoints": [],
  "commands": [],
  "workers": [],
  "_metadata": {
    "index": 0,
    "total": 0,
    "savedAt": "2025-11-21T17:50:50.163Z"
  }
}