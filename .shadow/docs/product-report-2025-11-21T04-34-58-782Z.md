# Product Documentation Report

## Executive Summary

Shadow Watch is a Visual Studio Code extension that provides AI-powered code analysis and automated documentation generation for software development teams. It continuously monitors codebases to identify code quality issues, generate comprehensive documentation, and provide intelligent refactoring recommendations. By integrating with OpenAI and Claude AI providers, Shadow Watch automates the traditionally manual processes of maintaining documentation, writing tests, and identifying technical debt, enabling development teams to maintain code health and knowledge capture without manual effort.

## Product Overview

Shadow Watch transforms how development teams understand, maintain, and document their codebases by providing automated, AI-powered analysis that runs continuously in the background. The extension performs deep code inspection using AST parsing to extract function metadata, complexity metrics, and dependency relationships, then leverages large language models to generate human-readable insights, documentation, and refactoring guidance.

The product addresses a fundamental challenge in software development: as codebases grow and evolve, documentation becomes outdated, code quality degrades, and understanding complex systems requires significant expertise. Shadow Watch solves this by automatically detecting problems like high complexity functions, circular dependencies, orphaned code, and missing test coverage, then presenting these findings through interactive visualizations, inline editor annotations, and structured reports.

Development teams interact with Shadow Watch through familiar VS Code interfaces—command palette commands, sidebar tree views, inline diagnostics, and hover tooltips—making it a natural extension of their existing workflow. All analysis results are automatically saved with timestamps, creating a historical record of code health that teams can use to track improvements over time and maintain comprehensive documentation without manual maintenance.

## What It Does

Shadow Watch provides the following comprehensive capabilities:

- **Automated Code Analysis**: Analyzes entire workspaces or individual files to identify code quality issues including high complexity functions, large files, circular dependencies, orphaned code, and duplicate detection
- **AI-Powered Documentation Generation**: Creates comprehensive product documentation, architecture insights, and code explanations using OpenAI or Claude language models
- **Automated Test Generation**: Generates unit tests for functions with AI-powered test planning, validation, and automatic fixing of failing tests
- **Test Framework Auto-Configuration**: Detects and configures test frameworks (Jest, Mocha, Vitest, Pytest) without manual setup
- **Interactive Visualizations**: Displays code problems through color-coded inline diagnostics, Problems panel integration, and multiple sidebar tree views
- **Intelligent Refactoring Recommendations**: Generates detailed step-by-step refactoring plans for complex functions with extraction instructions
- **Continuous Monitoring**: Watches file changes and automatically re-analyzes modified code to keep all views synchronized
- **Test Coverage Tracking**: Identifies untested functions across the codebase and provides coverage metrics
- **Multiple Export Formats**: Exports analysis results optimized for AI assistants like Cursor and ChatGPT in Markdown and JSON formats
- **Hierarchical Navigation**: Provides codebase exploration through product navigator showing modules, components, and entry points
- **Historical Documentation Archives**: Creates timestamped documentation archives to track codebase evolution over time
- **Incremental Analysis**: Enables multi-round analysis where AI can request additional context through iterative information gathering
- **Search Capabilities**: Provides AI agents with search and exploration tools to understand codebases

## User Perspective

### GUI (Graphical User Interface)

Users interact with Shadow Watch through rich visual interfaces integrated throughout VS Code:

- **Command Palette**: Trigger workspace or file-specific analysis, generate insights, switch AI providers, clear cache, and export results
- **Sidebar Tree Views**: Browse analysis results, AI-generated insights, documentation hierarchy, and codebase structure organized by modules and components
- **Inline Editor Annotations**: Visual problem indicators with color-coded severity levels appear directly in the code editor
- **Hover Tooltips**: Detailed information about detected issues displays when hovering over problem indicators
- **Click-to-Navigate**: Jump from tree views directly to source code locations with automatic scrolling
- **Status Bar Indicators**: Show analysis progress and extension state at a glance
- **Progress Notifications**: Real-time updates during long-running operations with cancel buttons for user control
- **Problems Panel Integration**: All detected code issues appear in VS Code's Problems panel with jump-to-source links
- **Webview Panels**: View detailed reports and documentation in formatted panels
- **Context Menus**: Quick access to analysis and documentation commands from right-click menus

### CLI (Command Line Interface)

Command palette commands provide CLI-style access to all features:

- `Shadow Watch: Analyze Workspace` - Comprehensive workspace analysis
- `Shadow Watch: Analyze File` - Single file analysis
- `Shadow Watch: Generate Insights` - AI-powered insight generation
- `Shadow Watch: Generate Product Documentation` - Product documentation creation
- `Shadow Watch: Generate Tests` - Automated test generation
- `Shadow Watch: Plan Tests` - Test planning and prioritization
- `Shadow Watch: Clear Cache` - Cache management
- `Shadow Watch: Switch AI Provider` - Toggle between OpenAI and Claude
- Export commands for saving analysis results to disk
- Navigation commands for jumping to specific code elements

### API (Application Programming Interface)

Shadow Watch integrates with external services through well-defined APIs:

- **OpenAI API Integration**: GPT-based code analysis and documentation generation with configurable models
- **Anthropic Claude API Integration**: Alternative AI-powered analysis with Claude models
- **Extensible Provider System**: Architecture supports integration of additional AI services
- **File System Watching API**: Detects workspace changes and triggers appropriate updates
- **Analysis Result Storage API**: Persists documentation and insights to timestamped directories
- **VS Code Extension API**: Deep integration with VS Code's diagnostics, tree views, and editor interfaces

### CI/CD (Continuous Integration/Continuous Deployment)

Shadow Watch can be integrated into automated workflows:

- Integration into CI/CD pipelines through VS Code automation capabilities
- Exports machine-readable JSON reports for integration with quality gates
- Generates analysis results consumable by automated tooling
- Timestamps all analysis runs for tracking quality metrics over time
- Provides historical data suitable for trend analysis in quality dashboards

## Problems Solved

Shadow Watch addresses critical challenges in software development:

1. **Documentation Decay**: Manual documentation becomes outdated quickly as code evolves. Shadow Watch automatically generates and updates documentation as code changes, ensuring documentation stays synchronized with implementation.

2. **Code Quality Blind Spots**: Identifying code quality issues requires expertise and time. The extension automatically detects complexity, circular dependencies, large files, and other problems without requiring manual code review.

3. **Test Writing Overhead**: Writing comprehensive tests is time-consuming and often neglected. AI-powered test generation creates complete unit tests automatically, improving coverage without manual effort.

4. **Codebase Comprehension**: Understanding large, complex codebases is difficult for new team members. Interactive navigation and AI-generated insights make exploration easier and faster.

5. **Technical Debt Tracking**: Tracking code health over time requires manual effort and discipline. Timestamped analysis runs create an automatic historical record of code quality evolution.

6. **Test Environment Configuration**: Setting up test frameworks is complex and error-prone. Automatic detection and configuration eliminates manual setup, making test generation seamless.

7. **Refactoring Risk**: Refactoring complex code without guidance is risky. Detailed step-by-step plans reduce the chance of introducing bugs during refactoring.

8. **Code Discovery**: Finding relevant code quickly in large projects is challenging. Search and navigation tools help locate specific functions and modules efficiently.

## Architecture Overview

Shadow Watch follows a modular, domain-driven architecture organized around four core domains:

### Analysis Domain

The analysis layer performs deep code inspection using TypeScript/JavaScript AST parsing to extract function metadata, complexity metrics, and dependency relationships. Analysis data flows through an intelligent caching layer that stores results to avoid redundant processing, then feeds into insight generators that identify code quality issues and refactoring opportunities.

**Key Components:**
- Enhanced Code Analyzer: Parses AST to extract detailed function metadata
- Function Analyzer: Analyzes individual functions for complexity and dependencies
- Insight Generator: Transforms metrics into actionable recommendations
- File Cache: In-memory caching to reduce disk I/O

### Documentation Generation Domain

This domain integrates with AI language model providers through an abstraction layer supporting both OpenAI and Claude. Documentation requests flow through a prompt building system that constructs specialized queries for different tasks (architecture analysis, test generation, refactoring guidance), then results are formatted into structured Markdown and persisted to timestamped storage directories.

**Key Components:**
- LLM Integration Layer: Abstraction for multiple AI providers
- Prompt Builder: Constructs specialized prompts for different tasks
- Documentation Formatter: Transforms analysis into structured Markdown
- Rate Limiter: Prevents API quota exhaustion
- Retry Handler: Handles transient failures with exponential backoff
- Response Parser: Extracts structured data from AI responses

### Testing Automation Domain

The testing domain provides comprehensive automated testing workflows including test planning, generation, execution, and validation. It automatically detects test frameworks, configures environments, generates tests using AI, runs them, and fixes failures automatically.

**Key Components:**
- Test Planning Service: Creates prioritized test plans
- Test Generation Service: Generates unit tests using AI
- Test Execution Service: Runs tests across multiple frameworks
- Test Validation Service: Validates and fixes failing tests
- Test Configuration Service: Detects and configures test environments

### User Interface Domain

The UI architecture consists of multiple coordinated views that provide comprehensive visualization and interaction capabilities. A file watching service monitors workspace changes and triggers appropriate updates across all views, while a progress service provides consistent user feedback.

**Key Components:**
- Tree View Providers: Hierarchical data display for analysis, insights, and navigation
- Diagnostics Provider: Inline problem annotations in editor
- Webview Providers: Rich content display for reports
- Navigation Handler: Manages jumping between code locations
- Progress Service: Standardized progress notifications
- Command Registry: Maps user actions to handlers

### Data Flow

```
User Action (Command/File Save)
    ↓
Command Handler / File Watcher
    ↓
Analysis Engine (AST Parsing + Metrics)
    ↓
Cache Layer (Intelligent Caching)
    ↓
Insight Generator (Problem Detection)
    ↓
AI Integration (Prompt → LLM → Response)
    ↓
Response Parser (Structured Data Extraction)
    ↓
Formatters (Markdown/JSON Generation)
    ↓
UI Components (Tree Views/Diagnostics/Reports)
    ↓
Persistence Layer (Timestamped Storage)
```

## Key Components & Modules

### Core Analysis Components

**Code Analysis Engine**
- **Purpose**: Deep code inspection system that parses source files
- **Capabilities**: Extracts function metadata, calculates complexity metrics, maps dependencies, identifies code quality issues
- **Key Files**: `src/analysis/enhancedAnalyzer.ts`, `src/analysis/functionAnalyzer.ts`

**Insight Generator**
- **Purpose**: Transforms raw metrics into actionable recommendations
- **Capabilities**: Identifies code smells, suggests refactorings, prioritizes issues
- **Key Files**: `src/insightGenerator.ts`

### AI Integration Components

**LLM Integration Layer**
- **Purpose**: Abstraction layer for multiple AI providers
- **Capabilities**: Rate limiting, retry handling, response parsing, timeout management
- **Key Files**: `src/llmIntegration.ts`, `src/llmService.ts`, `src/ai/`

**Prompt Builder**
- **Purpose**: Constructs specialized prompts for different AI tasks
- **Capabilities**: Documentation generation, test creation, refactoring guidance, architecture analysis
- **Key Files**: `src/domain/prompts/`

### Testing Components

**Test Automation System**
- **Purpose**: Comprehensive automated testing workflow
- **Capabilities**: Test planning, generation, execution, validation, automatic fixing
- **Key Files**: `src/domain/services/testing/`

**Test Configuration Service**
- **Purpose**: Detects and configures test frameworks automatically
- **Capabilities**: Framework detection (Jest, Mocha, Vitest, Pytest), dependency checking, setup planning
- **Key Files**: `src/domain/services/testConfigurationService.ts`

### User Interface Components

**Analysis Viewer**
- **Purpose**: Hierarchical tree view for browsing analysis results
- **Capabilities**: Click-to-navigate, expandable hierarchy, real-time updates
- **Key Files**: `src/analysisViewer.ts`

**Insights Tree View**
- **Purpose**: Displays AI-generated insights and documentation
- **Capabilities**: Hierarchical organization, status indicators, navigation to sources
- **Key Files**: `src/insightsTreeView.ts`

**Product Navigator**
- **Purpose**: Shows codebase structure organized by modules and components
- **Capabilities**: Module browsing, component exploration, entry point identification
- **Key Files**: `src/productNavigator.ts`

**Diagnostics Provider**
- **Purpose**: Visual problem indicators in editor and Problems panel
- **Capabilities**: Color-coded severity, hover tooltips, jump-to-source
- **Key Files**: `src/diagnosticsProvider.ts`

### Infrastructure Components

**File Watcher Service**
- **Purpose**: Monitors workspace for file changes
- **Capabilities**: Automatic re-analysis, view synchronization, change detection
- **Key Files**: `src/domain/services/fileWatcherService.ts`

**Progress Service**
- **Purpose**: Standardized progress notifications
- **Capabilities**: Cancellable operations, multiple display locations, consistent feedback
- **Key Files**: `src/infrastructure/progressService.ts`

**Configuration Manager**
- **Purpose**: Type-safe access to all extension settings
- **Capabilities**: Change detection, setting validation, automatic propagation
- **Key Files**: `src/config/configurationManager.ts`

**Analysis Result Repository**
- **Purpose**: Persists analysis results to disk
- **Capabilities**: Timestamped directories, organized storage, historical tracking
- **Key Files**: `src/infrastructure/persistence/analysisResultRepository.ts`

### Module Organization

#### `/src/ai` - AI Provider Infrastructure
Handles reliable AI interactions with rate limiting, retry logic, and response parsing for OpenAI and Claude integrations.

#### `/src/analysis` - Code Analysis Engine
Performs deep code inspection with AST parsing to extract function metadata, complexity metrics, and dependencies.

#### `/src/config` - Configuration Management
Central hub for extension settings with type-safe access and automatic change detection.

#### `/src/domain/bootstrap` - Extension Initialization
Handles startup sequence, command registration, and UI component setup.

#### `/src/domain/formatters` - Documentation Formatting
Transforms analysis results into structured Markdown documentation.

#### `/src/domain/handlers` - Action Handlers
Manages navigation, file operations, and user interactions.

#### `/src/domain/prompts` - Prompt Engineering
Constructs specialized AI prompts for documentation, testing, and refactoring tasks.

#### `/src/domain/services` - Core Services
File watching, incremental analysis, and test configuration automation.

#### `/src/domain/services/testing` - Testing Automation
Complete testing workflow including planning, generation, execution, and validation.

#### `/src/infrastructure` - Infrastructure Services
Progress reporting, persistence, file system operations, and caching.

## Key Functions & Data Structures

### Core Functions

**analyzeWorkspace** (`src/extension.ts`)
- **Purpose**: Performs comprehensive analysis of entire workspace
- **Output**: Complete analysis results with file metadata, dependencies, and insights
- **User Impact**: Provides full codebase health assessment

**analyzeFile** (`src/extension.ts`)
- **Purpose**: Analyzes a single file for code quality issues
- **Output**: File-specific analysis with complexity metrics
- **User Impact**: Quick feedback on individual file quality

**generateInsights** (`src/llmIntegration.ts`)
- **Purpose**: Creates AI-powered architecture insights and recommendations
- **Input**: Analysis results
- **Output**: Structured insights with actionable recommendations
- **User Impact**: Intelligent code quality guidance

**generateProductDocs** (`src/llmIntegration.ts`)
- **Purpose**: Produces comprehensive product documentation
- **Input**: Code analysis data
- **Output**: Structured Markdown documentation
- **User Impact**: Automated documentation generation

**generateTests** (`src/domain/services/testing/llmTestGenerationService.ts`)
- **Purpose**: Automatically creates unit tests for functions
- **Input**: Function metadata and context
- **Output**: Complete test files with assertions
- **User Impact**: Automated test coverage improvement

**planTests** (`src/domain/services/testing/llmTestPlanningService.ts`)
- **Purpose**: Creates prioritized test plans
- **Input**: Codebase analysis
- **Output**: Recommended functions to test with priorities
- **User Impact**: Guided test coverage strategy

**validateTests** (`src/domain/services/testing/llmTestValidationService.ts`)
- **Purpose**: Runs and automatically fixes failing tests
- **Input**: Generated test files
- **Output**: Validated, passing tests
- **User Impact**: Reliable test generation

**analyzeFunction** (`src/analysis/functionAnalyzer.ts`)
- **Purpose**: Extracts detailed metadata from individual functions
- **Output**: Function signature, complexity, dependencies, behavioral hints
- **User Impact**: Function-level analysis for refactoring decisions

**generateRefactoringPlan** (`src/domain/prompts/refactoringPromptBuilder.ts`)
- **Purpose**: Creates step-by-step refactoring instructions
- **Input**: Complex function analysis
- **Output**: Detailed refactoring plan with extraction steps
- **User Impact**: Guided refactoring with reduced risk

**navigateToLocation** (`src/domain/handlers/navigationHandler.ts`)
- **Purpose**: Handles navigation to specific code locations
- **Input**: File path, line number, function name
- **Output**: Editor opens at target location with automatic scrolling
- **User Impact**: Quick code exploration

### Key Data Structures

**AnalysisResult** (`src/analyzer.ts`)
```typescript
interface AnalysisResult {
  files: Map<string, FileAnalysis>;
  dependencies: Map<string, string[]>;
  insights: Insight[];
  timestamp: Date;
  workspaceRoot: string;
}
```
Complete analysis results for a workspace including all files, dependencies, and generated insights.

**FileAnalysis** (`src/analyzer.ts`)
```typescript
interface FileAnalysis {
  path: string;
  functions: FunctionInfo[];
  complexity: number;
  lines: number;
  issues: CodeIssue[];
  dependencies: string[];
}
```
Analysis data for a single file including functions, metrics, and detected issues.

**FunctionInfo** (`src/analyzer.ts`)
```typescript
interface FunctionInfo {
  name: string;
  signature: string;
  complexity: number;
  startLine: number;
  endLine: number;
  parameters: Parameter[];
  returnType: string;
  dependencies: string[];
  behavioralHints: BehavioralHint[];
}
```
Comprehensive metadata about a function including complexity, dependencies, and behavioral characteristics.

**ProductDocumentation** (`src/fileDocumentation.ts`)
```typescript
interface ProductDocumentation {
  overview: string;
  features: Feature[];
  userPerspective: UserPerspective;
  architecture: ArchitectureDescription;
  problemsSolved: Problem[];
  workflows: Workflow[];
}
```
Structured product documentation generated from code analysis.

**TestPlan** (`src/domain/services/testing/types/testPlanTypes.ts`)
```typescript
interface TestPlan {
  functionsToTest: FunctionToTest[];
  priority: Priority;
  testingAreas: TestingArea[];
  recommendations: string[];
}
```
Prioritized plan for testing functions with recommendations.

**TestResult** (`src/domain/services/testing/types/testResultTypes.ts`)
```typescript
interface TestResult {
  passed: number;
  failed: number;
  errors: TestError[];
  coverage: CoverageData;
  duration: number;
}
```
Results of test execution including pass/fail counts and coverage metrics.

**RefactoringPlan** (`src/domain/prompts/refactoringPromptBuilder.ts`)
```typescript
interface RefactoringPlan {
  steps: RefactoringStep[];
  extractedFunctions: ExtractedFunction[];
  reasoning: string;
  risks: string[];
}
```
Step-by-step plan for refactoring complex functions.

**Insight** (`src/insightGenerator.ts`)
```typescript
interface Insight {
  type: InsightType;
  severity: Severity;
  message: string;
  location: CodeLocation;
  recommendation: string;
}
```
Code quality insight describing an issue and recommendation.

## Workflows & Integration

### Primary Workflows

#### 1. Workspace Analysis Workflow

```
User triggers "Analyze Workspace" command
    ↓
Extension displays progress notification
    ↓
File system scans workspace for source files
    ↓
Analysis engine parses each file's AST
    ↓
Metrics calculator computes complexity and dependencies
    ↓
Insight generator identifies code quality issues
    ↓
Results cached for performance
    ↓
Diagnostics provider displays problems in editor
    ↓
Tree views update with analysis results
    ↓
Results saved to timestamped directory
    ↓
User notified of completion
```

#### 2. Documentation Generation Workflow

```
User triggers "Generate Product Documentation"
    ↓
Extension gathers analysis results
    ↓
Prompt builder constructs documentation prompts
    ↓
LLM integration sends request to AI provider
    ↓
Rate limiter ensures API quota compliance
    ↓
AI generates documentation content
    ↓
Response parser extracts structured data
    ↓
Documentation formatter creates Markdown
    ↓
Result saved to .shadow/docs/[timestamp]
    ↓
Insights tree view updates with new documentation
    ↓
User can view documentation in webview
```

#### 3. Automated Test Generation Workflow

```
User triggers "Generate Tests" command
    ↓
Test configuration service detects framework
    ↓
Test planning service analyzes code and creates plan
    ↓
Test generation service generates tests for each function
    ↓
Progress notifications show incremental progress
    ↓
Test execution service runs generated tests
    ↓
Test validation service detects failures
    ↓
AI automatically fixes failing tests
    ↓
Final test results displayed to user
    ↓
Test coverage metrics updated
```

#### 4. Continuous Monitoring Workflow

```
User modifies a file and saves
    ↓
File watcher detects change
    ↓
Cache invalidated for modified file
    ↓
Analysis engine re-analyzes file
    ↓
Diagnostics updated in editor
    ↓
Tree views refresh with new data
    ↓
All views stay synchronized
```

#### 5. Refactoring Guidance Workflow

```
User identifies complex function
    ↓
User triggers "Generate Refactoring Plan"
    ↓
Function analyzer extracts detailed metadata
    ↓
Prompt builder creates refactoring prompt
    ↓
AI generates step-by-step plan
    ↓
Plan includes extraction instructions
    ↓
User reviews plan in webview
    ↓
User follows steps to refactor
    ↓
Re-analysis confirms improvement
```

### Integration Points

#### VS Code Integration

- **Command Palette**: All features accessible via command palette
- **Sidebar Views**: Custom tree view providers for analysis, insights, and navigation
- **Editor Integration**: Inline diagnostics with color-coded severity
- **Problems Panel**: Integration with VS Code's built-in problem reporting
- **Status Bar**: Real-time status indicators
- **File System Watcher**: Automatic detection of workspace changes

#### AI Provider Integration

- **OpenAI API**: GPT models for code analysis and documentation
- **Anthropic Claude API**: Alternative AI provider support
- **Extensible Architecture**: Easy addition of new AI providers
- **Rate Limiting**: Automatic compliance with API quotas
- **Retry Logic**: Resilient handling of transient failures

#### Test Framework Integration

- **Jest**: Full support for Jest test generation and execution
- **Mocha**: Compatible with Mocha testing framework
- **Vitest**: Modern Vite-based testing support
- **Pytest**: Python testing framework support
- **Multi-language**: TypeScript, JavaScript, Python, Java, C++

#### CI/CD Integration

- **VS Code Automation**: Scriptable for CI/CD pipelines
- **JSON Export**: Machine-readable reports for quality gates
- **Historical Tracking**: Timestamped results for trend analysis
- **Quality Metrics**: Exportable data for dashboards

## File Organization

### Entry Point

**src/extension.ts**
- Main extension entry point
- Registers all commands and initializes components
- Orchestrates extension activation

### Domain Layer

**Core Services**
- `src/domain/services/fileWatcherService.ts` - Workspace change monitoring
- `src/domain/services/incrementalAnalysisService.ts` - Multi-round AI analysis
- `src/domain/services/testConfigurationService.ts` - Test framework detection

**Testing Services**
- `src/domain/services/testing/llmTestGenerationService.ts` - AI test generation
- `src/domain/services/testing/llmTestPlanningService.ts` - Test planning
- `src/domain/services/testing/llmTestValidationService.ts` - Test validation
- `src/domain/services/testing/testExecutionService.ts` - Test execution

**Handlers & Formatters**
- `src/domain/handlers/navigationHandler.ts` - Code navigation
- `src/domain/formatters/documentationFormatter.ts` - Markdown formatting

**Prompts**
- `src/domain/prompts/promptBuilder.ts` - General prompt construction
- `src/domain/prompts/refactoringPromptBuilder.ts` - Refactoring prompts
- `src/domain/prompts/testPrompts.ts` - Testing prompts

**Bootstrap**
- `src/domain/bootstrap/extensionBootstrapper.ts` - Extension initialization
- `src/domain/bootstrap/commandRegistry.ts` - Command registration

### Analysis Layer

**Core Analysis**
- `src/analysis/enhancedAnalyzer.ts` - Deep code analysis
- `src/analysis/functionAnalyzer.ts` - Function-level analysis

**Analysis Support**
- `src/analyzer.ts` - Type definitions
- `src/insightGenerator.ts` - Insight generation

### AI Integration Layer

**Provider Infrastructure**
- `src/ai/llmRateLimiter.ts` - Rate limiting
- `src/ai/llmRetryHandler.ts` - Retry logic
- `src/ai/llmResponseParser.ts` - Response parsing

**Providers**
- `src/ai/providers/providerFactory.ts` - Provider instantiation
- `src/ai/providers/ILLMProvider.ts` - Provider interface

**Integration**
- `src/llmIntegration.ts` - AI feature coordination
- `src/llmService.ts` - AI request handling

### UI Layer

**Views**
- `src/analysisViewer.ts` - Analysis tree view
- `src/insightsTreeView.ts` - Insights tree view
- `src/productNavigator.ts` - Product navigation tree
- `src/diagnosticsProvider.ts` - Problem indicators

### Infrastructure Layer

**Persistence**
- `src/infrastructure/persistence/analysisResultRepository.ts` - Result storage

**File System**
- `src/infrastructure/fileSystem/fileCache.ts` - File caching
- `src/infrastructure/fileSystem/fileProcessor.ts` - Batch processing

**Services**
- `src/infrastructure/progressService.ts` - Progress notifications

### Configuration

**Config Management**
- `src/config/configurationManager.ts` - Settings management

### Context & Documentation

**Context**
- `src/context/contextBuilder.ts` - LLM context preparation

---

*This documentation was generated from Shadow Watch's comprehensive codebase analysis and represents the current state of the product architecture and capabilities.*