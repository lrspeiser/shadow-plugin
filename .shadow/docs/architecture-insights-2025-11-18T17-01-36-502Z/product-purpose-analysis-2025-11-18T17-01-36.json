{
  "productPurpose": "Shadow Watch aims to bridge the gap between code quality analysis and AI-powered development workflows by automatically detecting architecture issues and formatting them for immediate use with AI coding assistants. Its core mission is to make code quality feedback actionable by integrating static analysis with modern AI development tools, enabling developers to catch architecture problems early and get AI-powered refactoring guidance without manual effort.",
  "architectureRationale": "The architecture exists to support continuous, non-blocking code monitoring integrated deeply into the VS Code development workflow. There is a single Node.js entry point (./dist/extension.js) because Shadow Watch is exclusively a VS Code extension that must hook into VS Code's extension API and lifecycle. The multi-interface presentation layer (sidebar tree view, webview panels, inline diagnostics, context menus) exists because developers need different ways to consume analysis results depending on their current task: quick overview in the sidebar during navigation, detailed formatted reports in webviews for deep analysis, and inline diagnostics for immediate feedback while editing. The external AI provider abstraction (OpenAI, Anthropic, custom endpoints) exists because the product's value depends on connecting analysis results to AI assistants, and developers use different AI providers based on preference, budget, and organizational policies. The LLM-ready prompt formatting exists specifically because the product's differentiator is not just detecting issues, but making them immediately usable with AI tools like Cursor and ChatGPT without manual reformatting.",
  "designDecisions": [
    "Multi-layered presentation architecture (tree view + webview + diagnostics) - Reason: Developers need different information density and interaction patterns depending on whether they're browsing issues, studying detailed analysis, or editing code",
    "File system watcher with save-triggered analysis - Reason: Provides continuous feedback without requiring manual commands, catching issues at the moment code is written while avoiding performance impact from analyzing on every keystroke",
    "Caching layer for analysis results - Reason: Enables real-time feedback on save without re-analyzing unchanged files, critical for maintaining development flow in large codebases",
    "Flexible AI provider abstraction - Reason: Different users have access to different AI services (OpenAI, Anthropic, self-hosted), and the product must support all of them to be useful across diverse development teams",
    "LLM-formatted output with provider-specific templates - Reason: Different AI assistants (Cursor, ChatGPT, Claude) expect different prompt formats, so generating optimized formats increases the likelihood users get useful refactoring guidance",
    "Severity-based issue categorization (error/warning/info) - Reason: Helps developers prioritize architecture fixes by importance, preventing alert fatigue from treating all issues equally",
    "One-click copy functionality for LLM prompts - Reason: Minimizes friction in the workflow from detecting issues to getting AI help, supporting the core mission of actionable feedback",
    "JSON schema validation for AI responses - Reason: Ensures AI-generated documentation and insights are structured consistently for reliable display, preventing parsing errors that would break the user experience",
    "Multi-language static analysis engine - Reason: Developers work in polyglot codebases, and language-specific tools fragment the workflow; unified analysis across Python, JavaScript, TypeScript, Java, Go, Rust, C/C++, Ruby, and PHP provides consistent experience",
    "Incremental analysis with workspace and file-level granularity - Reason: Balances comprehensive codebase analysis with quick feedback on individual files, allowing developers to choose scope based on their immediate needs"
  ],
  "userGoals": [
    "Catch architecture anti-patterns like god objects and circular dependencies immediately while writing code, before they become embedded in the codebase",
    "Get AI-powered refactoring suggestions for detected architecture issues without manually formatting problems for AI assistants",
    "Understand what unfamiliar codebases do from a user perspective without reading through implementation details",
    "Generate and maintain up-to-date documentation automatically as code evolves, eliminating manual documentation burden",
    "Navigate quickly from detected issues to the exact code locations that need attention",
    "Choose between different AI providers based on organizational access, budget constraints, or preference for specific models",
    "Analyze entire workspaces for comprehensive architecture review or focus on specific files for quick checks",
    "Copy architecture insights in formats optimized for Cursor, ChatGPT, or other AI tools without reformatting",
    "Receive severity-prioritized feedback that distinguishes critical errors from minor suggestions",
    "Monitor codebase health trends over time through aggregated health scores",
    "Leverage AI to explain design patterns and component relationships in complex systems",
    "Understand test coverage and purposes through AI-generated unit test documentation"
  ],
  "contextualFactors": [
    "VS Code extension constraints requiring single entry point and deep integration with editor APIs",
    "Continuous monitoring requirements demanding efficient caching and incremental analysis to avoid blocking development workflow",
    "AI-first development trend where developers increasingly use AI coding assistants like Cursor, ChatGPT, and Copilot for refactoring guidance",
    "Multiple AI provider ecosystem requiring abstraction layer to support OpenAI, Anthropic, and custom endpoints",
    "Developer workflow optimization needing minimal friction between issue detection and getting AI assistance",
    "Polyglot development environments requiring multi-language support in a single tool",
    "Real-time feedback expectations from developers accustomed to instant linting and formatting",
    "Documentation maintenance burden driving demand for automated, always-current documentation generation",
    "Codebase comprehension challenges in large or unfamiliar projects requiring AI-powered explanations of architecture and purpose",
    "Performance constraints in large codebases requiring intelligent caching and selective analysis",
    "User interface diversity needs within VS Code supporting tree views, webviews, diagnostics, and context menus for different information consumption patterns"
  ],
  "_metadata": {
    "savedAt": "2025-11-18T17:01:36.502Z"
  }
}