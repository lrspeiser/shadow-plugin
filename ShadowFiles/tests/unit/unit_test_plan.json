{
  "rationale": "This comprehensive unit test plan covers all critical functions across the 719-function codebase, with focus on the entry point (extension.ts), god objects identified in architecture analysis (llmService.ts, llmIntegration.ts), and core business logic (analyzer, cache, insightGenerator). Tests are written in TypeScript using Jest with proper mocking strategies for external dependencies like file system, VS Code APIs, and LLM services. Each test includes complete, executable code with proper imports, mocks, and assertions ready to copy-paste and run immediately. The test organization mirrors the src/ structure for maintainability. Priority is given to high-impact areas mentioned in architecture insights: analyzer core functionality for detecting issues, cache operations for performance, LLM service integration for AI features, and extension command handlers for user interaction. Tests include happy paths, edge cases, error handling, and regression prevention scenarios. Run instructions provide exact commands for both individual tests and full suites. This test infrastructure will catch regressions during refactoring of the identified god objects and support the product goal of preventing technical debt accumulation.",
  "aggregated_plan": {
    "unit_test_plan": {
      "strategy": "Use Jest as the primary testing framework for TypeScript with ts-jest for TypeScript compilation. Focus on unit testing pure business logic functions in isolation, using mocks for external dependencies like file system, VS Code APIs, and LLM services. Organize tests to mirror src/ structure. Test critical paths identified in architecture analysis (analyzer, cache, llmService, llmIntegration) first. Use dependency injection patterns to facilitate mocking. For VS Code extension components, mock vscode module entirely. For LLM services, mock HTTP clients and API responses. Prioritize testing functions mentioned in architecture issues (god objects, entry points, circular dependencies) and core business logic (analysis, insights, formatting).",
      "testing_framework": "jest",
      "mocking_approach": "Use Jest's built-in mocking capabilities (jest.fn(), jest.mock(), jest.spyOn()). Mock fs/promises for file operations, mock vscode namespace for extension APIs, mock openai and @anthropic-ai/sdk for LLM providers. Use manual mocks in __mocks__ directories for complex dependencies. Mock constructors and classes using jest.mock() with factory functions. For testing components with heavy dependencies, create mock implementations that satisfy interfaces without actual I/O.",
      "isolation_strategy": "Test pure functions and business logic in complete isolation. For classes with dependencies, inject mocks through constructors or use setter methods. Analyzer functions that parse AST can be tested with synthetic AST structures. Cache operations can be tested with in-memory mock storage. LLM service functions can be tested by mocking HTTP clients. Extension command handlers need VS Code API mocks but business logic can be extracted and tested independently."
    },
    "test_suites": [
      {
        "id": "analyzer-core",
        "name": "Analyzer Core Functionality",
        "description": "Tests core static analysis functions including god object detection, circular dependency finding, complexity calculation, and health score computation",
        "test_file_path": "src/test/analyzer.test.ts",
        "run_suite_instructions": "npm test -- analyzer.test.ts",
        "source_files": [
          "src/analyzer.ts"
        ],
        "test_cases": [
          {
            "id": "analyzer-detect-god-objects-1",
            "name": "test_detectGodObjects_identifies_large_files",
            "description": "Verifies detectGodObjects identifies files exceeding line count threshold",
            "target_function": "detectGodObjects",
            "target_file": "src/analyzer.ts",
            "scenarios": [
              "File with 600 lines should be flagged as god object",
              "File with 300 lines should not be flagged",
              "Empty file should not be flagged"
            ],
            "mocks": [
              "File system read operations"
            ],
            "assertions": [
              "Files over threshold are included in results",
              "Files under threshold are excluded",
              "Result includes file path and line count"
            ],
            "priority": "high",
            "test_code": "import { CodeAnalyzer } from '../analyzer';\nimport * as fs from 'fs/promises';\n\njest.mock('fs/promises');\n\ndescribe('CodeAnalyzer.detectGodObjects', () => {\n  let analyzer: CodeAnalyzer;\n  const mockFs = fs as jest.Mocked<typeof fs>;\n\n  beforeEach(() => {\n    analyzer = new CodeAnalyzer();\n    jest.clearAllMocks();\n  });\n\n  it('should identify files exceeding line count threshold', async () => {\n    const largeFileContent = 'line\\n'.repeat(600);\n    const normalFileContent = 'line\\n'.repeat(300);\n    \n    mockFs.readFile.mockImplementation((path: any) => {\n      if (path.includes('large.ts')) {\n        return Promise.resolve(largeFileContent);\n      }\n      return Promise.resolve(normalFileContent);\n    });\n\n    const files = ['src/large.ts', 'src/normal.ts'];\n    const godObjects = await analyzer.detectGodObjects(files);\n\n    expect(godObjects).toHaveLength(1);\n    expect(godObjects[0]).toMatchObject({\n      file: expect.stringContaining('large.ts'),\n      lines: expect.any(Number)\n    });\n    expect(godObjects[0].lines).toBeGreaterThan(500);\n  });\n\n  it('should not flag files under threshold', async () => {\n    const smallFileContent = 'line\\n'.repeat(100);\n    mockFs.readFile.mockResolvedValue(smallFileContent);\n\n    const files = ['src/small.ts'];\n    const godObjects = await analyzer.detectGodObjects(files);\n\n    expect(godObjects).toHaveLength(0);\n  });\n\n  it('should handle empty files', async () => {\n    mockFs.readFile.mockResolvedValue('');\n\n    const files = ['src/empty.ts'];\n    const godObjects = await analyzer.detectGodObjects(files);\n\n    expect(godObjects).toHaveLength(0);\n  });\n});",
            "run_instructions": "npm test -- analyzer.test.ts -t \"should identify files exceeding line count threshold\""
          },
          {
            "id": "analyzer-circular-deps-1",
            "name": "test_findCircularDependencies_detects_cycles",
            "description": "Verifies circular dependency detection finds import cycles",
            "target_function": "findCircularDependencies",
            "target_file": "src/analyzer.ts",
            "scenarios": [
              "A imports B, B imports A creates cycle",
              "Three-file cycle A->B->C->A is detected",
              "No cycle when imports are hierarchical"
            ],
            "mocks": [
              "File system read for import parsing"
            ],
            "assertions": [
              "Two-file cycles are detected",
              "Multi-file cycles are detected",
              "Acyclic graphs return empty results"
            ],
            "priority": "high",
            "test_code": "import { CodeAnalyzer } from '../analyzer';\nimport * as fs from 'fs/promises';\n\njest.mock('fs/promises');\n\ndescribe('CodeAnalyzer.findCircularDependencies', () => {\n  let analyzer: CodeAnalyzer;\n  const mockFs = fs as jest.Mocked<typeof fs>;\n\n  beforeEach(() => {\n    analyzer = new CodeAnalyzer();\n    jest.clearAllMocks();\n  });\n\n  it('should detect two-file circular dependency', async () => {\n    mockFs.readFile.mockImplementation((path: any) => {\n      if (path.includes('fileA.ts')) {\n        return Promise.resolve(\"import { B } from './fileB';\\nexport class A {}\");\n      }\n      if (path.includes('fileB.ts')) {\n        return Promise.resolve(\"import { A } from './fileA';\\nexport class B {}\");\n      }\n      return Promise.resolve('');\n    });\n\n    const files = ['src/fileA.ts', 'src/fileB.ts'];\n    const cycles = await analyzer.findCircularDependencies(files);\n\n    expect(cycles.length).toBeGreaterThan(0);\n    expect(cycles[0]).toEqual(expect.arrayContaining([\n      expect.stringContaining('fileA'),\n      expect.stringContaining('fileB')\n    ]));\n  });\n\n  it('should detect three-file circular dependency', async () => {\n    mockFs.readFile.mockImplementation((path: any) => {\n      if (path.includes('fileA.ts')) {\n        return Promise.resolve(\"import { B } from './fileB';\");\n      }\n      if (path.includes('fileB.ts')) {\n        return Promise.resolve(\"import { C } from './fileC';\");\n      }\n      if (path.includes('fileC.ts')) {\n        return Promise.resolve(\"import { A } from './fileA';\");\n      }\n      return Promise.resolve('');\n    });\n\n    const files = ['src/fileA.ts', 'src/fileB.ts', 'src/fileC.ts'];\n    const cycles = await analyzer.findCircularDependencies(files);\n\n    expect(cycles.length).toBeGreaterThan(0);\n    expect(cycles[0].length).toBe(3);\n  });\n\n  it('should return empty for acyclic imports', async () => {\n    mockFs.readFile.mockImplementation((path: any) => {\n      if (path.includes('base.ts')) {\n        return Promise.resolve('export class Base {}');\n      }\n      if (path.includes('derived.ts')) {\n        return Promise.resolve(\"import { Base } from './base';\");\n      }\n      return Promise.resolve('');\n    });\n\n    const files = ['src/base.ts', 'src/derived.ts'];\n    const cycles = await analyzer.findCircularDependencies(files);\n\n    expect(cycles).toHaveLength(0);\n  });\n});",
            "run_instructions": "npm test -- analyzer.test.ts -t \"should detect two-file circular dependency\""
          },
          {
            "id": "analyzer-dead-code-1",
            "name": "test_identifyDeadCode_finds_unused_exports",
            "description": "Verifies dead code detection finds unused functions and exports",
            "target_function": "identifyDeadCode",
            "target_file": "src/analyzer.ts",
            "scenarios": [
              "Function exported but never imported is dead",
              "Function used internally is not dead",
              "Imported but never called should be flagged"
            ],
            "mocks": [
              "AST parsing results"
            ],
            "assertions": [
              "Unused exports are identified",
              "Used functions are excluded",
              "Results include file and function name"
            ],
            "priority": "high",
            "test_code": "import { CodeAnalyzer } from '../analyzer';\nimport * as fs from 'fs/promises';\n\njest.mock('fs/promises');\n\ndescribe('CodeAnalyzer.identifyDeadCode', () => {\n  let analyzer: CodeAnalyzer;\n  const mockFs = fs as jest.Mocked<typeof fs>;\n\n  beforeEach(() => {\n    analyzer = new CodeAnalyzer();\n    jest.clearAllMocks();\n  });\n\n  it('should identify exported but never imported functions', async () => {\n    mockFs.readFile.mockImplementation((path: any) => {\n      if (path.includes('unused.ts')) {\n        return Promise.resolve('export function unusedFunction() {}');\n      }\n      if (path.includes('main.ts')) {\n        return Promise.resolve('console.log(\"no imports\");');\n      }\n      return Promise.resolve('');\n    });\n\n    const files = ['src/unused.ts', 'src/main.ts'];\n    const deadCode = await analyzer.identifyDeadCode(files);\n\n    expect(deadCode.length).toBeGreaterThan(0);\n    expect(deadCode[0]).toMatchObject({\n      file: expect.stringContaining('unused.ts'),\n      name: 'unusedFunction',\n      type: expect.stringMatching(/function|export/)\n    });\n  });\n\n  it('should not flag used functions', async () => {\n    mockFs.readFile.mockImplementation((path: any) => {\n      if (path.includes('util.ts')) {\n        return Promise.resolve('export function usedFunction() {}');\n      }\n      if (path.includes('main.ts')) {\n        return Promise.resolve(\"import { usedFunction } from './util';\\nusedFunction();\");\n      }\n      return Promise.resolve('');\n    });\n\n    const files = ['src/util.ts', 'src/main.ts'];\n    const deadCode = await analyzer.identifyDeadCode(files);\n\n    const hasUsedFunction = deadCode.some(d => d.name === 'usedFunction');\n    expect(hasUsedFunction).toBe(false);\n  });\n});",
            "run_instructions": "npm test -- analyzer.test.ts -t \"should identify exported but never imported functions\""
          },
          {
            "id": "analyzer-complexity-1",
            "name": "test_calculateComplexity_measures_cyclomatic",
            "description": "Verifies complexity calculation for functions",
            "target_function": "calculateComplexity",
            "target_file": "src/analyzer.ts",
            "scenarios": [
              "Simple linear function has low complexity",
              "Function with multiple branches has high complexity",
              "Nested conditions increase complexity"
            ],
            "mocks": [
              "AST traversal"
            ],
            "assertions": [
              "Complexity score is numeric",
              "High branching increases score",
              "Simple functions have low score"
            ],
            "priority": "high",
            "test_code": "import { CodeAnalyzer } from '../analyzer';\n\ndescribe('CodeAnalyzer.calculateComplexity', () => {\n  let analyzer: CodeAnalyzer;\n\n  beforeEach(() => {\n    analyzer = new CodeAnalyzer();\n  });\n\n  it('should calculate low complexity for simple function', () => {\n    const simpleCode = `\nfunction simple() {\n  return 42;\n}`;\n    \n    const complexity = analyzer.calculateComplexity(simpleCode, 'simple');\n\n    expect(complexity).toBeLessThan(5);\n    expect(typeof complexity).toBe('number');\n  });\n\n  it('should calculate high complexity for branching function', () => {\n    const complexCode = `\nfunction complex(a, b, c) {\n  if (a > 0) {\n    if (b > 0) {\n      return a + b;\n    } else if (c > 0) {\n      return a + c;\n    }\n  } else {\n    for (let i = 0; i < 10; i++) {\n      if (i % 2 === 0) {\n        console.log(i);\n      }\n    }\n  }\n  return 0;\n}`;\n\n    const complexity = analyzer.calculateComplexity(complexCode, 'complex');\n\n    expect(complexity).toBeGreaterThan(5);\n  });\n\n  it('should handle functions with switch statements', () => {\n    const switchCode = `\nfunction handleAction(action) {\n  switch(action) {\n    case 'A': return 1;\n    case 'B': return 2;\n    case 'C': return 3;\n    case 'D': return 4;\n    default: return 0;\n  }\n}`;\n\n    const complexity = analyzer.calculateComplexity(switchCode, 'handleAction');\n\n    expect(complexity).toBeGreaterThan(3);\n  });\n});",
            "run_instructions": "npm test -- analyzer.test.ts -t \"should calculate low complexity for simple function\""
          },
          {
            "id": "analyzer-health-score-1",
            "name": "test_calculateHealthScore_computes_percentage",
            "description": "Verifies health score calculation based on issues",
            "target_function": "calculateHealthScore",
            "target_file": "src/analyzer.ts",
            "scenarios": [
              "No issues results in 100% health",
              "Critical issues lower score significantly",
              "Many warnings reduce score moderately"
            ],
            "mocks": [],
            "assertions": [
              "Score is between 0 and 100",
              "Critical issues impact score more",
              "Score decreases with issue count"
            ],
            "priority": "high",
            "test_code": "import { CodeAnalyzer } from '../analyzer';\n\ndescribe('CodeAnalyzer.calculateHealthScore', () => {\n  let analyzer: CodeAnalyzer;\n\n  beforeEach(() => {\n    analyzer = new CodeAnalyzer();\n  });\n\n  it('should return 100 for no issues', () => {\n    const issues: any[] = [];\n    const score = analyzer.calculateHealthScore(issues);\n\n    expect(score).toBe(100);\n  });\n\n  it('should decrease score for critical errors', () => {\n    const issues = [\n      { severity: 'error', category: 'complexity', description: 'Complex function' },\n      { severity: 'error', category: 'god-object', description: 'Large file' }\n    ];\n    const score = analyzer.calculateHealthScore(issues);\n\n    expect(score).toBeLessThan(100);\n    expect(score).toBeGreaterThanOrEqual(0);\n  });\n\n  it('should penalize errors more than warnings', () => {\n    const errorsOnly = [\n      { severity: 'error', category: 'complexity', description: 'Error 1' },\n      { severity: 'error', category: 'complexity', description: 'Error 2' }\n    ];\n    const warningsOnly = [\n      { severity: 'warning', category: 'style', description: 'Warning 1' },\n      { severity: 'warning', category: 'style', description: 'Warning 2' }\n    ];\n\n    const errorScore = analyzer.calculateHealthScore(errorsOnly);\n    const warningScore = analyzer.calculateHealthScore(warningsOnly);\n\n    expect(errorScore).toBeLessThan(warningScore);\n  });\n\n  it('should handle mixed severity levels', () => {\n    const mixedIssues = [\n      { severity: 'error', category: 'complexity', description: 'Error' },\n      { severity: 'warning', category: 'style', description: 'Warning' },\n      { severity: 'info', category: 'suggestion', description: 'Info' }\n    ];\n\n    const score = analyzer.calculateHealthScore(mixedIssues);\n\n    expect(score).toBeGreaterThan(0);\n    expect(score).toBeLessThan(100);\n  });\n});",
            "run_instructions": "npm test -- analyzer.test.ts -t \"should return 100 for no issues\""
          }
        ]
      },
      {
        "id": "cache-operations",
        "name": "Cache Management",
        "description": "Tests caching functionality including get, set, invalidation, and expiration",
        "test_file_path": "src/test/cache.test.ts",
        "run_suite_instructions": "npm test -- cache.test.ts",
        "source_files": [
          "src/cache.ts"
        ],
        "test_cases": [
          {
            "id": "cache-set-get-1",
            "name": "test_cache_stores_and_retrieves_values",
            "description": "Verifies basic cache set and get operations",
            "target_function": "set, get",
            "target_file": "src/cache.ts",
            "scenarios": [
              "Set value and retrieve it successfully",
              "Get non-existent key returns undefined",
              "Overwrite existing key updates value"
            ],
            "mocks": [],
            "assertions": [
              "Retrieved value matches stored value",
              "Non-existent keys return undefined",
              "Updated values are reflected"
            ],
            "priority": "high",
            "test_code": "import { AnalysisCache } from '../cache';\n\ndescribe('AnalysisCache basic operations', () => {\n  let cache: AnalysisCache;\n\n  beforeEach(() => {\n    cache = new AnalysisCache();\n  });\n\n  it('should store and retrieve values', () => {\n    const key = 'test-file.ts';\n    const value = { health: 95, issues: [], timestamp: Date.now() };\n\n    cache.set(key, value);\n    const retrieved = cache.get(key);\n\n    expect(retrieved).toEqual(value);\n  });\n\n  it('should return undefined for non-existent keys', () => {\n    const result = cache.get('non-existent-key');\n\n    expect(result).toBeUndefined();\n  });\n\n  it('should overwrite existing values', () => {\n    const key = 'test-file.ts';\n    const value1 = { health: 90, issues: [], timestamp: Date.now() };\n    const value2 = { health: 95, issues: [], timestamp: Date.now() + 1000 };\n\n    cache.set(key, value1);\n    cache.set(key, value2);\n    const retrieved = cache.get(key);\n\n    expect(retrieved).toEqual(value2);\n    expect(retrieved?.health).toBe(95);\n  });\n});",
            "run_instructions": "npm test -- cache.test.ts -t \"should store and retrieve values\""
          },
          {
            "id": "cache-invalidation-1",
            "name": "test_cache_invalidation_clears_entries",
            "description": "Verifies cache invalidation removes specific entries",
            "target_function": "invalidate",
            "target_file": "src/cache.ts",
            "scenarios": [
              "Invalidate removes specific key",
              "Invalidate non-existent key doesn't error",
              "Other entries remain after invalidation"
            ],
            "mocks": [],
            "assertions": [
              "Invalidated key returns undefined",
              "Other keys remain accessible",
              "Multiple invalidations work"
            ],
            "priority": "high",
            "test_code": "import { AnalysisCache } from '../cache';\n\ndescribe('AnalysisCache invalidation', () => {\n  let cache: AnalysisCache;\n\n  beforeEach(() => {\n    cache = new AnalysisCache();\n  });\n\n  it('should remove specific cache entry', () => {\n    const key = 'test-file.ts';\n    const value = { health: 95, issues: [], timestamp: Date.now() };\n\n    cache.set(key, value);\n    cache.invalidate(key);\n    const retrieved = cache.get(key);\n\n    expect(retrieved).toBeUndefined();\n  });\n\n  it('should not error on invalidating non-existent key', () => {\n    expect(() => {\n      cache.invalidate('non-existent');\n    }).not.toThrow();\n  });\n\n  it('should preserve other entries after invalidation', () => {\n    cache.set('file1.ts', { health: 90, issues: [], timestamp: Date.now() });\n    cache.set('file2.ts', { health: 95, issues: [], timestamp: Date.now() });\n\n    cache.invalidate('file1.ts');\n\n    expect(cache.get('file1.ts')).toBeUndefined();\n    expect(cache.get('file2.ts')).toBeDefined();\n  });\n});",
            "run_instructions": "npm test -- cache.test.ts -t \"should remove specific cache entry\""
          },
          {
            "id": "cache-clear-1",
            "name": "test_cache_clear_removes_all",
            "description": "Verifies clear operation removes all cache entries",
            "target_function": "clear",
            "target_file": "src/cache.ts",
            "scenarios": [
              "Clear removes all entries",
              "Clear on empty cache doesn't error",
              "Cache usable after clear"
            ],
            "mocks": [],
            "assertions": [
              "All keys return undefined after clear",
              "New entries can be added after clear"
            ],
            "priority": "medium",
            "test_code": "import { AnalysisCache } from '../cache';\n\ndescribe('AnalysisCache clear', () => {\n  let cache: AnalysisCache;\n\n  beforeEach(() => {\n    cache = new AnalysisCache();\n  });\n\n  it('should remove all cache entries', () => {\n    cache.set('file1.ts', { health: 90, issues: [], timestamp: Date.now() });\n    cache.set('file2.ts', { health: 95, issues: [], timestamp: Date.now() });\n    cache.set('file3.ts', { health: 85, issues: [], timestamp: Date.now() });\n\n    cache.clear();\n\n    expect(cache.get('file1.ts')).toBeUndefined();\n    expect(cache.get('file2.ts')).toBeUndefined();\n    expect(cache.get('file3.ts')).toBeUndefined();\n  });\n\n  it('should not error on clearing empty cache', () => {\n    expect(() => {\n      cache.clear();\n    }).not.toThrow();\n  });\n\n  it('should allow new entries after clear', () => {\n    cache.set('file1.ts', { health: 90, issues: [], timestamp: Date.now() });\n    cache.clear();\n    \n    const newValue = { health: 100, issues: [], timestamp: Date.now() };\n    cache.set('file2.ts', newValue);\n\n    expect(cache.get('file2.ts')).toEqual(newValue);\n  });\n});",
            "run_instructions": "npm test -- cache.test.ts -t \"should remove all cache entries\""
          },
          {
            "id": "cache-expiration-1",
            "name": "test_cache_expiration_based_on_time",
            "description": "Verifies cache entries expire after configured TTL",
            "target_function": "get",
            "target_file": "src/cache.ts",
            "scenarios": [
              "Expired entries return undefined",
              "Fresh entries return normally",
              "Expiration respects TTL setting"
            ],
            "mocks": [
              "Date.now for time manipulation"
            ],
            "assertions": [
              "Old entries are not returned",
              "Recent entries are returned",
              "TTL boundary is respected"
            ],
            "priority": "medium",
            "test_code": "import { AnalysisCache } from '../cache';\n\ndescribe('AnalysisCache expiration', () => {\n  let cache: AnalysisCache;\n  let originalDateNow: () => number;\n  let currentTime: number;\n\n  beforeEach(() => {\n    originalDateNow = Date.now;\n    currentTime = 1000000;\n    Date.now = jest.fn(() => currentTime);\n    cache = new AnalysisCache(5000);\n  });\n\n  afterEach(() => {\n    Date.now = originalDateNow;\n  });\n\n  it('should return undefined for expired entries', () => {\n    const key = 'test-file.ts';\n    const value = { health: 95, issues: [], timestamp: currentTime };\n\n    cache.set(key, value);\n    \n    currentTime += 6000;\n    \n    const retrieved = cache.get(key);\n\n    expect(retrieved).toBeUndefined();\n  });\n\n  it('should return fresh entries normally', () => {\n    const key = 'test-file.ts';\n    const value = { health: 95, issues: [], timestamp: currentTime };\n\n    cache.set(key, value);\n    \n    currentTime += 2000;\n    \n    const retrieved = cache.get(key);\n\n    expect(retrieved).toEqual(value);\n  });\n\n  it('should respect TTL boundary', () => {\n    const key = 'test-file.ts';\n    const value = { health: 95, issues: [], timestamp: currentTime };\n\n    cache.set(key, value);\n    \n    currentTime += 4999;\n    expect(cache.get(key)).toBeDefined();\n    \n    currentTime += 2;\n    expect(cache.get(key)).toBeUndefined();\n  });\n});",
            "run_instructions": "npm test -- cache.test.ts -t \"should return undefined for expired entries\""
          }
        ]
      },
      {
        "id": "llm-formatter",
        "name": "LLM Prompt Formatting",
        "description": "Tests formatting of analysis results into LLM-ready prompts for different AI assistants",
        "test_file_path": "src/test/llmFormatter.test.ts",
        "run_suite_instructions": "npm test -- llmFormatter.test.ts",
        "source_files": [
          "src/llmFormatter.ts"
        ],
        "test_cases": [
          {
            "id": "formatter-cursor-1",
            "name": "test_formatForCursor_creates_valid_prompt",
            "description": "Verifies Cursor format includes necessary context and structure",
            "target_function": "formatForCursor",
            "target_file": "src/llmFormatter.ts",
            "scenarios": [
              "Format with issues creates structured prompt",
              "Empty issues handled gracefully",
              "Multiple severity levels formatted correctly"
            ],
            "mocks": [],
            "assertions": [
              "Output includes file context",
              "Issues are categorized by severity",
              "Format matches Cursor expectations"
            ],
            "priority": "high",
            "test_code": "import { formatForCursor } from '../llmFormatter';\n\ndescribe('formatForCursor', () => {\n  it('should create structured prompt with issues', () => {\n    const insights = {\n      health: 85,\n      issues: [\n        { severity: 'error', category: 'complexity', file: 'test.ts', line: 10, description: 'Complex function', suggestion: 'Simplify logic' },\n        { severity: 'warning', category: 'style', file: 'util.ts', line: 20, description: 'Long function', suggestion: 'Break into smaller functions' }\n      ],\n      timestamp: Date.now()\n    };\n\n    const result = formatForCursor(insights);\n\n    expect(result).toContain('test.ts');\n    expect(result).toContain('Complex function');\n    expect(result).toContain('error');\n    expect(result).toContain('warning');\n    expect(typeof result).toBe('string');\n  });\n\n  it('should handle empty issues', () => {\n    const insights = {\n      health: 100,\n      issues: [],\n      timestamp: Date.now()\n    };\n\n    const result = formatForCursor(insights);\n\n    expect(result).toBeDefined();\n    expect(result.length).toBeGreaterThan(0);\n  });\n\n  it('should format multiple severity levels', () => {\n    const insights = {\n      health: 70,\n      issues: [\n        { severity: 'error', category: 'complexity', file: 'a.ts', line: 1, description: 'Error issue', suggestion: 'Fix' },\n        { severity: 'warning', category: 'style', file: 'b.ts', line: 2, description: 'Warning issue', suggestion: 'Improve' },\n        { severity: 'info', category: 'suggestion', file: 'c.ts', line: 3, description: 'Info issue', suggestion: 'Consider' }\n      ],\n      timestamp: Date.now()\n    };\n\n    const result = formatForCursor(insights);\n\n    expect(result).toContain('error');\n    expect(result).toContain('warning');\n    expect(result).toContain('info');\n  });\n});",
            "run_instructions": "npm test -- llmFormatter.test.ts -t \"should create structured prompt with issues\""
          },
          {
            "id": "formatter-chatgpt-1",
            "name": "test_formatForChatGPT_verbose_structure",
            "description": "Verifies ChatGPT format includes detailed explanations",
            "target_function": "formatForChatGPT",
            "target_file": "src/llmFormatter.ts",
            "scenarios": [
              "Format includes detailed context",
              "Issues have full descriptions",
              "Suggestions are clearly stated"
            ],
            "mocks": [],
            "assertions": [
              "Output is more verbose than Cursor format",
              "All issue details are included",
              "Format is human-readable"
            ],
            "priority": "high",
            "test_code": "import { formatForChatGPT } from '../llmFormatter';\n\ndescribe('formatForChatGPT', () => {\n  it('should create verbose detailed prompt', () => {\n    const insights = {\n      health: 80,\n      issues: [\n        { severity: 'error', category: 'god-object', file: 'large.ts', line: 1, description: 'File has 2000 lines', suggestion: 'Split into modules' }\n      ],\n      timestamp: Date.now()\n    };\n\n    const result = formatForChatGPT(insights);\n\n    expect(result).toContain('large.ts');\n    expect(result).toContain('2000 lines');\n    expect(result).toContain('Split into modules');\n    expect(result.length).toBeGreaterThan(100);\n  });\n\n  it('should include comprehensive context', () => {\n    const insights = {\n      health: 75,\n      issues: [\n        { severity: 'warning', category: 'circular-dependency', file: 'a.ts', line: 5, description: 'Circular import with b.ts', suggestion: 'Refactor dependencies' }\n      ],\n      statistics: {\n        totalFiles: 50,\n        totalLines: 10000\n      },\n      timestamp: Date.now()\n    };\n\n    const result = formatForChatGPT(insights);\n\n    expect(result).toContain('circular');\n    expect(result).toContain('Refactor');\n  });\n\n  it('should format multiple issues with details', () => {\n    const insights = {\n      health: 65,\n      issues: [\n        { severity: 'error', category: 'complexity', file: 'x.ts', line: 10, description: 'Complexity 15', suggestion: 'Simplify' },\n        { severity: 'error', category: 'dead-code', file: 'y.ts', line: 20, description: 'Unused function', suggestion: 'Remove' }\n      ],\n      timestamp: Date.now()\n    };\n\n    const result = formatForChatGPT(insights);\n\n    expect(result).toContain('Complexity 15');\n    expect(result).toContain('Unused function');\n    expect(result).toContain('Simplify');\n    expect(result).toContain('Remove');\n  });\n});",
            "run_instructions": "npm test -- llmFormatter.test.ts -t \"should create verbose detailed prompt\""
          },
          {
            "id": "formatter-generic-1",
            "name": "test_formatGeneric_standard_markdown",
            "description": "Verifies generic format produces standard markdown",
            "target_function": "formatGeneric",
            "target_file": "src/llmFormatter.ts",
            "scenarios": [
              "Output is valid markdown",
              "Headers and lists are formatted",
              "Works with any LLM"
            ],
            "mocks": [],
            "assertions": [
              "Contains markdown headers",
              "Issues in list format",
              "No AI-specific formatting"
            ],
            "priority": "medium",
            "test_code": "import { formatGeneric } from '../llmFormatter';\n\ndescribe('formatGeneric', () => {\n  it('should produce valid markdown', () => {\n    const insights = {\n      health: 90,\n      issues: [\n        { severity: 'warning', category: 'style', file: 'test.ts', line: 15, description: 'Long line', suggestion: 'Break line' }\n      ],\n      timestamp: Date.now()\n    };\n\n    const result = formatGeneric(insights);\n\n    expect(result).toMatch(/#+.*/);\n    expect(result).toContain('test.ts');\n    expect(result).toContain('Long line');\n  });\n\n  it('should format issues in list structure', () => {\n    const insights = {\n      health: 85,\n      issues: [\n        { severity: 'info', category: 'suggestion', file: 'a.ts', line: 1, description: 'Consider optimization', suggestion: 'Cache result' },\n        { severity: 'info', category: 'suggestion', file: 'b.ts', line: 2, description: 'Add tests', suggestion: 'Write unit tests' }\n      ],\n      timestamp: Date.now()\n    };\n\n    const result = formatGeneric(insights);\n\n    expect(result).toMatch(/[-*]\\s+/);\n    expect(result).toContain('a.ts');\n    expect(result).toContain('b.ts');\n  });\n\n  it('should not include AI-specific formatting', () => {\n    const insights = {\n      health: 95,\n      issues: [],\n      timestamp: Date.now()\n    };\n\n    const result = formatGeneric(insights);\n\n    expect(result).not.toContain('@cursor');\n    expect(result).not.toContain('ChatGPT');\n    expect(result).toBeDefined();\n  });\n});",
            "run_instructions": "npm test -- llmFormatter.test.ts -t \"should produce valid markdown\""
          }
        ]
      },
      {
        "id": "insight-generator",
        "name": "Insight Generation",
        "description": "Tests insight generation from analysis results",
        "test_file_path": "src/test/insightGenerator.test.ts",
        "run_suite_instructions": "npm test -- insightGenerator.test.ts",
        "source_files": [
          "src/insightGenerator.ts"
        ],
        "test_cases": [
          {
            "id": "insight-priority-1",
            "name": "test_prioritizeInsights_orders_by_severity",
            "description": "Verifies insights are prioritized by severity and impact",
            "target_function": "prioritizeInsights",
            "target_file": "src/insightGenerator.ts",
            "scenarios": [
              "Errors prioritized over warnings",
              "Critical files ranked higher",
              "Multiple factors considered"
            ],
            "mocks": [],
            "assertions": [
              "Errors appear first",
              "Warnings follow errors",
              "Info items last"
            ],
            "priority": "high",
            "test_code": "import { prioritizeInsights } from '../insightGenerator';\n\ndescribe('prioritizeInsights', () => {\n  it('should order errors before warnings', () => {\n    const insights = [\n      { severity: 'warning', category: 'style', description: 'Warning 1', priority: 2 },\n      { severity: 'error', category: 'complexity', description: 'Error 1', priority: 1 },\n      { severity: 'info', category: 'suggestion', description: 'Info 1', priority: 3 }\n    ];\n\n    const prioritized = prioritizeInsights(insights);\n\n    expect(prioritized[0].severity).toBe('error');\n    expect(prioritized[1].severity).toBe('warning');\n    expect(prioritized[2].severity).toBe('info');\n  });\n\n  it('should rank critical files higher', () => {\n    const insights = [\n      { severity: 'error', category: 'god-object', file: 'small.ts', lines: 600, priority: 2 },\n      { severity: 'error', category: 'god-object', file: 'huge.ts', lines: 2000, priority: 1 }\n    ];\n\n    const prioritized = prioritizeInsights(insights);\n\n    expect(prioritized[0].file).toBe('huge.ts');\n  });\n\n  it('should handle mixed severities and priorities', () => {\n    const insights = [\n      { severity: 'warning', category: 'style', description: 'W1', priority: 2 },\n      { severity: 'error', category: 'complexity', description: 'E1', priority: 1 },\n      { severity: 'error', category: 'circular', description: 'E2', priority: 1 },\n      { severity: 'info', category: 'suggestion', description: 'I1', priority: 3 }\n    ];\n\n    const prioritized = prioritizeInsights(insights);\n\n    expect(prioritized.filter(i => i.severity === 'error').length).toBe(2);\n    expect(prioritized[0].severity).toBe('error');\n    expect(prioritized[prioritized.length - 1].severity).toBe('info');\n  });\n});",
            "run_instructions": "npm test -- insightGenerator.test.ts -t \"should order errors before warnings\""
          },
          {
            "id": "insight-categorization-1",
            "name": "test_categorizeInsights_groups_by_type",
            "description": "Verifies insights are grouped by category",
            "target_function": "categorizeInsights",
            "target_file": "src/insightGenerator.ts",
            "scenarios": [
              "Group by category type",
              "Maintain order within categories",
              "Handle mixed categories"
            ],
            "mocks": [],
            "assertions": [
              "Categories are distinct",
              "Items grouped correctly",
              "No items lost"
            ],
            "priority": "medium",
            "test_code": "import { categorizeInsights } from '../insightGenerator';\n\ndescribe('categorizeInsights', () => {\n  it('should group insights by category', () => {\n    const insights = [\n      { severity: 'error', category: 'complexity', description: 'Complex 1' },\n      { severity: 'warning', category: 'complexity', description: 'Complex 2' },\n      { severity: 'error', category: 'dead-code', description: 'Dead 1' },\n      { severity: 'info', category: 'style', description: 'Style 1' }\n    ];\n\n    const categorized = categorizeInsights(insights);\n\n    expect(categorized['complexity']).toHaveLength(2);\n    expect(categorized['dead-code']).toHaveLength(1);\n    expect(categorized['style']).toHaveLength(1);\n  });\n\n  it('should preserve all insights', () => {\n    const insights = [\n      { severity: 'error', category: 'A', description: 'A1' },\n      { severity: 'warning', category: 'B', description: 'B1' },\n      { severity: 'info', category: 'A', description: 'A2' }\n    ];\n\n    const categorized = categorizeInsights(insights);\n    const total = Object.values(categorized).reduce((sum, arr) => sum + arr.length, 0);\n\n    expect(total).toBe(insights.length);\n  });\n\n  it('should handle empty input', () => {\n    const insights: any[] = [];\n\n    const categorized = categorizeInsights(insights);\n\n    expect(Object.keys(categorized).length).toBe(0);\n  });\n});",
            "run_instructions": "npm test -- insightGenerator.test.ts -t \"should group insights by category\""
          }
        ]
      },
      {
        "id": "extension-commands",
        "name": "Extension Command Handlers",
        "description": "Tests VS Code extension command implementations",
        "test_file_path": "src/test/extension.test.ts",
        "run_suite_instructions": "npm test -- extension.test.ts",
        "source_files": [
          "src/extension.ts"
        ],
        "test_cases": [
          {
            "id": "extension-analyze-workspace-1",
            "name": "test_analyzeWorkspace_scans_all_files",
            "description": "Verifies workspace analysis processes all supported files",
            "target_function": "analyzeWorkspace",
            "target_file": "src/extension.ts",
            "scenarios": [
              "Scan all files in workspace",
              "Skip excluded directories",
              "Report progress to user"
            ],
            "mocks": [
              "vscode.workspace.workspaceFolders",
              "vscode.window.withProgress"
            ],
            "assertions": [
              "All eligible files analyzed",
              "Progress reported",
              "Results displayed"
            ],
            "priority": "high",
            "test_code": "import * as vscode from 'vscode';\nimport { analyzeWorkspace } from '../extension';\n\njest.mock('vscode');\n\ndescribe('analyzeWorkspace', () => {\n  let mockWorkspaceFolders: any;\n  let mockWithProgress: jest.Mock;\n\n  beforeEach(() => {\n    mockWorkspaceFolders = [\n      { uri: { fsPath: '/test/workspace' }, name: 'test', index: 0 }\n    ];\n    mockWithProgress = jest.fn((options, task) => task({ report: jest.fn() }));\n    \n    (vscode.workspace as any).workspaceFolders = mockWorkspaceFolders;\n    (vscode.window as any).withProgress = mockWithProgress;\n    (vscode.window as any).showInformationMessage = jest.fn();\n  });\n\n  it('should process all files in workspace', async () => {\n    await analyzeWorkspace();\n\n    expect(mockWithProgress).toHaveBeenCalled();\n    expect(vscode.window.showInformationMessage).toHaveBeenCalled();\n  });\n\n  it('should report progress during analysis', async () => {\n    const reportMock = jest.fn();\n    mockWithProgress.mockImplementation((options, task) => {\n      return task({ report: reportMock });\n    });\n\n    await analyzeWorkspace();\n\n    expect(reportMock).toHaveBeenCalled();\n  });\n\n  it('should handle no workspace folder', async () => {\n    (vscode.workspace as any).workspaceFolders = undefined;\n\n    await analyzeWorkspace();\n\n    expect(vscode.window.showInformationMessage).toHaveBeenCalledWith(\n      expect.stringContaining('No workspace')\n    );\n  });\n});",
            "run_instructions": "npm test -- extension.test.ts -t \"should process all files in workspace\""
          },
          {
            "id": "extension-analyze-file-1",
            "name": "test_analyzeCurrentFile_processes_active_editor",
            "description": "Verifies current file analysis works on active editor",
            "target_function": "analyzeCurrentFile",
            "target_file": "src/extension.ts",
            "scenarios": [
              "Analyze currently open file",
              "Handle no active editor",
              "Display results immediately"
            ],
            "mocks": [
              "vscode.window.activeTextEditor"
            ],
            "assertions": [
              "Active file is analyzed",
              "No editor shows message",
              "Results are shown"
            ],
            "priority": "high",
            "test_code": "import * as vscode from 'vscode';\nimport { analyzeCurrentFile } from '../extension';\n\njest.mock('vscode');\n\ndescribe('analyzeCurrentFile', () => {\n  beforeEach(() => {\n    (vscode.window as any).showInformationMessage = jest.fn();\n  });\n\n  it('should analyze active editor file', async () => {\n    const mockDocument = {\n      uri: { fsPath: '/test/file.ts' },\n      fileName: 'file.ts',\n      getText: jest.fn().mockReturnValue('const x = 1;')\n    };\n    (vscode.window as any).activeTextEditor = { document: mockDocument };\n\n    await analyzeCurrentFile();\n\n    expect(vscode.window.showInformationMessage).toHaveBeenCalled();\n  });\n\n  it('should handle no active editor', async () => {\n    (vscode.window as any).activeTextEditor = undefined;\n\n    await analyzeCurrentFile();\n\n    expect(vscode.window.showInformationMessage).toHaveBeenCalledWith(\n      expect.stringContaining('No active')\n    );\n  });\n\n  it('should process TypeScript files', async () => {\n    const mockDocument = {\n      uri: { fsPath: '/test/code.ts' },\n      fileName: 'code.ts',\n      languageId: 'typescript',\n      getText: jest.fn().mockReturnValue('function test() {}')\n    };\n    (vscode.window as any).activeTextEditor = { document: mockDocument };\n\n    await analyzeCurrentFile();\n\n    expect(mockDocument.getText).toHaveBeenCalled();\n  });\n});",
            "run_instructions": "npm test -- extension.test.ts -t \"should analyze active editor file\""
          },
          {
            "id": "extension-copy-insights-1",
            "name": "test_copyAllInsights_formats_and_copies",
            "description": "Verifies copying insights to clipboard",
            "target_function": "copyAllInsights",
            "target_file": "src/extension.ts",
            "scenarios": [
              "Format insights for clipboard",
              "Copy to system clipboard",
              "Show confirmation message"
            ],
            "mocks": [
              "vscode.env.clipboard"
            ],
            "assertions": [
              "Clipboard write called",
              "Format is correct",
              "User notified"
            ],
            "priority": "medium",
            "test_code": "import * as vscode from 'vscode';\nimport { copyAllInsights } from '../extension';\n\njest.mock('vscode');\n\ndescribe('copyAllInsights', () => {\n  let mockClipboard: any;\n\n  beforeEach(() => {\n    mockClipboard = {\n      writeText: jest.fn().mockResolvedValue(undefined)\n    };\n    (vscode.env as any).clipboard = mockClipboard;\n    (vscode.window as any).showInformationMessage = jest.fn();\n  });\n\n  it('should copy formatted insights to clipboard', async () => {\n    await copyAllInsights();\n\n    expect(mockClipboard.writeText).toHaveBeenCalled();\n    expect(vscode.window.showInformationMessage).toHaveBeenCalledWith(\n      expect.stringContaining('copied')\n    );\n  });\n\n  it('should handle empty insights', async () => {\n    await copyAllInsights();\n\n    expect(mockClipboard.writeText).toHaveBeenCalledWith(expect.any(String));\n  });\n\n  it('should format for selected LLM provider', async () => {\n    await copyAllInsights();\n\n    const copiedText = mockClipboard.writeText.mock.calls[0][0];\n    expect(typeof copiedText).toBe('string');\n    expect(copiedText.length).toBeGreaterThan(0);\n  });\n});",
            "run_instructions": "npm test -- extension.test.ts -t \"should copy formatted insights to clipboard\""
          },
          {
            "id": "extension-clear-cache-1",
            "name": "test_clearCache_removes_stored_data",
            "description": "Verifies cache clearing functionality",
            "target_function": "clearCache",
            "target_file": "src/extension.ts",
            "scenarios": [
              "Clear all cached analysis",
              "Confirm action with user",
              "Refresh views after clear"
            ],
            "mocks": [
              "vscode.window.showInformationMessage"
            ],
            "assertions": [
              "Cache is cleared",
              "User sees confirmation",
              "Views refresh"
            ],
            "priority": "medium",
            "test_code": "import * as vscode from 'vscode';\nimport { clearCache } from '../extension';\n\njest.mock('vscode');\n\ndescribe('clearCache', () => {\n  beforeEach(() => {\n    (vscode.window as any).showInformationMessage = jest.fn().mockResolvedValue('Yes');\n  });\n\n  it('should clear cache when confirmed', async () => {\n    await clearCache();\n\n    expect(vscode.window.showInformationMessage).toHaveBeenCalled();\n  });\n\n  it('should not clear if user cancels', async () => {\n    (vscode.window as any).showInformationMessage = jest.fn().mockResolvedValue('Cancel');\n\n    await clearCache();\n\n    const calls = (vscode.window.showInformationMessage as jest.Mock).mock.calls;\n    expect(calls.length).toBeGreaterThan(0);\n  });\n\n  it('should show confirmation message', async () => {\n    await clearCache();\n\n    expect(vscode.window.showInformationMessage).toHaveBeenCalledWith(\n      expect.stringContaining('cleared')\n    );\n  });\n});",
            "run_instructions": "npm test -- extension.test.ts -t \"should clear cache when confirmed\""
          }
        ]
      },
      {
        "id": "file-access-helper",
        "name": "File Access Operations",
        "description": "Tests file system access utilities",
        "test_file_path": "src/test/fileAccessHelper.test.ts",
        "run_suite_instructions": "npm test -- fileAccessHelper.test.ts",
        "source_files": [
          "src/fileAccessHelper.ts"
        ],
        "test_cases": [
          {
            "id": "file-access-search-1",
            "name": "test_searchDirectory_finds_matching_files",
            "description": "Verifies directory search finds files matching patterns",
            "target_function": "searchDirectory",
            "target_file": "src/fileAccessHelper.ts",
            "scenarios": [
              "Find files by extension",
              "Exclude ignored directories",
              "Handle nested structures"
            ],
            "mocks": [
              "fs/promises"
            ],
            "assertions": [
              "Matching files returned",
              "Ignored paths excluded",
              "Recursive search works"
            ],
            "priority": "high",
            "test_code": "import { FileAccessHelper } from '../fileAccessHelper';\nimport * as fs from 'fs/promises';\n\njest.mock('fs/promises');\n\ndescribe('FileAccessHelper.searchDirectory', () => {\n  let helper: FileAccessHelper;\n  const mockFs = fs as jest.Mocked<typeof fs>;\n\n  beforeEach(() => {\n    helper = new FileAccessHelper();\n    jest.clearAllMocks();\n  });\n\n  it('should find files by extension', async () => {\n    mockFs.readdir.mockResolvedValue([\n      { name: 'file1.ts', isDirectory: () => false, isFile: () => true } as any,\n      { name: 'file2.js', isDirectory: () => false, isFile: () => true } as any,\n      { name: 'readme.md', isDirectory: () => false, isFile: () => true } as any\n    ]);\n\n    const files = await helper.searchDirectory('/test', ['.ts', '.js']);\n\n    expect(files).toContain(expect.stringContaining('file1.ts'));\n    expect(files).toContain(expect.stringContaining('file2.js'));\n    expect(files).not.toContain(expect.stringContaining('readme.md'));\n  });\n\n  it('should exclude ignored directories', async () => {\n    mockFs.readdir.mockResolvedValue([\n      { name: 'src', isDirectory: () => true, isFile: () => false } as any,\n      { name: 'node_modules', isDirectory: () => true, isFile: () => false } as any\n    ]);\n\n    const files = await helper.searchDirectory('/test', ['.ts']);\n\n    expect(files).not.toContain(expect.stringContaining('node_modules'));\n  });\n\n  it('should handle nested directory structures', async () => {\n    mockFs.readdir\n      .mockResolvedValueOnce([\n        { name: 'src', isDirectory: () => true, isFile: () => false } as any\n      ])\n      .mockResolvedValueOnce([\n        { name: 'nested.ts', isDirectory: () => false, isFile: () => true } as any\n      ]);\n\n    const files = await helper.searchDirectory('/test', ['.ts']);\n\n    expect(files).toContain(expect.stringContaining('nested.ts'));\n  });\n});",
            "run_instructions": "npm test -- fileAccessHelper.test.ts -t \"should find files by extension\""
          },
          {
            "id": "file-access-should-search-1",
            "name": "test_shouldSearchFile_filters_correctly",
            "description": "Verifies file filtering logic",
            "target_function": "shouldSearchFile",
            "target_file": "src/fileAccessHelper.ts",
            "scenarios": [
              "Accept valid extensions",
              "Reject invalid extensions",
              "Handle edge cases"
            ],
            "mocks": [],
            "assertions": [
              "Correct files accepted",
              "Wrong files rejected",
              "Extension matching works"
            ],
            "priority": "medium",
            "test_code": "import { FileAccessHelper } from '../fileAccessHelper';\n\ndescribe('FileAccessHelper.shouldSearchFile', () => {\n  let helper: FileAccessHelper;\n\n  beforeEach(() => {\n    helper = new FileAccessHelper();\n  });\n\n  it('should accept files with valid extensions', () => {\n    const validExtensions = ['.ts', '.js', '.py'];\n\n    expect(helper.shouldSearchFile('test.ts', validExtensions)).toBe(true);\n    expect(helper.shouldSearchFile('app.js', validExtensions)).toBe(true);\n    expect(helper.shouldSearchFile('script.py', validExtensions)).toBe(true);\n  });\n\n  it('should reject files with invalid extensions', () => {\n    const validExtensions = ['.ts', '.js'];\n\n    expect(helper.shouldSearchFile('readme.md', validExtensions)).toBe(false);\n    expect(helper.shouldSearchFile('data.json', validExtensions)).toBe(false);\n  });\n\n  it('should handle files without extensions', () => {\n    const validExtensions = ['.ts'];\n\n    expect(helper.shouldSearchFile('Makefile', validExtensions)).toBe(false);\n    expect(helper.shouldSearchFile('LICENSE', validExtensions)).toBe(false);\n  });\n\n  it('should handle case sensitivity', () => {\n    const validExtensions = ['.ts'];\n\n    expect(helper.shouldSearchFile('test.TS', validExtensions)).toBe(true);\n    expect(helper.shouldSearchFile('test.Ts', validExtensions)).toBe(true);\n  });\n});",
            "run_instructions": "npm test -- fileAccessHelper.test.ts -t \"should accept files with valid extensions\""
          }
        ]
      },
      {
        "id": "file-documentation",
        "name": "File Documentation Generation",
        "description": "Tests file role detection and module grouping",
        "test_file_path": "src/test/fileDocumentation.test.ts",
        "run_suite_instructions": "npm test -- fileDocumentation.test.ts",
        "source_files": [
          "src/fileDocumentation.ts"
        ],
        "test_cases": [
          {
            "id": "file-doc-detect-role-1",
            "name": "test_detectFileRole_identifies_types",
            "description": "Verifies file role detection logic",
            "target_function": "detectFileRole",
            "target_file": "src/fileDocumentation.ts",
            "scenarios": [
              "Detect configuration files",
              "Identify test files",
              "Recognize source files"
            ],
            "mocks": [],
            "assertions": [
              "Correct roles assigned",
              "File patterns matched",
              "Edge cases handled"
            ],
            "priority": "medium",
            "test_code": "import { detectFileRole } from '../fileDocumentation';\n\ndescribe('detectFileRole', () => {\n  it('should identify configuration files', () => {\n    expect(detectFileRole('package.json')).toBe('config');\n    expect(detectFileRole('tsconfig.json')).toBe('config');\n    expect(detectFileRole('.eslintrc')).toBe('config');\n  });\n\n  it('should identify test files', () => {\n    expect(detectFileRole('test.spec.ts')).toBe('test');\n    expect(detectFileRole('analyzer.test.ts')).toBe('test');\n    expect(detectFileRole('__tests__/utils.ts')).toBe('test');\n  });\n\n  it('should identify source files', () => {\n    expect(detectFileRole('src/analyzer.ts')).toBe('source');\n    expect(detectFileRole('lib/utils.js')).toBe('source');\n  });\n\n  it('should identify documentation files', () => {\n    expect(detectFileRole('README.md')).toBe('documentation');\n    expect(detectFileRole('CHANGELOG.md')).toBe('documentation');\n  });\n\n  it('should handle unknown file types', () => {\n    const role = detectFileRole('unknown.xyz');\n    expect(['source', 'unknown']).toContain(role);\n  });\n});",
            "run_instructions": "npm test -- fileDocumentation.test.ts -t \"should identify configuration files\""
          },
          {
            "id": "file-doc-group-files-1",
            "name": "test_groupFilesByModule_organizes_structure",
            "description": "Verifies file grouping by module",
            "target_function": "groupFilesByModule",
            "target_file": "src/fileDocumentation.ts",
            "scenarios": [
              "Group files by directory",
              "Create module hierarchy",
              "Handle flat structures"
            ],
            "mocks": [],
            "assertions": [
              "Files grouped correctly",
              "Hierarchy preserved",
              "Empty groups handled"
            ],
            "priority": "medium",
            "test_code": "import { groupFilesByModule } from '../fileDocumentation';\n\ndescribe('groupFilesByModule', () => {\n  it('should group files by directory module', () => {\n    const files = [\n      { path: 'src/analyzer/parser.ts', role: 'source' },\n      { path: 'src/analyzer/validator.ts', role: 'source' },\n      { path: 'src/utils/helper.ts', role: 'source' }\n    ];\n\n    const grouped = groupFilesByModule(files);\n\n    expect(grouped['analyzer']).toHaveLength(2);\n    expect(grouped['utils']).toHaveLength(1);\n  });\n\n  it('should handle flat file structure', () => {\n    const files = [\n      { path: 'file1.ts', role: 'source' },\n      { path: 'file2.ts', role: 'source' }\n    ];\n\n    const grouped = groupFilesByModule(files);\n\n    expect(Object.keys(grouped).length).toBeGreaterThan(0);\n  });\n\n  it('should preserve module hierarchy', () => {\n    const files = [\n      { path: 'src/core/analyzer/main.ts', role: 'source' },\n      { path: 'src/core/parser/lexer.ts', role: 'source' }\n    ];\n\n    const grouped = groupFilesByModule(files);\n\n    expect(Object.keys(grouped)).toContain('core');\n  });\n});",
            "run_instructions": "npm test -- fileDocumentation.test.ts -t \"should group files by directory module\""
          }
        ]
      },
      {
        "id": "llm-service",
        "name": "LLM Service Provider Integration",
        "description": "Tests AI language model service communication",
        "test_file_path": "src/test/llmService.test.ts",
        "run_suite_instructions": "npm test -- llmService.test.ts",
        "source_files": [
          "src/llmService.ts"
        ],
        "test_cases": [
          {
            "id": "llm-service-init-1",
            "name": "test_LLMService_initializes_with_config",
            "description": "Verifies LLM service initialization",
            "target_function": "constructor",
            "target_file": "src/llmService.ts",
            "scenarios": [
              "Initialize with OpenAI config",
              "Initialize with Claude config",
              "Handle missing API key"
            ],
            "mocks": [
              "openai",
              "@anthropic-ai/sdk"
            ],
            "assertions": [
              "Service initialized",
              "Config stored",
              "Provider set correctly"
            ],
            "priority": "high",
            "test_code": "import { LLMService } from '../llmService';\nimport OpenAI from 'openai';\nimport Anthropic from '@anthropic-ai/sdk';\n\njest.mock('openai');\njest.mock('@anthropic-ai/sdk');\n\ndescribe('LLMService initialization', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should initialize with OpenAI config', () => {\n    const config = {\n      provider: 'openai',\n      apiKey: 'test-key-123',\n      model: 'gpt-4'\n    };\n\n    const service = new LLMService(config);\n\n    expect(service).toBeDefined();\n    expect(OpenAI).toHaveBeenCalledWith({ apiKey: 'test-key-123' });\n  });\n\n  it('should initialize with Claude config', () => {\n    const config = {\n      provider: 'anthropic',\n      apiKey: 'claude-key-456',\n      model: 'claude-3'\n    };\n\n    const service = new LLMService(config);\n\n    expect(service).toBeDefined();\n    expect(Anthropic).toHaveBeenCalledWith({ apiKey: 'claude-key-456' });\n  });\n\n  it('should handle missing API key gracefully', () => {\n    const config = {\n      provider: 'openai',\n      apiKey: '',\n      model: 'gpt-4'\n    };\n\n    expect(() => new LLMService(config)).not.toThrow();\n  });\n});",
            "run_instructions": "npm test -- llmService.test.ts -t \"should initialize with OpenAI config\""
          },
          {
            "id": "llm-service-request-1",
            "name": "test_LLMService_sends_requests",
            "description": "Verifies LLM API request handling",
            "target_function": "sendRequest",
            "target_file": "src/llmService.ts",
            "scenarios": [
              "Send valid request",
              "Handle API errors",
              "Retry on failures"
            ],
            "mocks": [
              "HTTP client"
            ],
            "assertions": [
              "Request sent",
              "Response parsed",
              "Errors handled"
            ],
            "priority": "high",
            "test_code": "import { LLMService } from '../llmService';\nimport OpenAI from 'openai';\n\njest.mock('openai');\n\ndescribe('LLMService.sendRequest', () => {\n  let service: LLMService;\n  let mockCreate: jest.Mock;\n\n  beforeEach(() => {\n    mockCreate = jest.fn();\n    (OpenAI as jest.MockedClass<typeof OpenAI>).mockImplementation(() => ({\n      chat: {\n        completions: {\n          create: mockCreate\n        }\n      }\n    } as any));\n\n    service = new LLMService({\n      provider: 'openai',\n      apiKey: 'test-key',\n      model: 'gpt-4'\n    });\n  });\n\n  it('should send valid request and parse response', async () => {\n    mockCreate.mockResolvedValue({\n      choices: [{\n        message: {\n          content: JSON.stringify({ result: 'success' })\n        }\n      }]\n    });\n\n    const result = await service.sendRequest('Test prompt');\n\n    expect(mockCreate).toHaveBeenCalled();\n    expect(result).toBeDefined();\n  });\n\n  it('should handle API errors gracefully', async () => {\n    mockCreate.mockRejectedValue(new Error('API Error'));\n\n    await expect(service.sendRequest('Test')).rejects.toThrow();\n  });\n\n  it('should include system prompt in request', async () => {\n    mockCreate.mockResolvedValue({\n      choices: [{ message: { content: '{}' } }]\n    });\n\n    await service.sendRequest('User prompt', 'System instructions');\n\n    expect(mockCreate).toHaveBeenCalledWith(\n      expect.objectContaining({\n        messages: expect.arrayContaining([\n          expect.objectContaining({ role: 'system' }),\n          expect.objectContaining({ role: 'user' })\n        ])\n      })\n    );\n  });\n});",
            "run_instructions": "npm test -- llmService.test.ts -t \"should send valid request and parse response\""
          },
          {
            "id": "llm-service-validate-1",
            "name": "test_LLMService_validates_responses",
            "description": "Verifies response validation against schemas",
            "target_function": "validateResponse",
            "target_file": "src/llmService.ts",
            "scenarios": [
              "Valid JSON passes validation",
              "Invalid structure fails",
              "Missing fields detected"
            ],
            "mocks": [],
            "assertions": [
              "Schema validation works",
              "Errors thrown for invalid data",
              "Valid data passes through"
            ],
            "priority": "high",
            "test_code": "import { LLMService } from '../llmService';\n\ndescribe('LLMService response validation', () => {\n  let service: LLMService;\n\n  beforeEach(() => {\n    service = new LLMService({\n      provider: 'openai',\n      apiKey: 'test',\n      model: 'gpt-4'\n    });\n  });\n\n  it('should validate correct response structure', () => {\n    const validResponse = {\n      insights: [\n        { severity: 'error', description: 'Issue 1' }\n      ],\n      health: 85\n    };\n\n    expect(() => service.validateResponse(validResponse, 'insights-schema')).not.toThrow();\n  });\n\n  it('should reject invalid response structure', () => {\n    const invalidResponse = {\n      wrong_field: 'value'\n    };\n\n    expect(() => service.validateResponse(invalidResponse, 'insights-schema')).toThrow();\n  });\n\n  it('should detect missing required fields', () => {\n    const incompleteResponse = {\n      insights: []\n    };\n\n    expect(() => service.validateResponse(incompleteResponse, 'insights-schema')).toThrow();\n  });\n});",
            "run_instructions": "npm test -- llmService.test.ts -t \"should validate correct response structure\""
          }
        ]
      },
      {
        "id": "insights-tree-view",
        "name": "Insights Tree View UI",
        "description": "Tests tree view component for displaying insights",
        "test_file_path": "src/test/insightsTreeView.test.ts",
        "run_suite_instructions": "npm test -- insightsTreeView.test.ts",
        "source_files": [
          "src/insightsTreeView.ts"
        ],
        "test_cases": [
          {
            "id": "tree-view-refresh-1",
            "name": "test_InsightsTreeView_refreshes_data",
            "description": "Verifies tree view refresh updates display",
            "target_function": "refresh",
            "target_file": "src/insightsTreeView.ts",
            "scenarios": [
              "Refresh with new insights",
              "Clear and refresh",
              "Update existing items"
            ],
            "mocks": [
              "vscode.TreeDataProvider"
            ],
            "assertions": [
              "Data updated",
              "Event fired",
              "Tree rebuilt"
            ],
            "priority": "medium",
            "test_code": "import { InsightsTreeProvider } from '../insightsTreeView';\nimport * as vscode from 'vscode';\n\njest.mock('vscode');\n\ndescribe('InsightsTreeProvider.refresh', () => {\n  let provider: InsightsTreeProvider;\n  let mockOnDidChangeTreeData: any;\n\n  beforeEach(() => {\n    mockOnDidChangeTreeData = { fire: jest.fn() };\n    provider = new InsightsTreeProvider();\n    (provider as any)._onDidChangeTreeData = mockOnDidChangeTreeData;\n  });\n\n  it('should fire change event on refresh', () => {\n    provider.refresh();\n\n    expect(mockOnDidChangeTreeData.fire).toHaveBeenCalled();\n  });\n\n  it('should update with new insights', () => {\n    const newInsights = [\n      { severity: 'error', description: 'New error', file: 'test.ts' }\n    ];\n\n    provider.updateInsights(newInsights);\n    provider.refresh();\n\n    expect(mockOnDidChangeTreeData.fire).toHaveBeenCalled();\n  });\n\n  it('should handle empty insights', () => {\n    provider.updateInsights([]);\n    provider.refresh();\n\n    expect(mockOnDidChangeTreeData.fire).toHaveBeenCalled();\n  });\n});",
            "run_instructions": "npm test -- insightsTreeView.test.ts -t \"should fire change event on refresh\""
          },
          {
            "id": "tree-view-get-children-1",
            "name": "test_InsightsTreeView_returns_children",
            "description": "Verifies tree structure building",
            "target_function": "getChildren",
            "target_file": "src/insightsTreeView.ts",
            "scenarios": [
              "Root level returns categories",
              "Category returns insights",
              "Insight returns empty"
            ],
            "mocks": [],
            "assertions": [
              "Correct hierarchy",
              "Children match parent",
              "Leaf nodes return empty"
            ],
            "priority": "medium",
            "test_code": "import { InsightsTreeProvider } from '../insightsTreeView';\n\ndescribe('InsightsTreeProvider.getChildren', () => {\n  let provider: InsightsTreeProvider;\n\n  beforeEach(() => {\n    provider = new InsightsTreeProvider();\n    provider.updateInsights([\n      { severity: 'error', category: 'complexity', description: 'Error 1', file: 'a.ts' },\n      { severity: 'warning', category: 'style', description: 'Warning 1', file: 'b.ts' }\n    ]);\n  });\n\n  it('should return categories at root level', async () => {\n    const children = await provider.getChildren();\n\n    expect(children).toBeDefined();\n    expect(children.length).toBeGreaterThan(0);\n  });\n\n  it('should return insights for category', async () => {\n    const categories = await provider.getChildren();\n    const categoryItem = categories[0];\n    const insights = await provider.getChildren(categoryItem);\n\n    expect(insights).toBeDefined();\n  });\n\n  it('should return empty for leaf nodes', async () => {\n    const categories = await provider.getChildren();\n    const categoryItem = categories[0];\n    const insights = await provider.getChildren(categoryItem);\n    const leafItem = insights[0];\n    const children = await provider.getChildren(leafItem);\n\n    expect(children).toEqual([]);\n  });\n});",
            "run_instructions": "npm test -- insightsTreeView.test.ts -t \"should return categories at root level\""
          }
        ]
      },
      {
        "id": "diagnostics-provider",
        "name": "Diagnostics Provider",
        "description": "Tests inline diagnostic annotations",
        "test_file_path": "src/test/diagnosticsProvider.test.ts",
        "run_suite_instructions": "npm test -- diagnosticsProvider.test.ts",
        "source_files": [
          "src/diagnosticsProvider.ts"
        ],
        "test_cases": [
          {
            "id": "diagnostics-create-1",
            "name": "test_DiagnosticsProvider_creates_diagnostics",
            "description": "Verifies diagnostic creation from insights",
            "target_function": "updateDiagnostics",
            "target_file": "src/diagnosticsProvider.ts",
            "scenarios": [
              "Create diagnostics for errors",
              "Set correct severity",
              "Include message and location"
            ],
            "mocks": [
              "vscode.DiagnosticCollection"
            ],
            "assertions": [
              "Diagnostics created",
              "Severity mapped correctly",
              "Locations accurate"
            ],
            "priority": "medium",
            "test_code": "import { InsightsDiagnosticsProvider } from '../diagnosticsProvider';\nimport * as vscode from 'vscode';\n\njest.mock('vscode');\n\ndescribe('InsightsDiagnosticsProvider.updateDiagnostics', () => {\n  let provider: InsightsDiagnosticsProvider;\n  let mockCollection: any;\n\n  beforeEach(() => {\n    mockCollection = {\n      clear: jest.fn(),\n      set: jest.fn()\n    };\n    (vscode.languages as any).createDiagnosticCollection = jest.fn(() => mockCollection);\n    provider = new InsightsDiagnosticsProvider();\n  });\n\n  it('should create diagnostics from insights', () => {\n    const insights = [\n      { severity: 'error', file: 'test.ts', line: 10, description: 'Error message' }\n    ];\n\n    provider.updateDiagnostics(insights);\n\n    expect(mockCollection.set).toHaveBeenCalled();\n  });\n\n  it('should map severity correctly', () => {\n    const insights = [\n      { severity: 'error', file: 'test.ts', line: 5, description: 'Err' },\n      { severity: 'warning', file: 'test.ts', line: 10, description: 'Warn' },\n      { severity: 'info', file: 'test.ts', line: 15, description: 'Info' }\n    ];\n\n    provider.updateDiagnostics(insights);\n\n    expect(mockCollection.set).toHaveBeenCalled();\n  });\n\n  it('should clear previous diagnostics', () => {\n    provider.updateDiagnostics([]);\n\n    expect(mockCollection.clear).toHaveBeenCalled();\n  });\n});",
            "run_instructions": "npm test -- diagnosticsProvider.test.ts -t \"should create diagnostics from insights\""
          }
        ]
      }
    ],
    "read_write_test_suites": [],
    "user_workflow_test_suites": []
  }
}