// Mock VS Code API for Jest tests
// Auto-generated by Shadow Watch
// This file is only used at test runtime, not during extension compilation

// Use type-safe mock functions that work without Jest types at compile time
const createMockFn = () => {
  const fn: any = function(...args: any[]) { return fn.mockReturnValue ? fn.mockReturnValue() : undefined; };
  fn.mockReturnValue = (value: any) => { fn._returnValue = value; return fn; };
  fn.mockResolvedValue = (value: any) => { fn._returnValue = Promise.resolve(value); return fn; };
  fn.mockRejectedValue = (value: any) => { fn._returnValue = Promise.reject(value); return fn; };
  fn.mockImplementation = (impl: any) => { fn._impl = impl; return fn; };
  fn.mock = { calls: [], results: [] };
  return fn;
};

// EventEmitter mock
export class EventEmitter<T> {
  private listeners: ((e: T) => any)[] = [];
  
  event = (listener: (e: T) => any) => {
    this.listeners.push(listener);
    return { dispose: () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    } };
  };
  
  fire(data: T): void {
    this.listeners.forEach(listener => listener(data));
  }
  
  dispose(): void {
    this.listeners = [];
  }
}

export const window = {
  showInformationMessage: createMockFn(),
  showErrorMessage: createMockFn(),
  showWarningMessage: createMockFn(),
  createOutputChannel: (() => {
    const fn = createMockFn();
    fn.mockReturnValue({
      appendLine: createMockFn(),
      clear: createMockFn(),
      dispose: createMockFn(),
      show: createMockFn()
    });
    return fn;
  })(),
  showTextDocument: createMockFn(),
  createTextEditorDecorationType: createMockFn(),
  activeTextEditor: undefined
};

export const workspace = {
  getConfiguration: (() => {
    const fn = createMockFn();
    fn.mockReturnValue({
      get: createMockFn(),
      has: createMockFn(),
      update: createMockFn(),
      inspect: createMockFn()
    });
    return fn;
  })(),
  workspaceFolders: [],
  onDidChangeConfiguration: createMockFn(),
  onDidChangeWorkspaceFolders: createMockFn(),
  findFiles: createMockFn(),
  openTextDocument: createMockFn()
};

export const commands = {
  registerCommand: createMockFn(),
  executeCommand: createMockFn()
};

export class Uri {
  static file(path: string) {
    return { fsPath: path, scheme: 'file', path: path };
  }
  static joinPath(...parts: any[]) {
    return { fsPath: parts.join('/'), scheme: 'file' };
  }
  fsPath: string;
  scheme: string;
  constructor() {
    this.fsPath = '';
    this.scheme = 'file';
  }
}

export class ExtensionContext {
  subscriptions: any[] = [];
  workspaceState: any = {
    get: createMockFn(),
    update: createMockFn()
  };
  globalState: any = {
    get: createMockFn(),
    update: createMockFn(),
    setKeysForSync: createMockFn()
  };
  extensionPath: string = '';
  asAbsolutePath: any = (() => {
    const mockFn = createMockFn();
    mockFn.mockImplementation((path: string) => path);
    return mockFn;
  })();
}

export const ViewColumn = {
  One: 1,
  Two: 2,
  Three: 3,
  Active: -1,
  Beside: -2
};

export const ConfigurationTarget = {
  Global: 1,
  Workspace: 2,
  WorkspaceFolder: 3
};

export const TreeItemCollapsibleState = {
  None: 0,
  Collapsed: 1,
  Expanded: 2
};

export const ProgressLocation = {
  SourceControl: 1,
  Window: 10,
  Notification: 15
};

export class TreeItem {
  label: string | any;
  collapsibleState?: TreeItemCollapsibleState;
  command?: any;
  contextValue?: string;
  description?: string;
  iconPath?: any;
  tooltip?: string;
  
  constructor(
    label: string | any,
    collapsibleState?: TreeItemCollapsibleState
  ) {
    this.label = label;
    this.collapsibleState = collapsibleState;
  }
}

export class Disposable {
  constructor(private callOnDispose: () => void) {}
  dispose() {
    this.callOnDispose();
  }
  static from(...disposables: { dispose(): any }[]): Disposable {
    return new Disposable(() => {
      disposables.forEach(d => d.dispose());
    });
  }
}
